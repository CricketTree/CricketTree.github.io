{"meta":{"title":"This is Title","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2023-10-27T15:04:19.000Z","updated":"2023-10-27T17:10:23.471Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Welcome to my blog! Have a nice day!"},{"title":"categories","date":"2023-10-27T14:56:34.000Z","updated":"2023-10-27T15:00:41.794Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"汇编学习-2.4 物理地址","slug":"汇编学习-2.4 物理地址","date":"2023-12-01T03:56:27.000Z","updated":"2023-11-15T04:04:40.215Z","comments":true,"path":"2023/12/01/汇编学习-2.4 物理地址/","link":"","permalink":"http://example.com/2023/12/01/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.4%20%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/","excerpt":"","text":"CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有惟一的地址，我们将这个惟一的地址称为物理地址 CPU 通过地址总线送入存储器的必须是一个内存单元的物理地址，在 CPU 向地址总线上发出物理地址之前，必须在内部先形成这个物理地址。不同的 CPU 可以有不同的形成物理地址的方式 我们要研究的是 8086CPU，我们知道 8086CPU 的上一代等是 8 位机，而 8086CPU 是 16 位机，也可以说是 16 位结构的 CPU，现在我们先来了解一下什么是 16 位结构的 CPU 简单的， 16 位结构讲的是 CPU 具有以下几个结构特性： * 运算器一次最多可以处理 16 位的数据 * 寄存器的最大宽度为 16 位 * 寄存器与运算器之间的通路为 16 位 这也就是说，16 位结构的 CPU 能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的（内存单元的地址在送上地址总线之前，必须在 CPU 中处理、传输、暂时存放） 在学习 8086CPU 是怎么给出物理地址之前，我们先来梳理一下 8086CPU： 8086CPU 有 20 位地址总线，可以传送 20 位地址，达到 1 mb 的寻址能力；又是 16 位结构，在内部一次性处理、传输、暂时存储的地址为 16 位，从 8086CPU 内部结构来看，如果将地址从内部简单的发出，那么它只能送出 16 位的地址，表现出的寻址能力只有 64 kb 而 8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址 当 CPU 要读取内存时： 1. CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址 2. 段地址和偏移地址通过内部总线被送入一个称为地址加法器的部件 3. 地址加法器将两个 16 位地址合成为一个 20 位的物理地址 4. 地址加法器通过内部总线将 20 位物理地址送上地址总线 5. 20 位物理地址被地址总线传送到存储器 地址加法器采用 物理地址&#x3D;段地址×16+偏移地址 的方法用段地址和偏移地址合成物理地址（其中的 16 是十进制数）下图是一个例子： ![](&#x2F;images&#x2F;汇编学习-2.4 物理地址&#x2F;image-1-1024x418.png) 由 段地址 × 16 引发的讨论 “段地址 × 16” 有一个更为常用的说法是左移 4 位（这个 4 位指的是二进制的 4 位，因为计算机中的所有信息都是以二进制的形式存储的，段地址当然也不例外） 我们来看一个例子：一个数据为 2h，二进制形式为 10b，对其进行左移位运算： 左移位数二进制十六进制十进制010b2h21100b4h421000b8h8310000b10h164100000b20h32_观察上面位移次数和各种形式数据的关系，我们可以发现啊：_ * 一个数据的二进制形式左移 1 位相当于该数据乘以 2 * 一个数据的二进制形式左移 N 位相当于该数据乘以 2N * 地址加法器如何完成 段地址 × 16 的运算？就是将以二进制形式存放的段地址左移 4 位 进一步思考，我们可以看出：一个数据的十六进制数形式左移 1 位，相当于乘以 16；一个数据的十进制形式左移 1 位，相当于乘以 10；一个 X 进制的数据左移 1 位，相当于乘以 X","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"网鼎杯2020青龙组-singal","slug":"[网鼎杯2020青龙组]singal","date":"2023-11-15T03:15:23.000Z","updated":"2023-11-15T03:47:59.577Z","comments":true,"path":"2023/11/15/[网鼎杯2020青龙组]singal/","link":"","permalink":"http://example.com/2023/11/15/[%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84]singal/","excerpt":"","text":"这道题是道虚拟机题，有静态和动调两种方式解决 方法一：静态分析说是静态分析，其实就是把他给的虚拟机代码和数据库复制粘贴来用，图二中的就是虚拟机的运行代码，我们要的数据库就是 v4，在图一第 6 行，把 unk_403040 处的值赋给了 v4，这样我们得到了 v4 注意提取的时候它默认给的是unsigned char类型的，这个很重要、 接下来就是先观察一下虚拟机的代码是怎么运行的 这里我们注意到 result 是Str的长度，需要为15才行，所以flag的长度是15 因为在case 10和case 7中间运行了多少步我们是不好求的，但是case 7中的a1[v9 + 1]我们是必须要知道的，这样才知道Str[v7 + 100]是多少，逆向才能继续。然后如果我们知道了a1[v9 + 1]都是些什么，接下来要怎么反过来求最初的flag我们也要思考，既然是用虚拟机的代码和它给的固定数据库实现运行得到的a1[v9 + 1]，那么我们也可以将虚拟机的代码完全反过来，数据库的数据也全部反过来，再结合a1[v9 + 1]就可以运行新的代码得到flag。要实现这个就需要记录v9是怎么变化的，因为switch里的是a1[v9]，那么v9是怎么个取值过程我们必须知道， 知道了要求什么了之后，我们就可以把代码复制粘贴好后稍作修改就可以用了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char vmcode[] = //数据库&#123; 0x0A, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xA7, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x84, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 &#125;;int* a = (int*)vmcode;int __cdecl vm_operad(int* code, int len114)&#123; char order[114] = &#123;&#125;; //用来记录v9的值的变化过程 char flag[200]; //记录我们要的a1[v9 + 1] char tmp; int m = 0; int v9 = 0; int v7 = 0; int v8 = 0; int v6 = 0; int v5 = 0; while (1) &#123; if (v9 &gt;= len114) break; switch (code[v9]) &#123; case 1: flag[v6 + 100] = tmp; ++v9; ++v6; ++v8; break; case 2: tmp = code[v9 + 1] + flag[v8]; v9 += 2; break; case 3: tmp = flag[v8] - code[v9 + 1]; v9 += 2; break; case 4: tmp = code[v9 + 1] ^ flag[v8]; v9 += 2; break; case 5: tmp = code[v9 + 1] * flag[v8]; v9 += 2; break; case 6: ++v9; break; case 7: flag[v7+100] = code[v9 + 1]; //把判断改为直接赋值，因为我们要知道值是什么 printf(&quot;%#x,&quot;, flag[v7+100]); //以16进制的形式输出出来 ++v7; v9 += 2; break; case 8: flag[v5] = tmp; ++v9; ++v5; break; case 10: printf(&quot;请输入flag：&quot;); //手动输入数据 scanf(&quot;%s&quot;,flag); ++v9; break; case 11: tmp = flag[v8] - 1; ++v9; break; case 12: tmp = flag[v8] + 1; ++v9; break; &#125; order[m++] = v9; //每运行一步就记录一次v9的值 &#125; printf(&quot;\\nv9的值依次是：\\n&quot;); for (int i = 0; i &lt; strlen(order); i++) &#123; printf(&quot;%d,&quot;,order[i]); &#125; return 0;&#125;int main()&#123; vm_operad(a, 114); return 0;&#125; 可以看到除了case 7和case 10其它的都是不变的，直接照搬过来 符串就行 这样我们就得到了我们想要的，再把虚拟机的代码反过来修改一下运行就可以得到flag了。需要注意的是，v9我们已经得到了，所以v9怎么赋值是我们来决定的，在修改虚拟机代码的时候就不需要v9++什么的代码了，直接删掉就可以，但是其他的都需要保留。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;stdio.h&gt;#include&lt;string.h&gt;unsigned char vmcode[] = //数据库&#123; 0x0A, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xA7, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x84, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC1, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 &#125;;int __cdecl vm_solve(int* code, int len114)&#123; unsigned char flag[100] = &#123;&#125;; unsigned char v4[] = &#123; 0x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xffffffa7,0x31,0xfffffff1,0x28,0xffffff84,0xffffffc1,0x1e,0x7a &#125;; //因为flag的前百位和后百位是独立的，所以我将flag的后百位分出来新设了一个数组v4 char order[100] = &#123; 1,3,4,6,7,9,10,12,13,15,16,17,18,19,20,22,23,25,26,28,29,30,31,32,33,35,36,38,39,41,42,44,45,46,47,48,49,51,52,54,55,57,58,60,61,63,64,66,67,69,70,72,73,75,76,78,79,81,82,83,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114 &#125;; int tmp; int v6 = 15; int v8 = 15; int v5 = 15; int v9 = 0; for (int j = strlen(order) - 1; j &gt;= 0; j--) //v9是从order的后面往前取的，所以j=strlen(order)-1 &#123; v9 = order[j]; //v9按照正向运行得到的值反过来取一遍 switch (code[v9]) &#123; case 1: --v6; --v8; tmp = v4[v6]; break; case 2: //tmp = code[i + 1] + flag[v8]; flag[v8] = tmp - char(code[v9 + 1]); break; case 3: //tmp = flag[v8] - code[i + 1]; flag[v8] = tmp + char(code[v9 + 1]); break; case 4: //tmp = code[i + 1] ^ flag[v8]; flag[v8] = (tmp ^ code[v9 + 1]) &amp; 0xFF; //&amp; 0xFF是为了确保是取低二位，在这里有没有&amp; 0xFF结果一样 break; case 5: //tmp = code[i + 1] * flag[v8]; flag[v8] = tmp / code[v9 + 1]; break; case 6: break; case 8: //flag[v5] = tmp; --v5; tmp = flag[v5]; break; case 11: //tmp = flag[v8] - 1; flag[v8] = tmp + 1; break; case 12: //tmp = flag[v8] + 1; flag[v8] = tmp - 1; break; &#125; &#125; printf(&quot;%s&quot;, flag); return 0;&#125;int main()&#123; vm_solve(a, 114); return 0;&#125; 运行一下，得到flag 方法二：动态调试用动调的方法，也是需要求出a1[v9 + 1]也就是用来比较的值的，只不过不是像上面那样复制粘贴运行来求，我们用动调的方式来求： 首先我们要先下好断点，我在下面几个地方下的断点，仅供参考： 断点设完之后，我们要让程序能够运行到退出循环才行，但是我们不知道flag，没法确保case 7进行比较的时候能够顺利通过，所以我们将图十三的 je 0x004016FE 改成 jmp 0x004016FE，这样我们只要在运行到这里的时候看一下用来比较的值是什么就可以了，接下来可以继续运行然后看下一个进行比较的值直到循环结束 现在来运行， 到了输入的地方，我们知道flag是15位的，输入一个15位的字符串，特别注意这里是把我们输入的flag放到了ss:[ebp+8]，这个要留意，对后面判断哪一个是我们要的数据很重要 这里我们看到在比较之前最后对eax进行操作的是004014E0处的指令，它是把ds:[eax]处的值放到了eax中，并不是我们输入的flag（上面提到了我们输入的flag是放到了ss:[ebp+8]处），所以这时eax里的值就是我们要的，记录这里eax里的值：0x22 然后我们直接F9运行 按了F9后可以发现画面并没有动，但其实是循环回来后有运行到了这个断点停下了，我们看到这个时候eax里的值是0x3F，记录下来，然后重复F9运行，记录eax里的值的操作，知道运行到我们设的断点四退出循环 ![](&#x2F;images&#x2F;[网鼎杯 2020 青龙组]singal&#x2F;image-21-1024x328.png) 15次比较完了后，就马上要退出循环了，运行到第四个断点，这样我们就得到了要用来比较的值都是什么了 然后分析一下源代码可以得到每个值是怎么得到的 123456789101112131415161718192021222324252627282930class=&quot;wp-block-syntaxhighlighter-code&quot;&gt;0x22 = (flag[0] ^ 0xa) - 50x3f = (flag[1] ^ 0x20) * 30x34 = (flag[2] - 2) - 10x32 = (flag[3] + 1) ^ 40x72 = (flag[4] * 3) - 0x210x33 = (flag[5] - 1) - 1 0x18 = (flag[6] ^ 9) - 0x200xffffffa7 = (flag[7] + 0x51) ^ 0x240x31 = (flag[8] +1 ) - 10xfffffff1 = (flag[9] * 2) + 0x250x28 = (flag[10] + 0x36) ^ 0x410xffffff84 = (flag[11] + 0x20) * 10xffffffc1 = (flag[12] *3) + 0x250x1e = (flag[13] ^ 9) - 0x200x7a = (flag[14] + 0x41) + 1 然后写出脚本得到flag 1234567891011121314151617181920212223x = [0x22,0x3f,0x34,0x32,0x72,0x33,0x18,0xffffffa7,0x31, 0xfffffff1,0x28,0xffffff84,0xffffffc1,0x1e,0x7a]flag = [0]*15flag[0] = (x[0] + 5) ^ 0x10flag[1] = (x[1] // 3) ^ 0x20flag[2] = (x[2] + 3)flag[3] = (x[3] ^ 4) - 1flag[4] = (x[4] + 0x21) // 3flag[5] = x[5] + 2flag[6] = (x[6] + 0x20) ^ 9flag[7] = ((x[7] &amp; 0xFF) ^ 0x24) - 0x51flag[8] = x[8]flag[9] = ((x[9] &amp; 0xFF) - 0x25) // 2flag[10] = (x[10] ^ 0x41) - 0x36flag[11] = (x[11] &amp; 0xFF) - 0x20flag[12] = ((x[12] &amp; 0xFF) - 0x25) // 3flag[13] = (x[13] + 0x20) ^ 9flag[14] = (x[14] - 1) - 0x41result = &quot;&quot;for i in range(len(flag)): result += chr(flag[i])print(result) 得到flag","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"}],"tags":[]},{"title":"PE文件格式-运行时压缩","slug":"PE文件格式-运行时压缩","date":"2023-11-14T15:14:22.000Z","updated":"2023-11-15T03:17:37.816Z","comments":true,"path":"2023/11/14/PE文件格式-运行时压缩/","link":"","permalink":"http://example.com/2023/11/14/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"14.1数据压缩不论哪种形态的文件（数据）都是由二进制组成的，只要使用合适的压缩算法，就能缩减其大小。经过压缩的文件若能100%恢复，则称该压缩为“无损压缩”；若不能，则称为“有损压缩” 14.1.1无损压缩无损压缩用来缩减文件（数据）的大小，压缩后的文件更易保管、移动。使用经过压缩的文件之前，需要先对文件解压缩（此过程中应该保证数据完整性） 7z、ZIP、RAR等都是具有代表性的压缩文件格式，，它们最根本的压缩理念是Run-Length、Lempel-Ziv、Huffman（这些都是最具代表性的无损压缩算法，还有许多其它压缩算法都是在上面3种压缩算法的基础上改造而成的），然后各自应用了一些各自特有的技术（压缩率、压缩\\解压时间） 14.1.2有损压缩有损压缩运行压缩文件（数据）时损失一定信息，以此换取高压缩率。压缩多媒体文件（jpg、mp3、mp4）时，大部分都使用这种有损压缩方式。人类的肉眼与听觉几乎无法察觉到这些多媒体文件在压缩中损失的数据。以mp3为例，mp3的核心算法通过删除超越人类听觉范围（20~20000Hz）的波长区段来缩减（不需要的数据大小） 14.2运行时压缩器运行时压缩器时针对可执行文件而言的，可执行文件内部含有解压缩代码，文件在运行瞬间于内存中解压缩后执行 运行时压缩文件也是PE文件，内部含有原PE文件与解码程序。在程序的EP代码中执行解码程序，同时在内存中解压缩后执行 项目 普通压缩 运行时压缩 对象文件 所有文件 PE文件（exe、dll、sys） 压缩结果 压缩文件（zip、rar） PE文件（exe、dll、sys） 解压缩方式 使用专门解压缩程序 内部含有解码程序 文件是否可执行 本身不可执行 本身可执行 优点 可以对所有文件以高压缩率压缩 无需专门解压程序便可直接运行 缺点 若无专门解压缩软件则无法使用压缩文件 每次运行均需要调用解码程序导致运行时间过长 可以看到，与普通压缩器相比，运行时压缩器的一个明显不同时“PE文件的可运行性” 把普通PE文件创建成运行时压缩文件的实用程序称为“压缩器”（Packer），经反逆向（Anti-Reversing）技术特别处理的压缩器称为保护器（Protector） 14.2.1压缩器#1.使用目的缩减PE文件的大小 隐藏PE文件内部代码与资源（字符串、API名称字符串等） #2.压缩器种类PE压缩器大致可分为两种： 一类是单纯用于压缩普通PE文件的压缩器，比如说UPX、ASPack等 另一类是对源文件进行较大变形、严重破坏PE头、意图稍显不纯的压缩器（这里的意图不纯的压缩器是指专门用于恶意程序，如Virtus、Trojan、Worm等），比如说UPack、PESpin、NSAnti等 14.2.2保护器不同于普通的压缩器，保护器还会应用多种防止代码逆向分析的技术（反调试、反模拟、代码混乱、多态代码、垃圾代码、调试器监视等）。这类保护器使压缩后的PE文件尺寸反而比源文件要大一些 #1.使用目的防止破解 不仅可以保护PE文件本身，还可以在文件运行时保护进程内存，防止打开Dump窗口 #2.使用现状比如说游戏的安全保护程序。当然还有那些意图不纯的恶心代码（Trojan、Worm）中也大量使用保护器来防止（或降低）杀毒软件的检测。有些保护器还能提供“多变的代码”，每次都会生成不同形态当功能相同的代码，这给病毒诊断带来很大困难 14.3运行时压缩测试以notepad.exe为例进行运行时压缩测试","categories":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"14章-运行时压缩","slug":"逆向工程核心原理/14章-运行时压缩","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/14%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/"}],"tags":[]},{"title":"Python base64 编解码","slug":"Python base64 编解码","date":"2023-10-31T10:04:14.000Z","updated":"2023-10-31T10:07:54.898Z","comments":true,"path":"2023/10/31/Python base64 编解码/","link":"","permalink":"http://example.com/2023/10/31/Python%20base64%20%E7%BC%96%E8%A7%A3%E7%A0%81/","excerpt":"","text":"Python base64 编解码1. 引入 base64 模块想要在 python 中使用 base64 编解码，我们要先引入 base64 模块 1import base64 这个时候我们就可以使用 base64 模块中的相关功能了 2. 正常的 base64 编码方法在使用编码的函数之前，需要对字符串进行 utf-8 编码一下，不然 python 的 base64 库的函数没法识别对应的字符串而报错；不过解码的时候不需要这部操作 2.1 base64 编码我们来看一下在 Python 中进行 base64 编码的过程， 1234567891011121314151617import base64#引入 base64 模块str = &#x27;hello&#x27;#定义一个字符串bstr = str.encode()#将我们定义的字符串转换为 utf-8#encode()的括号内不填任何内容就会被默认为 &#x27;utf-8&#x27;b64str = base64.b64encode(bstr)#进行 base64 编码print(b64str)#输出编码后的字符串#最后的输出结果是 b&#x27;aGVsbG8=&#x27; 2.2 base64 解码我们再来看一下 base64 的解码过程， 1234567891011121314import base64#引入 base64 模块b64str = &#x27;aGVsbG8=&#x27;#定义一个已编码的字符串str = base64.b64decode(b64str)#进行 base64 解码print(str)#输出解码后的字符串#最后的输出结果是 b&#x27;hello&#x27; 3. 特殊的 base64 编解码什么是特殊的呢，就是其中的编码规则被修改后的编解码 我们知道，标准的 base64 编解码是由一个标准的码表的，那我们修改了这个标准码表后，那编解码的结果也会有所改变，现在我们就来学习一下怎么进行码表修改和进一步编解码 我们先来了解几个语句： 3.1 Python translate()Python translate（） 根据参数表给出的表（包含 256 个字符）转换字符串的字符， 要过滤掉的字符放到 del 参数中 str.translate(table[, deletechars]) 参数： table : 翻译表，翻译表是通过 maketrans 方法转换而来。 deletechars : 字符串中要过滤的字符列表。 Python translate（）的返回值是翻译后的字符串 具体的实例我们在 Python maketrans() 中一起展示 3.1 Python maketrans()Python maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 注：两个字符串的长度必须相同，为一一对应的关系。 str.maketrans(intab, outtab) 参数： intab : 字符串中要被替换的字符组成的字符串 outtab : 字符串中要替换成的字符组成的字符串 Python maketrans() 的返回值是字符串转换后生成的新字符串 123456789101112131415#我们来看一个实例：#Python 3#这里不用引用 string 模块或者从 string 模块中引用 maketrans#这和 Python 2.x 不同，Python 2.x 需要引用上述内容intab = &#x27;adzio5&#x27;outtab = &#x27;@4210S&#x27;trantab = str.maketrans(intab,outtab)str = &#x27;Crazy Thurday vivo 50&#x27;#疯狂暗示print(str.translate(trantab))#最后的输出结果是 Cr@2y Thur4@y v1v0 S0 我们可以看到，intab 中出现的字符都被替换成 outtab 中对应的字符 3.3 实际操作有了以上的知识，我们可以来进行简单的码表替换的 base64 编解码 真是太巧了，我刚好遇到了一道这样的题，我们来看看 已知，base64 的原码表是 ‘ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;‘ 在题目里它被替换成了 ‘TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;‘ 而 flag 被编码后是 ‘d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD&#x3D;&#x3D;’ 现在我们来求一下 flag 首先呢，我们肯定要把码表给换回来，那么就要用到 maketrans() 和 translate() 那我们换回来后呢，还是在已编码状态，所以我们要解码，这样就能得到 flag 了 我们来看一下代码： 1234567891011121314151617181920import base64#引入 base64 库str1 = &quot;d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==&quot;string1 = &quot;TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;trantab = str.maketrans(string1,string2)trlate = str1.translate(trantab)#把 str1 里 string1 的对应字符转换成 string2 中的对应字符#也就是换表a = base64.b64decode(trlate)#最后解码print(a)#最后输出的结果是 b&#x27;wctf2020&#123;Base64_is_the_start_of_reverse&#125;&#x27; 就是这么简单","categories":[{"name":"Python相关","slug":"Python相关","permalink":"http://example.com/categories/Python%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"线性结构和非线性结构","slug":"线性结构和非线性结构","date":"2023-10-31T10:02:34.000Z","updated":"2023-10-31T10:08:10.211Z","comments":true,"path":"2023/10/31/线性结构和非线性结构/","link":"","permalink":"http://example.com/2023/10/31/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/","excerpt":"","text":"线性结构和非线性结构▲线性结构首先，我们先了解一下线性结构： 线性是种什么样的关系呢，简单的理解就是，有一定的联系，即数据之间是相关的。说的学术一点就是数据元素之间存在一对一的线性关系。 而数据元素之间不一定是物理地址上的连续才是线性的，主要看我们如何利用，所以，线性结构的存储可以分为顺序存储&nbsp;和&nbsp;链式存储这两种 看第一张图，其中的数据在地址上是连续存放的，这种存储方式称之为顺序存储。这个线性表称为顺序表。 看第二张图，其中的数据在地址上不是连续存放的，但是我们依然可以用一条链串起来，这种方式称之为链式存储，这个线性表称为链表。 线性结构常见的有：数组，队列，链表和栈 ▲非线性结构在非线性结构中，每个数据不想线性结构一样，保持在一个线性序列中，也就是每个数据之间没有一定的关系。 常见的非线性结构有：二维数组，多维数组，广义表","categories":[{"name":"栈相关","slug":"栈相关","permalink":"http://example.com/categories/%E6%A0%88%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"利用二维数组计算矩阵行列式的值 —— 按行展开计算法","slug":"利用二维数组计算矩阵行列式的值 —— 按行展开计算法","date":"2023-10-31T10:02:00.000Z","updated":"2023-11-14T16:30:31.209Z","comments":true,"path":"2023/10/31/利用二维数组计算矩阵行列式的值 —— 按行展开计算法/","link":"","permalink":"http://example.com/2023/10/31/%E5%88%A9%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E5%80%BC%20%E2%80%94%E2%80%94%20%E6%8C%89%E8%A1%8C%E5%B1%95%E5%BC%80%E8%AE%A1%E7%AE%97%E6%B3%95/","excerpt":"","text":"利用二维数组计算矩阵行列式的值 —— 按行展开计算法![](&#x2F;images&#x2F;利用二维数组计算矩阵行列式的值 —— 按行展开计算法&#x2F;image-70-1368x2048.png) 遇到一道经典题型–求矩阵行列式的值，我们用 C&#x2F;C++ 来实现 1. 基本思路在计算行列式的时候，如果低阶的话，可以很容易算出来，但是阶数高的时候没法在程序里用最基本的算法，也就是对角线法则，将其一项一项进行运算 这时候我们就要将其降阶，具体方法就是将其按照某一行展开，在程序里为了方便就都以第一行展开，并将代数余子式再按其第一列展开，然后以此类推，直到得到了 3 阶或 3 阶以下的子矩阵。为什么是 3 阶或 3 阶以下呢？因为这种低阶数的可以用对角线法则直接计算，当然，为了程序编写方便，我们可以直接将其降阶到 1 阶（一阶行列式 的值等于其唯一元素的值，如 ‘4’ &#x3D;&#x3D; 4） 2. 实现方法2.1 主函数(附上头文件与宏定义)我们要先确定函数要执行些什么、顺序是怎么样的。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;iomanip&gt; //we need it to use setprecision()#include&lt;math.h&gt; //we need it to use pow()#define N 20 //the max size of matrixint main()&#123; int n; //matrix size double a[N][N]; //matrix double result; cout &lt;&lt; &quot;Please enter matrix size n(1&lt;=n&lt;20)\\n&quot;; cin &gt;&gt; n; //input the matrix size n cout &lt;&lt; &quot;Please input matrix line by line:\\n&quot;; InputMatrix(a, n); //input the matrix PrintMatrix(a, n); //print the matrix result = DeterminantValue(); //get the result of the matrix cout &lt;&lt; result; //print the result&#125; 首先是输入阶数，然后再输入矩阵（InputMatrix），然后输出矩阵（PrintMatrix），接着就是计算出矩阵行列式的值（DeterminantValue），最后输出出来就行了 接下来我们详细看一下每个阶段的函数 2.2 InputMatrix()12345678910void InputMatrix(double a[N][N],int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; a[i][j]; //input the elements of the matrix &#125; &#125;&#125; 依项输入 2.3 PrintMatrix()1234567891011void PrintMatrix(double a[N][N],int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; a[i][j]; //print the elements of the matrix &#125; cout &lt;&lt; endl; &#125;&#125; 依项输出，注意换行 2.4 DeterminantValue()这个函数是这个程序的核心函数，也是最重要的函数。我们先来复习一下线性代数，**’A’ &#x3D; a11A11 + a12A12 + …… + a1nA1n &#x3D; Σa1nA1n，其中Aij &#x3D; (-1)i+j Mij** a11、a12……a1n 很容易找出，所以重点就是找出 A11、A12……A1n ，而 i+j 也很容易表示，难点是 Mij 怎么表示，现在我们先把 DeterminantValue() 的主要步骤都写出来 123456789101112131415161718192021222324252627double DeterminantValue(double a[N][N],int n)&#123; int i = 0, j = 0; double result, temp; double sub[N][N]; if (n == 1) &#123; result = a[0][0]; //if the matrix size == 1,result == the elements in matrix &#125; else &#123; result = 0.0; //make result back to zero for (j = 0; j &lt; n; j++) &#123; SubMatrix(); //reduce the size of matrix,namely,find the submatrix cout &lt;&lt; &quot;SubMatrix:\\n&quot;; PrintMatrix(sub, n - 1); //print the submatrix temp = DeterminantValue(sub, n - 1); //find the value of submatrix result += a[0][j] * pow(-1, i + j) * temp; //use submatrix and the corresponding elements in the first line in original matrix to find each value of items cout &lt;&lt; &quot;DValue of the Submatrix is &quot; &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; temp &lt;&lt; endl; &#125; &#125; return result;&#125; 首先不要忘了我们要解的是什么，是 Mij，也就是子矩阵。子矩阵用来干什么？拿来和 aij 还有 (-1)i+j 相乘，然后再把他们加起来就是答案。所以重点是求 Mij ，不要忘了 那么一开始先判断阶数，如果是 1 阶的那么这个矩阵行列式的值就是里面那个元素的值，如果不是，那我们把它降阶再求，如果降了阶还不是 1 阶的，那就继续降，直到阶数等于 1 那么重点就变成了我们该如何降阶，也就是函数 SubMatrix() 2.4.1 SubMatrix()首先，虽然说是一直降阶，听起来是个很简单的步骤，但是在计算机上想用代码实现并没有想象中的那么简单。我们再来回顾一次，怎么降阶：**’A’ &#x3D; a11A11 + a12A12 + …… + a1nA1n**，所以这其实是个套娃的过程，而套娃已经在 DeterminantValue 中实现了，aij 也表示出来了，那在 SubMatrix 中要求的也就只有 Mij 了，那么子矩阵 Mij 怎么求？看下图找规律（以三阶为例） ![](&#x2F;images&#x2F;利用二维数组计算矩阵行列式的值 —— 按行展开计算法&#x2F;image-71.png) 按照定义，是去掉与 aij 同行同列的其他元素，余下的就是子矩阵；但是在程序里怎么表示呢？&gt; 法一：首先，我们要取的 aij 都是第一行的，所以要的子矩阵的元素都不在第一行，也就是上图中黄色框框内的，我们可以用下面的代码把它们找出来 1234567for(int i = 1; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; a[i][j]; &#125;&#125; 找出来后就是排除掉我们不要的，也就是和 aij 同列的 1234567891011121314151617//a[i][j] int ii = 0, jj = 0;double submatrix[N][N];for(int p = 1; p &lt; n; p++) // p start at 1&#123; jj = 0; for(int q = 0; q &lt; n; q++) &#123; if(q != j) &#123; submatrix[ii][jj] = a[p][q]; jj++; &#125; &#125; ii++;&#125; 这样就得到子矩阵了 法二：或者，我们直接用整个原矩阵，这样需要多排除 (n-1) 个元素，不过道理类似 1234567891011121314151617181920//a[i][j] int ii = 0, jj = 0;double submatrix[N][N];for(int p = 0; p &lt; n; p++) // p start at 0&#123; jj = 0; for(int q = 0; q &lt; n; q++) &#123; if(p != i &amp;&amp; q != j) &#123; sub[ii][jj] = a[p][q]; &#125; &#125; if(p != i &amp;&amp; q != j) &#123; ii++; &#125;&#125; 这样也可以 3. 总体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;math.h&gt;#define N 20using namespace std;void InputMatrix(double a[N][N], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; a[i][j]; //input the elements of the matrix &#125; &#125;&#125;void PrintMatrix(double a[N][N], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; a[i][j] &lt;&lt; &quot;\\t&quot;; //print the elements of the matrix &#125; cout &lt;&lt; endl; &#125;&#125;void SubMatrix(double a[N][N], double submatrix[N][N], int n, int row, int col)&#123; int ii = 0, jj = 0; for (int p = 1; p &lt; n; p++) // p start at 1 &#123; jj = 0; for (int q = 0; q &lt; n; q++) &#123; if (q != col) &#123; submatrix[ii][jj] = a[p][q]; jj++; &#125; &#125; ii++; &#125;&#125;double DeterminantValue(double a[N][N],int n)&#123; int i = 0, j = 0; double result, temp; double sub[N][N]; if (n == 1) &#123; result = a[0][0]; //if the matrix size == 1,result == the elements in matrix &#125; else if (n == 2) &#123; result = a[0][0] * a[1][1] - a[0][1] * a[1][0]; &#125; else &#123; result = 0.0; //make result back to zero for (j = 0; j &lt; n; j++) &#123; SubMatrix(a, sub, n, i, j); //reduce the size of matrix,namely,find the submatrix cout &lt;&lt; &quot;SubMatrix:\\n&quot;; PrintMatrix(sub, n - 1); //print the submatrix temp = DeterminantValue(sub, n - 1); //find the value of submatrix result += a[0][j] * pow(-1, i + j) * temp; //use submatrix and the corresponding elements in the first line in original matrix to find each value of items cout &lt;&lt; &quot;DValue of the Submatrix is &quot; &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; temp &lt;&lt; endl; &#125; &#125; return result;&#125;int main()&#123; int n; //matrix size double a[N][N]; //matrix double result; cout &lt;&lt; &quot;Please enter matrix size n(1&lt;=n&lt;20)\\n&quot;; cin &gt;&gt; n; //input the matrix size n cout &lt;&lt; &quot;Please input matrix line by line:\\n&quot;; InputMatrix(a, n); //input the matrix PrintMatrix(a, n); //print the matrix result = DeterminantValue(a, n); ; //get the result of the matrix cout &lt;&lt; endl &lt;&lt; &quot;result is &quot; &lt;&lt; result; //print the result&#125;","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/%E5%85%B6%E5%AE%83/"}],"tags":[]},{"title":"初步了解栈","slug":"初步了解栈","date":"2023-10-31T10:00:18.000Z","updated":"2023-11-15T03:19:02.434Z","comments":true,"path":"2023/10/31/初步了解栈/","link":"","permalink":"http://example.com/2023/10/31/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E6%A0%88/","excerpt":"","text":"初步了解栈栈,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。 栈是限制插入和删除只能在一个位置上进行的线性表。 至于什么是线性表，可以看另一篇文章：线性结构和非线性结构 这里的**”只能在一个位置上进行插入和删除”指的是栈顶，栈顶是会随着栈里面的数据元素的多少变化的，是动态变化的，一直指向栈的最上面一个数据元素。而既然有栈顶，那么就会有栈底，栈底的元素是不允许直接插入和删除的。** 看下图： &nbsp;左边的框框我们可以看成一个栈，右边是我们要存储的数据。然后我们往里面存储我们要存储的数据： 当我们把数据存放到栈里面时，叫进栈(也叫压栈) ,此时栈顶指向我们上面的”5”这个数据元素。 如果我们把栈顶的数据取出来，像下图这样，就是退栈（也叫出栈，弹栈） 如果再来一次弹栈，就是这样： 我们可以发现，我们每次弹栈都是最靠近栈顶（包括栈顶）的那个数据，而无法直接把下面的数据直接取出来。其实，这就是栈的一个特点：&nbsp;“先进后出，后进先出” 如果栈中没有数据，那么称之为空栈，空栈的时候不能向外取出数据，也就是不能退栈 如果栈中数据已满，则不能向内存入数据，也就是不能进栈 以上两种操作都会造成一定程度的问题，比如满栈的时候再次进栈，或者存入写入超过其本身长度的数据,以致于栈无法容纳，就会造成栈以外的存储单元被改写,称之为栈溢出。","categories":[{"name":"栈相关","slug":"栈相关","permalink":"http://example.com/categories/%E6%A0%88%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"汇编学习-2.3 几条汇编代码","slug":"汇编学习-2.3 几条汇编代码","date":"2023-10-31T09:58:27.000Z","updated":"2023-11-15T04:05:57.533Z","comments":true,"path":"2023/10/31/汇编学习-2.3 几条汇编代码/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.3%20%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/","excerpt":"","text":"2.3 几条汇编代码我们可以通过汇编指令来控制 CPU 进行工作，常用的指令如下表所示： **汇编指令****控制 CPU 完成的操作****用高级语言的语法描述**mov ax,18将 18 送入寄存器 axax=18mov ah,78将 78 送入寄存器 ahah=78add ax,8将寄存器 ax 中的数值加上 8ax+=8mov ax,bx将寄存器 bx 中的数据送入寄存器 axax=bxadd ax,bx将 ax 和 bx 中的数值相加，结果存在 ax 中ax+=bx注意：在写一条汇编指令或一个寄存器的名称的时候，不区分大小写 我们来看看实例 **程序段中的指令****指令执行后 ax 中的数据****指令执行后 bx 中的数据**mov ax,4E20h4E20h0000hadd ax,1406h6226h0000hmov bx,2000h6226h2000hadd ax,bx8226h2000hmov bx,ax8226h8226hadd ax,bx044Ch8226h注意：①原 ax，bx 中的值都为 0000h 我们都可以看到，最后得到的 ax 中的值是 044Ch（表格中涂上蓝色的），但是 ax + bx 的值不应该是 1044Ch 吗？为什么是 044Ch 呢？ 这是因为 ax 是一个 16 位寄存器，只能存放 4 个十六进制的数据，所以最高位的 1 不能在 ax 中保存，这样 ax 中的数据就是 044Ch 了。如果这是一个 32 位寄存器，那么就可以把 1044Ch 都保存进去 我们再来看一个实例： 程序段中的指令指令执行后 ax 中的数据指令执行后 bx 中的数据mov ax,001Ah001Ah0000hmov bx,0026h001Ah0026hadd al,bl0040h0026hadd ah,bl2640h0026hadd bh,al2640h4026hmov ah,00040h4026hadd al,85h00C5h4026hadd al,93h0058h4026h 我们可以看到，最后 ax 中的数据是 0058h，而不是 0158h，道理和上一个实例一样：al 是 ax 的低八位，也就是说它是一个 8 位寄存器，只能保存 2 个十六进制的数据，自然的那个 1 就不会被保存，最后的 ax 就是 0058h 需要注意的是：此时 al 是作为一个独立的 8 位寄存器来使用的，和 ah 没有关系，CPU 在执行这条指令时认为 ah 和 al 是两个不相关的寄存器。不要错误地认为，诸如 add al,93h的指令产生的进位会存储在 ah 中，add al,93h进行的是 8 位运算 还需要注意的是，在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的，比如说： ![](&#x2F;images&#x2F;汇编学习-2.3 几条汇编代码&#x2F;2image-8.png) 而下面的都是错误的 ![](&#x2F;images&#x2F;汇编学习-2.3 几条汇编代码&#x2F;image-9.png)","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"汇编学习-2.2 字在寄存器中的存储","slug":"汇编学习-2.2 字在寄存器中的存储","date":"2023-10-31T09:55:27.000Z","updated":"2023-10-31T10:18:24.784Z","comments":true,"path":"2023/10/31/汇编学习-2.2 字在寄存器中的存储/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.2%20%E5%AD%97%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/","excerpt":"","text":"2.2 字在寄存器中的存储出于对兼容性的考虑，8086CPU 可以一次性处理两种尺寸的数据： 字节：记为 byte，一个字节由 8 个比特（即二进制位）组成，可以存在 8 位寄存器中 字：记为 word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节 ![一个字由两个字节组成](&#x2F;images&#x2F;汇编学习-2.2 字在寄存器中的存储&#x2F;2image-7.png) 一个字可以存在一个 16 位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高 8 位寄存器和低 8 位寄存器中 我们知道，十六位进制数的一位相当于二进制的四位，比如说 0100111000100000 可表示为：4(0010)、E(1110)、2(0010)、0(0000) 四位十六进制数 由于一个内存单元可存放 8 位数据，CPU 中的寄存器又可存放 n 个 8 位的数据。也就是说，计算机中的数据大多是由 1 ~ N 个 8 位数据构成的。很多时候，需要直观地看出组成数据的各个字节数据的值，用十六进制来表示数据可以直观地看出这个数据是由哪些8位数据构成的。比如 20000 写成 4E20 就可以直观地看出，这个数据是由 4E 和 20 两个 8 位数据构成的，如果 AX 中存放 4E20，那么 AH 里就是4E，AL 里就是20 而为了区分不同的进制，我们一般在十六进制表示的数据后面加 H，在二进制表示的数据后面加 B，十进制数后面什么都不加","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"汇编学习-2.1 通用寄存器","slug":"汇编学习-2.1 通用寄存器","date":"2023-10-31T09:54:27.000Z","updated":"2023-10-31T10:18:12.264Z","comments":true,"path":"2023/10/31/汇编学习-2.1 通用寄存器/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.1%20%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"","text":"2.1 通用寄存器8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX 四个寄存器通常用来存放一般性的数据，被称为通用寄存器 以 AX 为例： ![16 位寄存器的逻辑结构](&#x2F;images&#x2F;汇编学习-2.1 通用寄存器&#x2F;2image-2.png) 一个 16 位的寄存器可以存储一个 16 位的数据，数据在这类寄存器中的存放情况如下图 ![16 位数据在寄存器中的存储情况](&#x2F;images&#x2F;汇编学习-2.1 通用寄存器&#x2F;2image-4.png) 而一个 16 位寄存器可以被氛围两个 8 位寄存器，以 AX 为例就是 AH 和 AL： ![16 位寄存器分为两个 8 位寄存器](&#x2F;images&#x2F;汇编学习-2.1 通用寄存器&#x2F;image-5-1024x288.png) 可以看到，AX 的低 8 位，也就是 0 ~ 7 位构成了 AL 寄存器；AX 的高 8 位，也就是 8 ~ 15 位构成了 AH 寄存器。需要知道的是，AH 和 AL 寄存器是可以独立使用的 8 位寄存器 ![16 位寄存器及所分成的两个 8 位寄存器的数据存储情况](&#x2F;images&#x2F;汇编学习-2.1 通用寄存器&#x2F;2image-6.png) 接下来有两个问题： 问题一：一个16位寄存器所能存储的数据的最大值为多少? 答：216 &#x3D; 65536，则 16 位寄存器能存储的数据的最大值为 216 - 1 &#x3D; 65535 问题二：一个8位寄存器所能存储的数据的最大值为多少? 答：28 &#x3D; 256，则 8 位寄存器能存储的数据的最大值为 216 - 1 &#x3D; 255","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"汇编学习-2.0 寄存器（CPU 工作原理）","slug":"汇编学习-2.0 寄存器（CPU 工作原理）","date":"2023-10-31T09:52:27.000Z","updated":"2023-10-31T10:17:58.423Z","comments":true,"path":"2023/10/31/汇编学习-2.0 寄存器（CPU 工作原理）/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-2.0%20%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/","excerpt":"","text":"2.0 寄存器（CPU 工作原理）一个典型的 CPU （此处，我们讨论的不是某一具体的 CPU）由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前面所说的总线，相对于 CPU 内部来说是外部总线。内部总线实现 CPU 内部各个器件之间的联系，外部总线实现 CPU 和主板上其他器件的联系。简单地说，在 CPU 中，运算器进行信息处理；寄存器进行信息存储；控制器控制各种器件进行工作；内部总线连接各种器件，在它们之间进行数据的传送。 对汇编学习来说，CPU 中最主要的部件就是寄存器。寄存器是 CPU 中程序员可以用指令读写的部件。程序员可以通过改变各种寄存器中的内容来实现对 CPU 的控制 不同的 CPU，寄存器的个数、结构是不相同的。8086CPU 有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX, BX, CX, DX, SI, DI, SP, BP, IP, CS, SS, DS, ES, PSW","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"}],"tags":[]},{"title":"汇编学习-1.9 内存地址空间","slug":"汇编学习-1.9 内存地址空间","date":"2023-10-31T09:50:27.000Z","updated":"2023-10-31T10:17:53.399Z","comments":true,"path":"2023/10/31/汇编学习-1.9 内存地址空间/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.9%20%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/","excerpt":"","text":"1.9 内存地址空间什么是内存地址空间呢？ 我们来简单了解一下内存地址空间。举例来讲，一个 CPU 的地址线宽度为 10，那么可以寻址 1024 个内存单元，这 1024 个可寻的内存单元就构成了这个 CPU 的内存地址空间（210 &#x3D; 1024） 先前说到的那些存储器，它们再物理上是独立的器件，但是它们在以下两点上的相同： 都和 CPU 总线相连 CPU 对它们的读与写的时候都通过控制线发出内存读写命令 这也就是说，CPU 在操纵和控制它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间 ![](&#x2F;images&#x2F;汇编学习-1.9 内存地址空间&#x2F;2image.png)CPU 将系统中各类存储器看作一个逻辑存储器 在上图中，所有的物理存储器都被看作一个由若干个存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读取数据 我们来看一个例子： ![](&#x2F;images&#x2F;汇编学习-1.9 内存地址空间&#x2F;image-1024x402.png) 内存地址空间的大小受 CPU 地址总线宽度的限制。8086CPU 的地址总线宽度为 20，可以传送 220 个不同的地址信息（大小从 0 至 220-1）。即可以定位 220 个内存单元，则 8086CPU 的内存地址空间大小为 1 MB（216 &#x3D; 64 * 1024B &#x3D; 64KB，220 &#x3D; 1024KB &#x3D; 1 MB）。同理，80386CPU 的地址总线宽度为 32，则内存地址空间最大为 4GB。 我们在基于一个计算机硬件系统编程的时候，必须得知道这个系统中的内存地址空间分配情况。因为当读者想在某类存储器中读写数据的时候，读者必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。比如，读者希望向显示器输出一段信息，那么读者必须将这段信息写到显存中，显卡才能将它输出到显示器上。要向显存中写入数据，读者必须知道显存在内存地址空间中的地址。而不同的计算机系统的内存地址空间的分配情况是不同的。","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.8 各类存储器芯片","slug":"汇编学习-1.8 各类存储器芯片","date":"2023-10-31T09:49:27.000Z","updated":"2023-10-31T10:17:48.121Z","comments":true,"path":"2023/10/31/汇编学习-1.8 各类存储器芯片/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.8%20%E5%90%84%E7%B1%BB%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87/","excerpt":"","text":"1.8 各类存储器芯片一台 PC 机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。 不过从读写属性上看的话，就只分为 2 种：随机存储器（RAM）和 只读存储器（ROM）。随机存储器可读可写，但必须带电存储，关机后存储的内容会丢失；只读存储器顾名思义，只能读、不能写，不过与随机存储器不同的是，关机后其中的内容是不会丢失的。 如果是从功能与连接上分类的话，就分为 3 类： 随机存储器 用于存放供 CPU 使用的绝大部分程序和数据，主随机存储器一般由两个位置上的 RAM 组成，装在主板上的 RAM 与 插在扩展插槽上的 RAM（注意这不是接口卡上的，是扩展插槽上的） BIOS，即 Basic Input&#x2F;Output System，基本输入&#x2F;输出系统。BIOS 是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应 BIOS 的 RAM。比如说，主板上的 ROM 存储着主板的 BIOS（通常称为系统 BIOS）；显卡上的 ROM 存储着显卡的 BIOS；如果网卡上装有 ROM，那其中就可以存储网卡的 BIOS接口卡上的 RAM 某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。最典型的就是显示卡上的 RAM，我们一般把它称为 显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.7 主板与接口卡","slug":"汇编学习-1.7 主板与接口卡","date":"2023-10-31T09:48:27.000Z","updated":"2023-10-31T10:17:44.006Z","comments":true,"path":"2023/10/31/汇编学习-1.7 主板与接口卡/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.7%20%E4%B8%BB%E6%9D%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%8D%A1/","excerpt":"","text":"1.7 主板与接口卡1.7.1 主板在每一台 PC 机中，都有一块主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连，而这些器件就有：CPU，存储器，外围芯片组，扩展插槽（扩展插槽上一般插有 RAM 内存条和各类接口卡）等。 1.7.2 接口卡计算机系统中，所有可用程序控制其工作的设备，都必须收到 CPU 的控制，但是外部设备是不能由 CPU 直接控制的，比如说音响、显示器、打印机、话筒等。那么是什么直接控制这些外部设备的呢？ 没错，就是接口卡，不过准确的说是 插在扩展插槽上的接口卡。而扩展插槽与 CPU 通过总线相连，所以接口卡也通过总线与 CPU 相连。CPU 可以通过总线直接控制接口卡，从而实现 CPU 对这些外部设备的间接控制。","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.6 总线","slug":"汇编学习-1.6 总线","date":"2023-10-31T09:47:27.000Z","updated":"2023-10-31T10:17:40.560Z","comments":true,"path":"2023/10/31/汇编学习-1.6 总线/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.6%20%E6%80%BB%E7%BA%BF/","excerpt":"","text":"1.6 总线1.6.1 地址总线CPU 是通过地址总线来指定存储器单元的，地址总线上能够传送多少个不同的信息，CPU 就能对多少个存储单元进行寻址 在电子计算机中，一根导线可以传送的稳定状态只有两种，高电平和低电平；用二进制来表示的话，就是我们熟悉的 1 和 0，所以如果有 10 根导线的话，就可以传送 10 位二进制数据，而 10 位二进制数据可以表示 210 种数据，最小可以表示 0，最大可以表示 1023 所以，我们就有了宽度的概念：一个 CPU 有 N 跟地址总线，那么这个 CPU 的地址总线的宽度就是 N，这样的 CPU 最多可以寻找 2N 个内存单元 1.6.2 数据总线CPU 与内存或其他器件之间的数据传送是通过数据总线来进行的，数据总线的宽度决定了 CPU 和外界的数据传送速度。8 根数据总线能够一次性传送 8 位二进制数据（也就是一个字节），16 根数据总线一次可以传送 2 个字节 如果一个占 2 个字节的数据要写入内存的话，宽度为 8 和宽度为 16 的会有什么区别呢？ 8086 有 16 根数据线，可以一次传送 16 位数据，所以可以一次性传送数据 89D8H；而 8088 只有 8 根数据线，一次只能传 8 位数据，所以向内存写入 89D8H 的时候需要传送两次 1.6.3 控制总线CPU 对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味这 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。 前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根控制线，叫作 读信号输出控制线，负责由 CPU 向外传送读信号，如果 CPU 向该控制线上输出低电平，就表示将要读取数据；有一根控制线，叫作 写信号输出控制线，是负责传送写信号的","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.5 CPU 对存储器的读写","slug":"汇编学习-1.5 CPU 对存储器的读写","date":"2023-10-31T09:45:27.000Z","updated":"2023-10-31T10:17:36.772Z","comments":true,"path":"2023/10/31/汇编学习-1.5 CPU 对存储器的读写/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.5%20CPU%20%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99/","excerpt":"","text":"1.5 CPU 对存储器的读写之前讲到过，存储器被划分为多个存储单元，存储单元从零开始顺序编号。这些编号呢，我们可以把它看作是存储单元在存储器中的地址。就像是一条街，每门每户都有属于它们自己的门牌号。 CPU 要从内存中读数据，首先要指定存储单元的地址。也就是说它要先确定读取哪一个存储单元中的数据，就像是你要找一个人，先要确定那个人是哪户的。 另外，在一台微机中，不只有存储器这一种器件。CPU 在读写数据的时候还要指明，它要对哪种器件进行操作，还有要进行什么操作，是从中读取数据，还是要写入数据进去。 所以说我们可以看到，CPU 想要进行数据的读写，必须和外部器件（标准的说法就是芯片）进行 3 类信息的交互： 存储单元的地址 （地址信息） 器件的选择，读或写的命令 （控制信息） 读或写的数据 （数据信息） 那么 CPU 是通过什么将地址、数据和控制信息传到存储器芯片中的呢？首先，我们要知道的是，电子计算机能处理、传输的信息都是电信号；然后，电信号当然要用导线传送，在计算机中专门有连接 CPU 和其他芯片的导线，通常称之为总线。也就是一根根导线的集合。我们上面说到了 3 类信息的交互，所以总线也会被分为三类，也就是 地址总线、控制总线和数据总线 我们来看看《汇编语言》- 王爽 中 “CPU 从内存中读取和写入数据的过程” 的例子 ![](&#x2F;images&#x2F;汇编学习-1.5 CPU 对存储器的读写&#x2F;image-1024x849.png) 这样我们就对 CPU 从内存中读取和写入数据的过程了解清楚了，接下来就要来了解，我们要怎么命令计算机进行数据的读写 要让一个计算机或微处理器工作，应向它输入能够驱动它工作的电平信号，也就是我们说的机器码 之后会详细说明机器码","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.4存储器与存储单元","slug":"汇编学习-1.4 存储器与存储单元","date":"2023-10-31T09:43:27.000Z","updated":"2023-10-31T10:17:31.259Z","comments":true,"path":"2023/10/31/汇编学习-1.4 存储器与存储单元/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.4%20%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/","excerpt":"","text":"1.4 存储器与存储单元CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是平时所说的内存。在一台PC机中内存的作用仅次于CPU。离开了内存，性能再好的CPU也无法工作。这就像再聪明的大脑，没有了记忆也无法进行思考。磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用。要灵活地利用汇编语言编程，首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。 ![](&#x2F;images&#x2F;汇编学习-1.4 存储器与存储单元&#x2F;image-3.png) 存储器被划分成若干个存储单元，每个存储单元从 0 开始顺序编号，例如一个存储器有 128 个存储单元，编号从 0~127 &#x3D;一个存储单元能存储多少信息呢？电子计算机的最小信息单位是 bit (音译为比特)，也就是一个二进制位。8 个 bit 组成一个 Byte，也就是一个字节。微型机存储器的存储单元可以存储一个字节,即 8 个二进制位。一个存储器有 128 个存储单元，它可以存储 128 个字节 微机存储器的容量是以字节为最小单位来计算的。对于拥有 128 个存储单元的存储器，我们可以说，它的容量是 128 字节 对于大容量的的存储器一般还用以下单位来计算容量（其中 B 用来代表 Byte 也就是一字节）： 1 KB &#x3D; 1024 B 1 MB &#x3D; 1024 KB 1 GB &#x3D; 1024 MB 1 TB &#x3D; 1024 GB 磁盘的容量单位和内存是一样的，实际上以上单位是微机中的常用的计量单位","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.3汇编语言的组成以及指令和数据","slug":"汇编学习-1.3 汇编语言的组成以及指令和数据","date":"2023-10-31T09:41:27.000Z","updated":"2023-10-31T10:17:27.176Z","comments":true,"path":"2023/10/31/汇编学习-1.3 汇编语言的组成以及指令和数据/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.3%20%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90%E4%BB%A5%E5%8F%8A%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE/","excerpt":"","text":"1.3 汇编语言的组成以及指令和数据1.3.1 汇编语言的组成汇编语言由以下三类指令组成： 汇编指令：机器码的助记符，由对应的机器码 伪指令： 没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 + 、- 、* 、&#x2F; 等，由编译器识别，没有对应的机器码 汇编语言的核心是汇编指令，它决定了汇编语言的特性。 1.3.2 指令和数据指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。 《汇编语言》- 王爽 中有个有趣的例子： 内存中的二进制信息 1000100111011000 计算机可以把它看作大小为 89D8H 的数据来处理，也可以看作指令 mov ax,bx 来执行1000100111011000 → 89D8H （数据）1000100111011000 → mov ax,bx （程序）","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.2汇编语言的诞生","slug":"汇编学习-1.2 汇编语言的诞生","date":"2023-10-31T09:40:27.000Z","updated":"2023-10-31T10:17:17.791Z","comments":true,"path":"2023/10/31/汇编学习-1.2 汇编语言的诞生/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.2%20%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%9E%E7%94%9F/","excerpt":"","text":"1.2 汇编语言的诞生上一节我们知道了机器语言带来的麻烦，于是汇编语言诞生了 汇编指令和机器指令的差别在于指令的表达方式上，汇编指令是机器指令便于记忆读写的书写格式，例如：机器指令 1000100111011000 表示把寄存器 bx 的内容送到 ax 中，汇编指令写成 mov ax,bx 可以看到，这样的写法与人类语言更加接近，便于阅读和记忆 关于寄存器： 简单的讲就是 CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器，ax 是其中一个寄存器的代号，bx 是另一个寄存器的代号。详细的后面会讲到 所以，程序员们就开始用汇编指令编写源程序。可是，计算机能读懂的只有机器指令，那么如何让计算机执行程序员用汇编指令编写的程序呢？这时，就需要一个能够将汇编指令转换成机器指令的翻译程序，这样的程序被称为编译器。程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器码，有计算机最终执行。 ![用汇编语言编写程序的工作过程](&#x2F;images&#x2F;汇编学习-1.2 汇编语言的诞生&#x2F;image-2-1024x218.png)","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"汇编学习-1.1机器语言","slug":"汇编学习-1.1 机器语言","date":"2023-10-31T09:38:27.000Z","updated":"2023-10-31T10:17:21.973Z","comments":true,"path":"2023/10/31/汇编学习-1.1 机器语言/","link":"","permalink":"http://example.com/2023/10/31/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-1.1%20%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80/","excerpt":"","text":"1.1 机器语言在学习汇编语言之前，我们要先了解一下机器语言。机器语言是机器指令的集合，机器指令就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字，计算机将其转变为一列高低电平，使计算机的电子器件收到驱动，进行运算、运行。 刚刚说到的计算机，其实指的是可以执行机器指令、进行运算的机器。之前是这么称呼计算机的，现在，在常用的 PC 计算机里，有一个芯片就可以完成上面所说的计算机的功能，这个芯片就是我们常说的 CPU （中央处理单元），CPU 是一种微处理单元。 而每一种微处理单元，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使其可以工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。 我们知道，在很早之前，没有什么高级编程语言，比如说 C 语言，Python 语言，早期的程序设计均使用机器语言，程序员们用 0 、1 数字编成的程序代码打在纸带或卡片上，1 代表的是打孔，0 代表不打孔，再将程序通过纸带机或者卡片机输入计算机，就可以进行运算。 但是，机器码并非想象中的那么简单易懂，我们来看一下《汇编语言》- 王爽 里的一个例子： 应用 8086CPU 完成运算 s=768+12288-1280，机器码如下：101100000000000000000011000001010000000000110000001011010000000000000101假如将程序错写成一下这样，请读者找出错误101100000000000000000011000001010000000000110000000101101000000000000101 这里我们就可以看出，机器码的晦涩难懂，而且不易查错。所以，要书写和阅读机器码程序不是一件简单的工作，要记住所有抽象的二进制码。上面只是一个非常简单的运算，如果要写一个更有用的程序，情况又会怎么样呢？可想而知，如果程序里有一个 “1” 被误写为 “0”，或者少写了一个 “1”，又如何去查找呢？ 《汇编语言》- 王爽 例子中的错误： 第三行第一个 1 前多了个 0，第四个 1 后少了个 0","categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-3.3位运算","slug":"C++反汇编与逆向分析技术揭秘-3.3 位运算","date":"2023-10-31T09:28:28.000Z","updated":"2023-10-31T09:56:11.049Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-3.3 位运算/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-3.3%20%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"3.3 位运算二进制数据的运算成为位运算，位运算操作有： “&lt;&lt;”：左移运算，最高位左移到 CF 中，最低位补零 “&gt;&gt;”：右移运算，最高位不变，最低位右移到 CF 中 “ ‘ “：位或运算，在两个数的相同位上，只要有一个 1，则结果为 1 “ &amp; “：位与运算，在两个数的相同位上，只有同时为 1 时，结果才为 1 “ ^ “：异或运算，在两个数的相同位上，两个值相同则为 0 ，不同则为 1 “ ~ “：取反运算，将操作数每一位上的 1 变为 0 ，0 变为 1 位运算在程序算法中被大量使用，如不可逆算法 md5，就是通过大量位运算来完成的。如何使一个数不可逆转呢？利用位运算就可以达到目的，比如说呢，x &amp; 0 &#x3D; 0 ,但是我们并不能通过结果来逆推 x 的值的。 由于大多数位运算会导致数据信息的丢失（其中 取反” ~ “ 和 异或” ^ “ 是可以逆推的），所以，在知道原算法的前提下，使用逆转算法是无法计算出原数据的。在算术运算中，编译器会将各种运算转换成位运算，因此掌握位运算对于学会算法识别是一件非常重要的事。 接下来我们来看看，位运算符号又是如何转换成汇编代码的呢 12345678910111213141516171819int main() //C++ 源码说明：位运算&#123; int argc = 1; argc = argc &lt;&lt; 3; //将变量 argc 左移 3 位 argc = argc &gt;&gt; 5; //将变量 argc 右移 5 位 argc = argc &#x27; 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做位或运算 argc = argc &amp; 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做位与运算 argc = argc ^ 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做异或运算 argc = ~argc; //将变量 argc 做按位取反运算&#125; 我们来看看汇编代码是什么 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.3 位运算&#x2F;1image.png) 上面展示了有符号数的位运算，对于无符号数而言，转换的位运算指令将会发生转变，我们也来看看 1234567891011int main() //无符号位运算&#123; unsigned int argc = 1; argc = argc &lt;&lt; 3; //将变量 argc 左移 3 位 argc = argc &gt;&gt; 5; //将变量 argc 右移 5 位&#125; ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.3 位运算&#x2F;1image-1.png) 可以看到，无符号数的左移运算和有符号数的是一样的，都不需要考虑到符号位。但右移运算则有变化，有符号数对应的指令为 sar ，可以保留符号位，而无符号数不需要符号位，所以直接使用 shr 将最高位补 0","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-3.2关系运算和逻辑运算","slug":"C++反汇编与逆向分析技术揭秘-3.2 关系运算和逻辑运算","date":"2023-10-31T09:28:04.000Z","updated":"2023-10-31T09:55:51.108Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-3.2 关系运算和逻辑运算/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-3.2%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/","excerpt":"","text":"3.2 关系运算和逻辑运算关系运算用于判断两者之间的关系，如等于、不等于、大于等于、小于等于、大于和小于，对应的符号分别为”&#x3D;&#x3D;”、”!&#x3D;”、 “&gt;&#x3D;”、”&lt;&#x3D;”、”&gt;”、”&lt;”，关系运算的作用是比较关系运算符左右两边的操作数的值，得出一个判断结果:真或假。逻辑运算用于判定两个逻辑值之间的依赖关系，如或、与、非，对应的符号有”‘’”、”&amp;&amp;”、”!” ， 逻辑运算也是可以组合的，执行顺序和关系运算相同。 或 运算：比较运算符”‘’”左右的语句的结果，如果有一个值为真，则返回真值；如果都为假，则返回假值 与 运算：比较运算符”&amp;&amp;”左右的语句的结果，如果有一个值为假，则返回假值；如果都为真值，则返回真值 非 运算：改变运算符 “!” 后面的语句的真假结果，如果该语句的结果为真值，则返回假值；如果为假值，则返回真值 3.2.1 关系运算和条件跳转的对应如何选择条件跳转指令，需要根据所使用到的关系运算，不同的关系运算对应的条件跳转指令也不同 下面我们来看看各种关系对应的条件跳转指令 指令助记符检查标记位说明JZZF==1等于 0 则跳转JEZF==1相等则跳转JNZZF==0不等于 0 则跳转JNEZF==0不相等则跳转JSSF==1符号为 负 则跳转JNSSF==0符号为 正 则跳转JP/JPEPF==1\"1\"的个数为偶数则跳转JPN/JPOPF==0\"1\"的个数为奇数则跳转JOOF==1溢出则跳转JNOOF==0无溢出则跳转JCCF==1进位则跳转JBCF==1小于则跳转（无符号比较）JNAECF==1不大于等于则跳转JNCCF==0无进位则跳转JNBCF==0不小于则跳转JAECF==0大于等于则跳转JBECF==1 或 ZF==1小于等于则跳转JNACF==1 或 ZF==1不大于则跳转JNBECF==0 或 ZF==0不小于等于则跳转JACF==0 或 ZF==0大于则跳转（无符号比较）JLSF != OF小于则跳转（有符号比较）JNGESF != OF不大于等于则跳转JNLSF == OF不小于则跳转JGESF == OF大于等于则跳转JLEZF != OF 或 ZF==1小于等于则跳转JNGZF != OF 或 ZF==1不大于则跳转JNLESF == OF 或 ZF==0不小于等于则跳转JGSF == OF 或 ZF==0大于则跳转（有符号比较） 其中，有一定的规律，比如 A 和 G 表示的是大于，比如说 JA 和 JG；B 和 L 表示的是小于，比如说 JB 和 JL；E 表示的是相等，比如说 JE 是相等则跳转，JGE/JAE 是大于等于则跳转，JLE/JBE 是小于等于则跳转；N 表示的是 不 ，比如说 JNE 是不相等，JNG/JNA 是不大于则跳转，JNGE/JNAE 是不大于等于则跳转...... 在通常情况下，这些条件跳转指令都与 CMP 和 TEST 匹配出现，但条件跳转指令检查的是标记位。因此，在有修改标记位的代码处，也可以根据需要使用条件跳转指令来修改程序流程 3.2.2 表达式短路表达式短路通过 “逻辑与” 运算 和 “逻辑或” 运算 使语句根据条件在执行时发生中断，从而不予执行后面的语句。如何利用表达式短路来实现语句中断呢？根据逻辑与和逻辑或运算的特性，如果是与运算，当运算符左边的语句块为假值时，则直接返回假值，不执行右边的语句；如果是或运算，当运算符左边的语句块为真值时，直接返回真值，不执行右边的语句块 我们将进一步学习和理解表达式短路的构成 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.2 关系运算和逻辑运算&#x2F;image-165.png) //当 num 等于 0 时，逻辑与 运算符左边的值为假，将不会执行右边语句 num && (num += Accumulation(num - 1)); 00007FF613B1177E cmp dword ptr [num],0 //这里为短路模式汇编代码，比较变量 num 是否等于 0 00007FF613B11785 je Accumulation+46h (07FF613B117A6h) //通过 je 跳转，检查 ZF 标记位等于 1 跳转 00007FF613B11787 mov eax,dword ptr [num] //跳转失败，进入递归调用 00007FF613B1178D dec eax 00007FF613B1178F mov ecx,eax //对变量减 1，并将结果转移 00007FF613B11791 call Accumulation (07FF613B111AEh) 00007FF613B11796 mov ecx,dword ptr [num] 00007FF613B1179C add ecx,eax 00007FF613B1179E mov eax,ecx 00007FF613B117A0 mov dword ptr [num],eax //继续调用自己，形成递归 return num; 00007FF613B117A6 mov eax,dword ptr [num] 在上面的实例中，通过递归函数 Accumulation 完成了整数累加和计算，在递归函数的构成中，必须要有一个出口，本实例选择了逻辑运算”&amp;&amp;”来制造递归函数的出口。通过使用 CMP 指令来检查运算符左边的语句是否为假值，根据跳转指令 JE 来决定是否跳过程序流程。当变量 num 为假时，JE 成功跳转，跳过递归函数调用，程序流程将会执行到出口 return 处 逻辑运算” ‘’ “虽然与逻辑运算”&amp;&amp;”有些不同，但它们的构成原理相同，只需稍作修改就可以解决这一类型的问题。将 逻辑与 运算修改为 逻辑或 运算来实现表达式短路 //当 num 等于 0 时，逻辑或 运算符左边的值为真，将不会执行右边语句 (num == 0) '' (num += Accumulation(num - 1)); //使用逻辑或 运算造成的表达式短路，生成的反汇编代码与使用逻辑与 时是样的 00007FF67B54177E cmp dword ptr [num],0 00007FF67B541785 je Accumulation+46h (07FF67B5417A6h) 00007FF67B541787 mov eax,dword ptr [num] 00007FF67B54178D dec eax 00007FF67B54178F mov ecx,eax 00007FF67B541791 call Accumulation (07FF67B5411AEh) 00007FF67B541796 mov ecx,dword ptr [num] 00007FF67B54179C add ecx,eax 00007FF67B54179E mov eax,ecx 00007FF67B5417A0 mov dword ptr [num],eax return num; 00007FF67B5417A6 mov eax,dword ptr [num] 我们对比一下可以发现，两种短路表达式编译为相同的汇编代码，虽然使用的逻辑运算符不同，但在这两种情况下，运算符的左边的语句块都是在与 0 值作比较，而且判定的结果都是等于 0 时不执行运算符右边的语句块，所以就变成了相同的汇编代码 转换成汇编代码后，通过比较后跳转来实现短路，这种结构实质上呢，就是分支结构，在反汇编代码中时没有表达式短路的（虽然这节标题叫作表达式短路），我们能够看到的都是分支结构，至于什么是分支结构我们之后会详细了解的 3.2.3 条件表达式条件表达式，也就是三目运算 表达式 1 ? 表达式 2 : 表达式 3 我们来复习一下：如果表达式 1 是真值，那么执行表达式 2；如果是假值，那么执行表达式 3 条件表达式也属于表达式的一种，所以表达式 1，表达式 2，表达式 3 都可以套用到条件表达式中，条件表达式被套用后，其执行顺序依然是由左向右，自内向外 条件表达式的构成应该是先判断再选择，但是，编译器并不一定会按照这种方式进行编译，当表达式 2 与表达式 3 都为常量时，条件表达式可以被优化；而当表达式 2 或表达式 3 中的一个为变量时，条件表达式不可以被优化，会转换成分支结构；当表达式 1 为一个常量值时，编译器会在编译过程得到答案，将不会有条件表达式存在 编译器有四种条件表达式的转换方案 表达式 1 为简单比较，而表达式 2 和表达式 3 两者的差值等于 1 表达式 1 为简单比较，而表达式 2 和表达式 3 两者的差值大于 1 表达式 1 为复杂比较，而表达式 2 和表达式 3 两者的差值大于 1 表达式 2 和表达式 3 有一个是变量，于是没有优化 我们可以自己通过反汇编形式对比这 4 种转换方案，找出它们的特征，分析它们之间的区别","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-3.1算术运算和赋值","slug":"C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值","date":"2023-10-31T09:27:44.000Z","updated":"2023-10-31T09:55:27.117Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-3.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C%E8%B5%8B%E5%80%BC/","excerpt":"","text":"3.1 算术运算和赋值 本节内容稍长，爱护眼睛，望周知 Table of Contents 3.1.1 各种算术运算的工作方式 3.1.1.1 加法 ODebug ORelease ▲常量扩散 ▲常量折叠 3.1.1.2 减法 3.1.1.3 乘法 3.1.1.4 除法 O除法计算约定 O对整数除法的优化 ▲除数为 2 的幂 ▲除数为非 2 的幂 ▲除数为负的 2 的幂 ▲除数为负的非 2 的幂 ▲除法优化的原则 3.1.2 算术结果溢出 3.1.3 自增与自减 算术运算是指加法、减法、乘法、除法这四种数学运算，也称为四则运算。我们知道，数学上也有四则运算，那计算机上的四则运算和数学上的有什么不同呢？ 首先，赋值运算类似于数学中的”等于”，是将一个内存单元中的数据传递到另一个内存空间中。由于内存没有处理器那样的控制能力，各个内存单元之间是无法直接传递数据的，所以必须通过处理器访问并中转，以实现两个内存单元间的数据传输。 1234567int main()&#123; int a = 10; //这里的等号&#x27;=&#x27;就是赋值运算，将10赋值给变量a int b; b = a; //这里将变量a 的值赋值给变量b ，而变量a 所在的内存单元中的数据是 10，所以传递到变量b 的内存单元后，变量b 表示的就是 10&#125; 在 C++ 中，算术运算于其他传递计算结果的代码组合后才能被视为一条有效的语句，也就是说算术运算单独存在是没有意义的，因为单独的算术运算虽然可以编译通过，但是不会生成代码，就像你有炊具但是没有食材，最后是做不出饭菜的。不过，因为只进行计算而没有 传递结果的运算会被编译器视为无效语句，与空语句等价，所以不会对程序结果有任何结果 3.1.1 各种算术运算的工作方式3.1.1.1 加法加法运算对应的汇编指令为 ADD，也就是英文中的 ‘add’ ，翻译过来就是添加。在执行加法运算的时候，针对不同的操作数，转换的指令也会不同，而编译器会根据优化方案选择最佳的匹配方案。一般 C++ 最常用的优化方案是下面这两种： 生成文件占用空间最小 执行效率最快 本节内容我们来对比和分析一下Debug编译选项组与Release编译选项组这两个选项对各种计算产生的目标代码方案。 Debug在使用Debug编译选项组的时候，C++产生的目标汇编代码会和源码一一对应： ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-20221104144856347.png) 现在我们来分析一下Debug编译选项组下编译的汇编代码： 首先我们先是定义了变量 number_one 和变量 number_two ，我们可以看到编译器是用 mov 将数 0 传入 number_one 所在的地址中，对于 number_two 也是同理 然后是变量 + 常量的运算，我们可以看到，编译器将放在 number_one 地址处的数据先是用 mov 放到了 eax 中，然后对 eax 执行加 1 运算（在汇编中，inc 的作用是将指定的操作数的内容加1，再将结果送回到该操作数），最后将结果放回变量 number_one 中，完成加法运算 接下来是变量 + 变量的运算，由上面的C++源码对比可以看出，编译器先使用 eax 存放变量 number_one，然后使用 ecx 存放变量 number_two，再将 eax 的数据加到 ecx 里，完成后将 ecx 的数据转移到 eax （eax 原本的数据将会被覆盖掉），最后再将 eax 的数据存入变量 number_two 的地址处。这样就完成了number_three &#x3D; number_one + number_two 的运算 其中 eax 、ecx 是寄存器 ReleaseC++ 中，很多编译器的Release 编译选项组的默认选项是第二种方案–执行效率优先 在这种方案下，编译出来的汇编代码将会有较大的变化。因为其遵循效率优先，所以编译器会将无用代码去除，并将可合并代码进行归并处理。比如连续两次给同一个变量赋值，它会将第一次赋值给省去，因为在其后又重新对其进行了赋值操作，而且在此之前没有对该变量的任何访问，所以编译器判定此句代码是被删除的。 首先，我们先了解两个关于优化的概念。在编译过程中，编译器常常会采用”常量传播”和”常量折叠”这样的方案对代码中的变量与常量进行优化 常量传播将编译期间可计算出结果的变量转化成变量，这样就减少了变量的使用，比如说： 12345void main()&#123; int nVar = 1; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 我们知道，上面的变量 nVar 是一个在编译期间可以计算出结果的变量。所以，在程序中所有引用到 nVar 的地方都可以直接用常量 1来代替，这样代码就可以变成下面这样： 1234void main()&#123; printf(&quot;nVarOne = %d \\r\\n&quot;,1);&#125; 常量折叠当计算公式中出现多个常量进行计算的时候，且编译器可以在编译期间计算出结果时，这样所有的常量计算都将被计算结果代替（个人觉得这个大多数时候是没什么用的，因为我们写代码的时候一般不会闲着没事把数拆开） 12345void main()&#123; int nVar = 1 + 5 - 3 * 6; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 这个时候就不会生成计算指令，因为”1 + 5 - 3 * 6 “的值是可以在编译过程中计算出来的，所以编译器会先计算出”1 + 5 - 3 * 6 “的结果，也就是 -12，然后将数值 -12 替换掉原表达式 12345void main()&#123; int nVar = -12; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 接下来我们可以再使用”常量传播” 1234void main()&#123; printf(&quot;nVarOne = %d \\r\\n&quot;,-12);&#125; 3.1.1.2 减法减法运算对应于汇编指令 sub，也就是英文中的”subtraction”的缩写。我们知道，计算机只会做加法，但是可以通过补码转换，将减法转变为加法的形式来完成运算 我们先来浅浅学习一下将减法转变为加法的过程： 设有二进制数 Y ,其反码记为 Y（ 反 ），假定其二进制长度为8位，有： Y + Y（ 反 ）&#x3D; 1111 1111B Y + Y（ 反 ）+ 1 &#x3D; 0 （ 进位丢失 ） 根据以上公式从，可得： Y（ 反 ） + 1 &#x3D; 0 - Y Y（ 反 ） + 1 &#x3D; - Y Y（ 补 ） &#x3D; - Y 这就是为什么负数的补码可以简化为取反加 1 的原因 比如，7 - 4 可以转换成： 7 +（ 0 - 4 ）~ 7 +（ 4（ 反 ）+ 1 ）~ 7 + 4（ 补 ） 有了这个特性，所有的减法运算就都可以转换成加法运算了 而减法运算的工作方式与加法运算的基本一致，就不赘述了 3.1.1.3 乘法乘法运算对应的汇编指令有两种： 有符号 imul 无符号 mul 由于乘法指令的执行周期较长，在编译过程中，编译器会先尝试将乘法转换为加法，或者使用移位等周期较短的指令，如果它们都不可以转换的时候，才会使用乘法指令。 我们可以继续用Debug编译选项组来对比C++源码和对应的汇编代码 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-1.png) 我们可以看到，有符号数乘以常量值，且这个常量非2的幂，会直接使用有符号乘法 imul 指令。而当常量值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令。当常值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令。 这是因为，任何十进制数都可以转换成二进制数来表示，在二进制数中乘以2就等同于所有位依次向左移动1 位。如十进制数3的二进制数为 0011，3乘以 2 后等于 6，6 转换成二进制数为 0110。 而当乘数和被乘数同时都是未知变量时，则无法套用优化方案。这时编译器不会优化处理，将直接使用乘法指令完成乘法计算。 我们发现，两常量相乘时，会先在编译期间计算出相乘的结果，再将表达式转换为常量值 在上例中，乘法运算与加法运算的结合运算，编译器采用 LEA 指令来处理。在代码中，lea 语句 的目的并不是取地址。如果这种组合运算中的乘数不等于 2、4、8 的时候，组合运算会有些许不同 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-4.png) 我们可以看到，编译器会直接先拆分，然后再进行运算 而两变量相乘的时候，会直接使用有符号乘法指令 再者，无符号数乘法的原理与之相同，我们可以自己思考一下 3.1.1.4 除法除法计算约定除法运算对应的汇编指令分有符号 idiv 和无符号 div 两种。除法指令的执行周期较长，效率也较低，所以编译器想尽办法用其他运算指令代替除法指令。C++ 中的除法和数学中的除法不同。在 C++ 中，除法运算不保留余数，有专门求取余数的运算 ( 运算符为 % )，也称之为取模运算。对于整数除法，C++ 的规则是仅仅保留整数部分，小数部分完全舍弃。 我们先讨论一下除法计算的相关约定。以下讨论的除法是”计算机整数除法”，我们使用 C 语言中的 a&#x2F;b 表示除法关系。在 C 语言中，两个无符号整数相除，结果依然是无符号的;两个有符号整数相除，结果则是有符号的;如果有符号数和无符号数混除，其结果则是无符号的，有符号数的最高位 ( 符号位 ) 被作为数据位对待,然后作为无符号数参与计算。 对于除法而言，计算机面临着如何处理小数部分的问题。在数学意义上，7&#x2F;2&#x3D; 3.5，而对于计算机而言，整数除法的结果必须为整数。对于3.5这样的数值，计算机取整数部分的方式不止一种，下面来介绍三种取整方式： 向下取整： 所谓对 x 向下取整，就是往 -∞ 方向也就是往小的方向，取最接近 x 的整数值，换言之也就是取得不大于 x 的最大整数，例如，+3.5 向下取整得到3，-3.5向下取整得到-4。在数学描述中，⌊ x ⌋ 表示的就是对 x 向下取整。在标准 C 语言的 math.h 中，定义了 floor 函数，其作用就是向下取整，也有人称之为**”地板取整”**。向下取整的除法，当除数为 2 的幂时，可以直接用带符号右移指令( sar ) 来完成。但是，向下取整存在一个问题：那就是 ⌊ - a &#x2F; b ⌋ ≠ - ⌊ a &#x2F; b ⌋，比如说 ⌊ -1 &#x2F; 2 ⌋ 是 -1，而 -⌊ 1 &#x2F; 2 ⌋ 却是 0（假设 a &#x2F; b 不为整数） 向上取整 所谓对 x 向上取整，就是往 +∞ 方向也就是往大的方向，取最接近 x 的整数值，换言之也就是取得不小于 x 的最小整数。例如，+3.5 向上取整得到 4 ，-3.5 向上取整得到 -3。在数学描述中，⌈ x ⌉ 表示对x 向上取整。在标准 C 语言的 math.h 中有定义 ceil 函数，其作用就是向上取整，也有人称之为**”天花板取整”**。向上取整也存在一个问题：也是 ⌈ - a &#x2F; b ⌉ ≠ - ⌈ a &#x2F; b ⌉，比如 ⌈ -1 &#x2F; 2 ⌉ 是 0，而 -⌈ 1 &#x2F; 2 ⌉ 却是 -1（假设 a &#x2F; b 不为整数） 向 0 取整 所谓对 x 向零取整，就是往 0 方向，取最接近 x 的整数值，换而言之也就是放弃小数部分。举例说明，+3.5 向零取整得到 3，-3.5 向零取整得到 -3。在数学描述中，[ x ] 表示对 x向零取整。在C语言和其他多数高级语言中，对整数除法规定为向零取整。也有人称这种取整方法为**”截断除法”** 对整数除法的优化如果除数是变量，则只能使用除法指令（这和两变量相乘很相似）如果除数为常量，就有了优化的余地，根据除数值的相关特性，编译器有对应的处理方式 除数为 2 的幂我们知道，在乘法里，如果常值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令，那么在除法运算里也是类似的：在C语言中，有符号除法的除法规则是向 0 取整，对有符号数做右移运算，编译后使用的指令为 sar，相当于向下取整 比如说，4 &#x2F; 2 等价于 4 &gt;&gt; 1，结果就是 2（ ‘ &gt;&gt; ‘ 的意思是右移，比如说 4 的二进制码是 0100，右移就是 0010，也就是 2 了）如果是 5 &#x2F; 2 ，也就是 5 &gt;&gt; 1，结果还是 2（ 5 的二进制码是 0101，右移就是 0010，也就是 2 ）这也是我们在 C 语言中整型用除法时取整的原理 除数为非 2 的幂由于除法指令的周期比乘法指令周期长很多，因此编译器会用周期较短的乘法和其他指令代替除法。我们来看看数学证明 设 x 为被除数变量，o 为某一常量，则有: x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) 由于 o 为常量，且 2n 的取值由编译器选择，所以 ( 2n &#x2F; o ) 的值在编译期间可以计算出来，一般来说，n 的取值都大于等于32， 这样就可以直接调整使用乘法结果的高位，也就是说 ( 2n &#x2F; o ) 是一个编译期间先行计算的常量值，这个值通常被称为 Magic Number 我们用 M 代表 ( 2n &#x2F; o )，那么就有 x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; ( x * M ) * ( 1 &#x2F; 2n ) 我们再用 K 代表 ( x * M )，那么就有 K * ( 1 &#x2F; 2n ) &#x3D; K &#x2F; 2n 这样除数不就变成了 2 的幂了吗，就是 K &gt;&gt; n 然而除法运算还有更加深奥的方面没有研究，比如 ( 2n &#x2F; o ) 的 n 次方的大小问题，这里就先不深究了 除数为负的 2 的幂有了先前学习的基础，我们知道 sar 是右移指令，其实，除数为负的 2 的幂的除法和除数为 2 的幂的除法很相似，如果我们用 Release 编译选项组查看汇编代码，发现里面多了一个 neg 指令，其实这个 neg 指令相当于取负，其他的和除数为 2 的幂的除法基本一致 除数为负的非 2 的幂我们知道，在除数为非 2 的幂的除法中，x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; x * M * ( 1 &#x2F; 2n ) 那么在除数为负的非 2 的幂的除法中，就是 x &#x2F; ( -o ) &#x3D; x * ( -1 &#x2F; o ) &#x3D; x * ( -2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; x * ( -M ) * ( 1 &#x2F; 2n )，我们来研究一下这个 -M : -M &#x3D; - ( 2n &#x2F; o ) &#x3D; ( 2n &#x2F; o ) ( 求补 ) 而更深奥的方面我们在这就不研究了 除法优化的原则其实，我们通过还原所得的数都是近似值，这说明给出的公式不够严格，我们要在稍稍深度学习除法运算再来探索这方面的原理 我们可以先不管如何证明的，先看一下为什么还原的除数近似而不等的原因：我们的 Magic Number 是整数值，而 ( 2n &#x2F; o ) 是实数值，所以我们要找到 Magic Number 表达式中 2n 的值才行 3.1.2 算术结果溢出其实我们在之前已经接触过算术结果溢出的相关知识，比如 int 类型的数据如果经过计算后超出了 int 类型的存储范围，超出的部分也就是溢出数据，将无法被保存。又比如说一个负数，溢出后由于表示符号的最高位被进位了，原来符号位上的 1 变成了 0，这是负数也就变成了正数。 不过，我们需要知道，溢出的部分丢失后不是说它就是最大的数了，而是变成了一个很小的数，所以，有一些循环看似死循环，其实有可能并不是死循环，我们来看一下下面的例子： 1234for(int i = 1 ; i &gt; 0 ; i++)&#123; std::cout &lt;&lt; i;&#125; 上面的 for 循环看上去是一一个死循环，但由于 i 是一个有符号数，当 i 等于它允许取得的最大正数值0x7FFFFFF 时，再次加 1 后，数值会产生进位，将符号位 0 修改为 1，最终结果为 0x80000000，这时的最高位为 1,按照有符号数进行解释，这便是一个负数，对于 for 循环而言，当循环条件为假时，则会跳出循环体，结束循环。 溢出是由于数据进位后超出数据的保存范围导致的。溢出和进位都表示数据超出了存储范围，它们之间又有什么区别呢? 进位： 无符号数超出存储范围叫做进位。因为没有符号位，所以不会破坏数据，而多出的1位数据会被进位标志位 CF 保存，数据产生了进位，只是进位后的 1 位数据 1 不在自身的存储空间中，而在标志位 CF 中，可通过查看进位标志位 CF，检查数据是否进位。 溢出： 有符号数超出存储范围叫做溢出，由于数据进位，从而破坏了有符号数的最高位一符号位，因为只有有符号数才有符号位，所以溢出只针对有符号数。可查看溢出标志位 OF，检查数据是否溢出。OF 的判定规则很简单，如果参与加法计算的数值符号一致，而计算结果符号不同，则判定 OF 成立，其他都不成立。 3.1.3 自增与自减我们知道，C&#x2F;C++ 中分别用 ‘ ++ ‘，’ - - ‘ 来表示自增和自减。而自增和自减有两种： 先递增(减)：先执行自增(减)，然后再执行语句块 后递增(减)：先执行语句块，然后再执行自增(减) 下面我们要研究的是在汇编语言中自增和自减是怎么执行的 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-6.png) ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-3.1 算术运算和赋值&#x2F;image-5.png) 通过上面的汇编我们可以清晰的知道自增和自减是如何运作的： 先递增是将原语句块”number_two &#x3D; 5 + (++number_one);”分解为”number_one +&#x3D; 1 ;”和”number_two&#x3D; 5 +number_one;”，这样就实现了先自增 1，再参与语句块运算。同理，后递增的拆分过程只是执行顺序做了替换，先参与表达式运算，再将自身加 1。在识别过程中，后递增必然会保存计算前的变量值，在表达式计算完成后，才取出之前的值加 1，这是个显著特点。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-2.3main函数的识别","slug":"C++反汇编与逆向分析技术揭秘-2.3 main函数的识别","date":"2023-10-31T09:26:14.000Z","updated":"2023-10-31T09:54:39.761Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-2.3 main函数的识别/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-2.3%20main%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%86%E5%88%AB/","excerpt":"","text":"2.3 main函数的识别通过上节的学习，我们知道了调用main函数之前，必须先要得到三个必要的参数，而这三个参数的获取我们应该已经了解了，那么我们来看看怎么识别main函数： 首先，main函数被调用前要先调用下面的函数： GetVersion() heap init() GetCommandLineA0 _crtGetEnvironmentStringsA() _setargv() _setenvp() _cinit() 这些函数被调用之后，就会开始调用main函数。根据main函数被调用的特性，会将三个参数压入栈中作为函数的参数，那么我们只要知道以上函数到哪里截止就好了 2.3.1 OllyDBGOllyDBG在加载程序时直接暂停在应用程序的人口处，而不会直接定位到main函数处，需要分析者手动查找定位，我们可以通过main函数的特性查找到所在的位置 识别出GetCommandLineA()函数后，对应前面讨论的main函数特性继续寻找。为了准确识别main函数，可以观察传递参数的个数，如果具有3个参数，便是main函数的调用，双击即可进入main函数的实现中 2.3.2 IDAIDA下的main函数识别更为简便，它会直接分析出main函数所在的位置并显示出来（虽然有的程序放在IDA中是显示没有main函数的）那么，如何使用IDA分析启动函数mainCRTStartup呢？只要在函数窗口(左栏)中找到mainCRTStartup所在的位置，双击便可进入函数实现中 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-2.3 main函数的识别&#x2F;image-46-1024x549.png)","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-2.2了解启动程序","slug":"C++反汇编与逆向分析技术揭秘-2.2 了解启动程序","date":"2023-10-31T09:25:33.000Z","updated":"2023-10-31T09:37:24.470Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-2.2 了解启动程序/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-2.2%20%E4%BA%86%E8%A7%A3%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"2.2 了解启动程序> 需要注意的是，本篇将以VC++ 6.0作为示例，而其他C++的编译器与其差异不大，我们可以用自己的编译器实际操作一下 VC++ 6.0在控制台和多字节编码环境下的启动函数为mainCRTStartup，由系统库KERNEL32.dll负责调用。在mainCRTStartup中再调用main函数。使用VC++ 6.0进行调试时，入口断点总是停留在main函数的首地址处。如何挖掘main函数之前的代码呢？我们可以利用VC++ 6.0的栈回溯功能。在调试环境下，依次选择菜单View→Debug Windows→Call Stack打开出栈窗口(快捷键: Alt+7) 通过实践，我们可以知道，程序运行时调用了三个函数，依次是KERNEL32、mainCRTStartup 和main。其中显示的”KERNEL32 ! 7c817077” 表示在系统库KERNEL32.d11中的地址7c817077处调用mainCRTStartup,我们无法查看KERNEL32.dIl的高级源码，而VC++则提供了mainCRTStartup函数的源码，安装完整版VC++就可以查看。双击CallStack窗口中的mainCRTStartup函数，查看函数的内部实现 接下来，我们需要了解一些启动函数的工作流程： GetVersion函数：获取当前运行平台的版本号。控制台程序运行在Windows模拟的DOS下，因此这里获取的版本号为MS-DOS的版本信息。 _ heap_ init 函数：用于初始化堆空间。在函数实现中使用HeapCreate申请堆空间，申请空间的大小由_ heap_ init 传递的参数决定。_ sbh heap init 函数用于初始化堆结构信息。堆结构的说明将在第7章详细讲解。 GetCommandLineA函数：获取命令行参数信息的首地址。 _ crtGetEnvironmentStringsA 函数：获取环境变量信息的首地址。 _ setargv函数：此函数根据GetCommandLineA获取命令行参数信息的首地址并进行 参数分析，将分离出的参数的个数保存在全局变量**_argc** 中，将分析出的每个命令行 参数的首地址存放在数组中，并将这个字符指针数组的首地址保存在全局变量**argv **中。这样就得到了命令行参数的个数，以及命令行参数信息。 setenvp 函数：此函数根据_ _crtGetEnvironmentStringsA 函数获取环境变量信息的首地址并进行分析，将得到的每条环境变量字符串的首地址存放在字符指针数组中，并将这个数组的首地址存放在全局变量env中。 这就会得到main函数所需要的三个参数，所以当调用main函数的时候，便将**argc**** ，**_argv ，_env 这三个全局变量作为参数，以栈传参的方式传递到main函数中 接下来我们还要认识一个函数： _cinit 函数：用于全局数据和浮点寄存器的初始化。全局对象和IO流的初始化都是通过这个函数实现的。利用函数_initterm进行数据链初始化，这个函数由两个参数组成，类型为”_PVFV*”，这是一个函数指针数组，其中保留了每个初始化函数的地 址。初始化函数的类型为 PVFV, 其定义原型如下: typedef void ( cdecl *_PVFV) (void) ; 也就是说，这个初始化函数是无参数也无返回值的。大家知道，C++ 规定全局对象和静态对象必须在main函数前构造，在main函数返回后析构。所以，这里的_PVFV函数指针数组就是用来代理调用构造函数的 那么，是不是所有由VC++编译出的控制台程序的启动函数都在mainCRTStartup中呢？这要根据编译选项确定。在默认情况下，人口函数为main，这时会从mainCRTStartup启动，再传入main所需要的三个参数，最后调用main函数。重新指定入口函数后，将直接从KERNEL32中调用重新指定的入口函数，而不会经过mainCRTStartup。通过修改编译选项，重新设置入口函数，依次选择菜Procject→Settings→Link→Output,在Enty-pointsymbol中填写需要重新指定新入口的函数名称 但是，如果没有经过mainCRTStartup，而直接调用的新的入口函数，所以堆空间是没有被初始化的，这么做的话，在使用到堆空间的时候，程序会报错并且崩溃","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-2.1程序的真正入口","slug":"C++反汇编与逆向分析技术揭秘-2.1 程序的真正入口","date":"2023-10-31T09:17:07.000Z","updated":"2023-10-31T09:37:19.708Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-2.1 程序的真正入口/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-2.1%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%85%A5%E5%8F%A3/","excerpt":"","text":"2.1 程序的真正入口VC++开发的程序，在调试时总是从main或WinMain函数开始，这就让我们误认为它们是程序的第一条指令执行的地方，这个认识其实是不对的。 其实呢，main 或WinMain也是一个函数，也需要有一个调用者。在它们被调用前，编译器其实已经做了很多事情，所以我们熟悉的main或WinMain应该是”语法规定的用户入口”，而不是”应用程序入口”。在应用程序被操作系统加载的时候，操作系统会分析执行文件内的数据，并且将相关资源都分配出去，再读取执行文件中的代码和数据到合适的内存单元，然后才是执行入口代码，入口代码其实并不是我们熟悉的main或WinMain,通常是mainCRTStartup、wmainCRTStartup、 WinMainCRTStartup 或wWinMainCRTStartup，具体视编译选项而定。 其中，mainCRTStarup和wmainCRTStartup是控制台环境下多字节编码和Unicode编码的启动函数，而WinMainCRTStartup和wWinMainCRTStartup则是Windows环境下多字节编码和Unicode编码的启动函数。在开发过程中，VC++也允许程序员自己指定人口。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.6常量","slug":"C++反汇编与逆向分析技术揭秘-1.6 常量","date":"2023-10-31T09:11:33.000Z","updated":"2023-10-31T09:54:23.931Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.6 常量/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.6%20%E5%B8%B8%E9%87%8F/","excerpt":"","text":"1.6 常量常量和变量不同，变量可以随时改变，在程序运行中可以修改其保存的值；而常量呢，顾名思义，就是一个恒定不变的值，它在内存中也是不可修改的。比如说在程序中见到1、2、3这样的数字，或者是”Hello”这样的字符串，还有数组名称等等，这些都属于常量。程序在运行中是不可以修改它们的数据的 而常量是在程序运行前就已经存在了的，它们被编译到可执行文件中。当程序启动后，它们便会被加载进来。这些数据通常都会在常量数据库中保存，这个区域的属性中是没有可写权限的，所以当你试图对常量进行修改的时候，程序都会报错，引发异常，严重时将会导致程序崩溃 常量数据的地址减去基地址，便是它们的偏移地址 1.6.1 常量的定义在C++中，有两种方式定义常量： 可以用宏机制#define来定义常量 也可以用const将变量定义为一个常量 #define定义的常量名称，编译器对其进行编译时，会将代码中的宏名称替换成对应的信息，宏的使用可以增加代码的可读性 比如我们宏定义了一个常量number_one，并定义其的值为99，所以程序将其输出时，输出得到的结果就是99。而const是为了增加程序的健壮性而存在的 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.6 常量&#x2F;image-31.png) 这里我们将宏定义的常量number_one的值，也就是99，赋值给了const常量number_two，所以最后输出得到的结果也是99 1.6.2 #define 与 const 的区别#define是一个真常量，而const却是由编译器判断实现的常量，是一个伪常量。实际中，使用const定义的变量，最终还是一个变量，只是在编译器内进行了检查，发现有修改则报错 由于编译器在编译期间对const进行检查，因此被const修饰过的变量是可以被修改的。利用指针获取到const修饰过的变量地址，强制将指针的const修饰去掉，就可以修改对应的数据内容 1.6.3 关于这两者在连接生成可执行文件后将不复存在，在二进制编码中也没有这两种类型存在，在实际分析中，我们需要根据自身的经验进行分析还原","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.5地址","slug":"C++反汇编与逆向分析技术揭秘-1.5 地址、指针和引用","date":"2023-10-31T09:09:46.000Z","updated":"2023-10-31T09:37:09.829Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.5 地址、指针和引用/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.5%20%E5%9C%B0%E5%9D%80%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/","excerpt":"","text":"1.5 地址、指针和引用首先我们先来初步了解一下什么时是地址和指针，还有引用 地址：在C++中，地址标号用十六进制表示，如果我们想取一个变量的地址，那么就需要用到”&amp;”符号。但我们需要知道，只有变量才有地址，而常量是没有地址的（当然，我们不将const定义的伪常量包括在内），例如数字100，我们是无法取出它的地址的。取出的地址是一个常量值，我们就无法再对其取地址了。 指针：指针的定义使用”TYPE“,TYPE指的是数据类型，比如说 int，char*……所以任何数据类型都可以定义指针。实际上，指针本身就是一种数据类型，它用来保存各种数据类型在内存中的地址。因为指针本身就是变量，所以是可以对指针变量取地址的，所以会出现多级指针 引用：**引用的定义用”TYPE&amp;”**，TYPE指得是数据类型。在C++中是不可以单独定义的，并且在定义的时候就要进行初始化。引用表示一个变量的别名，对它的任何操作，本质上都是在操作它所表示的变量 1.5.1 地址和指针的区别指针可以通过指针类型对其地址对应的数据进行解释，而一个地址值无法单独解释数据 由于指针保存的数据都是地址，所以无论什么类型的指针在内存中都占用4个字节 下表是指针与变量不同点： 指针地址本身是变量，用于保存变量地址本身是常量，内存标号可修改，再次保存其他变量的地址不可修改可对其执行取地址操作得到地址不可对其执行取地址操作包含对保存的地址的解释信息一个地址值无法单独解释数据**指针与地址之间的不同点** 下表是指针与变量共同点： 指针地址可以取出指向地址内存中的数据可以取出地址对应内存中的数据可以对地址偏移后，再取数据可以偏移后取数据，自身不变可以求两个地址的差可以求两个地址的差 ## 1.5.2 各类型指针的工作方式 在C++中，任何数据类型都有对应的指针类型。从前面的学习中了解到，指针中保存的都是地址，为什么还需要类型作为修饰呢?因为需要用类型去解释这个地址中的数据。每种数据类型在内存中所占的内存空间不同，指针中只保存了存放数据的首地址，而没有指明该在哪里结束。这时就需要根据对应的类型来寻找解释数据的结束地址。例如，同一地址，使用不同类型指针进行访问，取出的内容就会不一样 指针的取内容操作分为两个步骤：先取出指针中保存的地址信息，然后针对这个地址进行取内容，也就是一个间接寻址的过程，这也是识别指针的重要依据 我们需要知道：所有类型的指针对地址的解释都取自于自身指针类型 那么指针支持哪些运算符号呢？在C++中，所有指针类型只支持加减法。指针是永远保存数据的地址、解释地址而存在的。因此，只有加减法才是有意义的，而乘除法是没有意义的 指针的加减法用于地址偏移，但指针的加减法并不像数学中的加减法那样简单。比如说，指针加1后，指针内保存的地址值并不一定会加1，具体的值取决于指针类型，若指针类型为int，指针加1后地址值将会加4。这个4是根据数据类型大小所得到的值。所以说用数据类型去修饰指针是很重要的。 但是，为什么C++要用这种繁琐的地址偏移方法呢，为什么不让加1就是加1呢？这是因为指针中保存的地址为数据的首地址，如果数据类型为数组，为了能够利用指针加1后直接访问到数组内下一成员，所以加的是类型长度，而非数字1 两指针做减法操作，是在计算两个地址之间的元素个数，结果为有符号整数，进行减法操作的两指针必须是同类指针 指针的减法可用于其中地址的比较，也可用于其他场合，比如求数组元素的个数（用两指针相减得到地址的差除以数据类型的大小即可得到数组元素的个数） 另外，两指针相加也是没有意义的 当然，在能够灵活运用指针的同时，指针的运用也要谨慎，以免将指针指向意料之外的地址，错误地修改地址中的数据，造成程序的崩溃 1.5.3 引用引用类型在C++中被描述为变量的别名。实际上，C++为了简化指针操作，对指针操作进行了封装，这就产生了引用类型。其实呢，引用类型就是指针类型，只不过它用于存放地址的内存空间对使用者来说是隐藏的。 引用类型的存储方式和指针是一样的，都是使用内存空间存放地址值。所以在C++中，引用和指针没有区别，只是引用时通过编译器实现寻址，而指针需要手动寻址。指针虽然灵活，但操作失误将造成严重后果，而使用引用则不存在这种问题。因此，C++极力推荐使用引用类型 在汇编代码中，如果没有源码对战，指针和应用都一样难以区分。 不过值得庆幸的时，在反汇编中，没有引用 这种数据类型","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.4布尔类型","slug":"C++反汇编与逆向分析技术揭秘-1.4 布尔类型","date":"2023-10-31T09:08:07.000Z","updated":"2023-10-31T09:37:04.303Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.4 布尔类型/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.4%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"1.4 布尔类型1.4.1 布尔类型的介绍布尔类型很简单，只有 0 与 非0 两种情况，在C++中，0 则表示为假，非0 则表示为真，并且是用bool定义布尔类型变量。布尔类型变量在内存中占一个字节，无论输入给布尔类型变量怎么样的数，只要非0就解释为1，即真，只要是0，就解释为0，即假。 现在我们知道，布尔类型的出现都是用来判断的，所以，它只是一个比较方便的工具，但实际上，任何类型都可以代替它的作用，比如说整型，浮点数，甚至是字符串或者位。 布尔类型的输出值只有1和0（即真和假）两种，所以布尔类型很好理解和学习，但布尔类型非常的重要，在代码中如果遇到布尔类型的运用，我们要能够将其转变为我们能理解的等价代码与解释。 例如下面的代码： 12345678910111213141516171819#include&lt;iostream&gt;int main()&#123; //我们可以用布尔类型来判断用户输入的数是否是零 using namespace std; bool judgment; int num; cout &lt;&lt; &quot;Please input num&quot;; cin &gt;&gt; num; judgment = num; if (!judgment) &#123; cout &lt;&lt; &quot;This is zero!&quot;; &#125; else &#123; cout &lt;&lt; &quot;This is not zero!&quot;; &#125;&#125; 当然我们一般不这么判断，我们知道，直接将if 语句的条件句改为 num &#x3D;&#x3D; 0 就好了，还不用定义布尔类型的judgment。实际上确实如此，但是其实 num &#x3D;&#x3D; 0 这一句就是 ！judgment 的等价代码，而前者更容易被人理解，而后者看似简短但需要仔细琢磨一下。 虽然我们自己写代码的时候可以用最好理解的方式写代码，但是其他方式写出来的我们也能看懂才行❤","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.3字符和字符串","slug":"C++反汇编与逆向分析技术揭秘-1.3 字符和字符串","date":"2023-10-31T09:07:23.000Z","updated":"2023-10-31T09:54:02.668Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.3 字符和字符串/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.3%20%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"1.3 字符和字符串字符串是由一个个字符组成的，而每个字符在字符表中又各自对应着一个唯一的编号。系统通过这些编号在表中查找这些字符，并把它们显示出来。其实，字符表格中的编号就是字符的编码格式。 1.3.1字符的编码在C++中，字符的编码格式有两种，分别是ASCII和Unicode 其中，Unicode是ASCII码的升级版，它弥补了ASCII的不足，在《C++反汇编与逆向分析技术揭秘》中说到，Unicode也是未来编码格式的趋势。 1.3.1.1 ASCII在C++中，ASCII编码在内存中占用一个字节，每个编号表示一个字符，它的表示范围为0~255。而且，ASCII码是可以和整型相互转换的，但是要注意不能超过ASCII码所能表示的最大范围，因为多余的部分将会被舍弃。 一般的，使用char定义ASCII编码格式的字符，如字符’a’可以转换为十六进制的0x61，或者是十进制的97 更多的ASCII码可以搜索ASCII表进行对照 ![ASCII字符代码表](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.3 字符和字符串&#x2F;image-23.png) 1.3.1.2 Unicode由于ASCII所能表示的范围太小，只能表示26个英文字母的大小写和一些常用字符，不同于ASCII，Unicode是占用两个字节的，它的表示范围为0～65535，当然，ASCII也包含在其中 一般的，用wchar_t定义Unicode编码格式的字符。像是字符’a’，我们知道用ASCII码表示是0x61，而用Unicode保存ASCII码的话是0x0061，这是因为ASCII是占用一个字节的，Unicode是占用两个字节的，所以不足的位就用0来补。 1.3.1.3 汉字的编码ASCII编码和Unicode编码都可以存储汉字，但是它们对汉字的编码方式各不相同，所以存储同样的汉字，它们在内存中的编码是不相同 ASCII两个字节解释一个汉字。在汉字国标码中用区和位来定位，第一个字节保存每个区，共94个区；第二个字节保存每个区中的位，共94位 Unicode使用USC-2编码格式，最多可以存储65535个字符，每个数字编号在表中对应一个汉字，但汉字博大精深，65535个肯定不够用，所以USC-2编码格式中只保存了常用字。而为了将更多的汉字都能表示出来，Unicode采用了和ASCII类似的方法，就是用两个Unicode编码解释一个汉字，称之为USC-4编码格式 1.3.2 字符串的存储方式字符串是由一系列按照一定的编码顺序线性排列的字符组成的。在图形中，两点可以确定一条直线，那么在程序中，只要知道字符串的首地址和结束地址就可以确定字符串的长度和大小。字符串的首地址很容易确定，因为在定义字符串的时候都会先指定好首地址。结束地址如何确定呢?有两种做法，一种是在首地址的4字节中保存字符串的总长度;另一种是在字符串的结尾处使用一个规定好的特殊字符，即结束符。为了更好的理解，我们可以看一下下面的距离： 保存总长度法： 我们知道了这串字符串的首地址，如果我们又知道了这串字符串多长，那么是不是就可以知道这段字符串是到哪里停止了，比如说下面这么一串字符中，如果字符串的第一个字符是4，长度是7，那么我们就可以知道这个字符串就是4567890 “1 2 3 4 5 6 7 8 9 0” 保存结束符法： 我们知道了这串字符串的首地址，如果我们又知道了这串字符串是以什么为结束符的，那么是不是就可以知道这段字符串是到什么了，比如说下面这么一串字符中，如果字符串的第一个字符是2，以’\\0’为结束符，那么我们就可以知道这个字符串就是234 “1 2 3 4 \\0 5 6 7 8 9 0” 当然，这两种方法都有各自的优缺点： 保存总长度： **优点:**获取字符串长度时，不用遍历字符串中的每个字符，取得首地址的前n字节就可以得到字符串的长度。(n 的取值一般是1、2、4)**缺点:**字符串长度不能超过n字节的表示范围，且要多开销n字节空间保存长度。如果涉及通信，双方交互前必须事先知道通信字符串的长度。 保存结束符： **优点:**没有记录长度的开销:另外，如果涉及通信，通信字符串可以根据实际情况随时结束，结束时附上结束符即可。**缺点:**获取字符串长度需要遍历所有字符，寻找特殊结尾字符，在某些情况下处理效率低。 C++使用结束符’\\0’作为字符串结束标志。ASCII 编码使用一个字节’\\0’, Unicode 编码使用两个字节’\\0’。需要注意的是，不能使用处理ASCII编码的函数对Unicode编码进行处理，因为如果Unicode编码中出现了只占用一字节的字符,就会发生解释错误 在程序中，都会使用一个存放地址的变量来存放字符串中第一个字符的地址，以便查找使用字符串。比如说使用字符型指针char* ，wchar_t* 都来保存字符串首地址。**所以我们要学好C&#x2F;C++语言** &#x2F;哭 1.3.3 字符串的识别字符串的识别也相对简单，同样是结合上下文，查看调用地址处对该地址的处理过程 在通常情况下，OllyDBG 与IDA都会自动识别出程序中的字符串 在使用IDA的过程中，有时会无法识别字符串，可手动修改 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.3 字符和字符串&#x2F;image-25.png) 这段数据明显为一个字符串，但是IDA并没有分析出来，这时可以选中将要分析的字符串的首地址，使用快捷键A，便可将从分析地址处到’\\0’解释为字符串。下图为识别后的字符串数据。如果想将已识别的变回未识别的状态，可以选中字符串的地址，使用快捷键D就好了 ![](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.3 字符和字符串&#x2F;image-26.png)","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.2浮点数","slug":"C++反汇编与逆向分析技术揭秘-1.2 浮点数","date":"2023-10-31T09:06:53.000Z","updated":"2023-10-31T09:53:46.898Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.2 浮点数/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.2%20%E6%B5%AE%E7%82%B9%E6%95%B0/","excerpt":"","text":"实数数据不可能都是整数，那么就会出现怎么输出小数的问题。在计算机的发展历程中，出现过许多中存储实数的方式，有的现在很少用了不管如何存储，我们都可以划分为定点实数存储方式和浮点实数存储方式这两种。 所谓定点实数，就是约定整数位和小数位的长度。这样的好处是计算的效率高，缺点也显而易见，因为整数部分和小数部分的位数都被固定了，所以存储不灵活。 对应的也有浮点实数的存储方式，简单的理解就是小数点可以移动，是浮动的，不是固定的，这就灵活多了。但这相较于定点实数来说，效率就低得多了。现在主流的实数存储方式就是浮点实数存储方式。但是，在一些条件恶劣的嵌入式开发场合，仍可看到定点实数的存储和使用。 1.2.1 浮点数类型在C&#x2F;C++中，使用浮点方式存储实数，用两种数据类型来保存浮点数: float (单精度)、double (双精度)。float 在内存中占4字节空间，double 在内存中占用8字节空间。由于占用空间大，double可描述的精度更高。这两种数据类型在内存中同样以十六进制方式进行存储，但与整型类型有所不同。整型类型是将十进制转换成二进制保存在内存中，以十六进制方式显示。浮点类型并不是将一个浮点小数直接转换成二进制数保存，而是将浮点小数转换成的二进制码重新编码，再进行存储。C&#x2F;C++的浮点数是有符号的。 注意：在C&#x2F;C++中，将浮点数强制转换为整数时，不会采用数学上四舍五人的方式，而是舍弃掉小数部分，不会进位。下面以C语言为例； 12345678910#include&lt;stdio.h&gt;main()&#123; int num = 127; int a ; float b ; a = num / 10 ; b = (float)num / 10 ; printf(&quot;a=%d,b=%f&quot;,a,b);&#125; 该段代码最后会输出 a&#x3D;12，b&#x3D;12.700000，我们发现 a 的值是12，而不是13，说明并不是四舍五入的原理。所以这就是浮点数强制转换为整数时，直接将小数点后面的全部舍去 另外，我们还需要知道，在使用浮点数之前需要先对浮点寄存器进行初始化，然后才能正常运行，若像下面代码一样则会使程序崩溃 12345678#include&lt;stdio.h&gt;main()&#123; //在未使用到浮点数情况下， //程序输入小数会报错，这是因为没有对浮点寄存器进行初始化 int n = 0; scanf (&quot;%f&quot;，&amp;n) ;&#125; 解决办法是：在使用该浮点数之前定义一个浮点类型的变量即可对浮点寄存器进行初始化 1.2.2 浮点数的编码方式浮点数編码转换采用的是IEEE规定的编码标准，float和double这两种类型数据的转换原理相同，但由于表示的范围不一样，编码方式有些许区别。IEEE 规定的浮点数编码会将一个浮点数转换为二进制数。以科学记数法划分，将浮点数拆分为3部分:符号、指数、尾数。. 1.2.2.1 float类型的IEEE编码float类型在内存中占4字节(32 位)，最高位用于表示符号，在剩余的31位中，从右向左取8位用于表示指数，其余用于表示尾数，如下图所示 ![浮点数的二进制表示说明](&#x2F;images&#x2F;C++反汇编与逆向分析技术揭秘-1.2 浮点数&#x2F;image-20231031171241838.png) 1.2.2.2 double类型的IEEE编码double类型表示的范围更大，精准度也更高，当然占用的空间更多，是float类型所占用空间的两倍。 double类型在内存中占8字节（64位），与float一样的是，最高位也是用于表示符号；不同的是，指数位占11位，剩余的52位用于表示尾数。 而且double类型的IEEE编码转换方式与float类型，除了判断指数符号上有一点点区别之外，其余的都是基本一样的。 1.2.3 基本的浮点数指令之前有讲到，浮点数操作是通过浮点寄存器来实现的，而普通数据类型使用的是通用寄存器，它们分别使用两套不同的指令。 首先，我们要先了解一下什么是栈 栈（我们先来初步了解一下） 栈，存储货物或供旅客住宿的地方，可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。栈是限制插入和删除只能在一个位置上进行的线性表。关于栈的稍详细内容请看另一篇文章：初步了解栈❤ 浮点寄存器是通过栈结构来实现的，由ST(0)~ ST(7)共8个栈空间组成，每个浮点寄存器占8字节。每次使用浮点寄存器都是率先使用ST(0)，而不能越过ST(0)直接使用ST(1) （更不用说直接使用更里面的空间了）。浮点寄存器的使用就是压栈、出栈的过程。当ST(0)存在数据时，执行压栈操作后，ST(0)中的数据将装人ST(1)中，如无出栈操作，将顺序地向下压栈，直到将浮点寄存器占满。常用浮点数指令的介绍如表所示，其中，IN表示操作数入栈，OUT表示操作数出栈。 常用浮点数指令表 指令名称使用格式指令功能FLDFLD IN将浮点数IN压入ST(0)中。IN（mem 32/64/80）FILDFILD IN将整数IN压入ST(0)中。IN（mem 32/64/80）FLDZFLDZ将0.0压入ST(0)中FLD1FLD1将1.0压入ST(0)中FSTFST OUTST(0)中的数据以浮点形式存入OUT地址中。OUT(mem 32/64)FSTPFSTP OUT和FST指令一样，但会执行一次出栈操作FISTFIST OUTST(0)数据以整数形式存入OUT地址中。OUT(mem 32/64)FISTPFISTP OUT和FIST指令一样，但会执行一次出栈操作FCOMFCOM IN将IN地址数据与ST(0)进行实数比较，影响对应标记位FTSTFTST比较ST(0)是否为0.0，影响对应标记位FADDFADD IN将IN地址内的数据与ST(0)做加法运算，结果放入ST(0)中FADDPFADDP ST(N).ST将ST(N)中的数据与ST(0)中的数据做加法运算，N为0~7中任意一个，先执行一次出栈操作，然后将相加结果放入ST(0)中保存 其他运算指令和普通指令类似，只需在前面加F即可，如FSUB和FSUBP等。 在使用浮点指令时，都要先利用ST(0)进行运算。当ST(0)中有值时，便会将ST(0)中的数据顺序向下存放到ST(1)中，然后再将数据放入ST(0)中。如果再次操作ST(0)，则会先将ST(1)中的数据放入ST(2)中，然后将ST(0)中的数据放入ST(1)中，最后才将新的数据存放到ST(0)。以此类推，**在8个浮点寄存器都有值的情况下继续向ST(0)中存放数据,这时会丢弃ST(7)中数据信息**。 其实，float类型的浮点数虽然占4字节，但是都以8字节方式进行处理。当浮点数作为参数时，并不能直接压栈。PUSH指令只能传入4字节数据到栈中，这样就有4字节的数据丢失了。这就是为什么使用printf函数以整数形式输出浮点数时会产生错误的原因。printf以整数形式输出时，将对应参数作为4字节数据，按补码方式进行解释；而真正压入的参数时浮点类型时，数据长度其实是8字节，需要用浮点编码方式来解释。如果是将浮点数作为返回值也是一样的，需要传递8字节数据 我们可以自己尝试使用各指令，观察浮点指令的特点的同时，熟悉数据传输类型指令的使用","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"C++反汇编与逆向分析技术揭秘-1.1整型","slug":"C++反汇编与逆向分析技术揭秘-1.1 整型","date":"2023-10-31T09:06:27.000Z","updated":"2023-10-31T09:36:44.641Z","comments":true,"path":"2023/10/31/C++反汇编与逆向分析技术揭秘-1.1 整型/","link":"","permalink":"http://example.com/2023/10/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98-1.1%20%E6%95%B4%E5%9E%8B/","excerpt":"","text":"1.1 整型C++提供的整数数据类型有三种: int、long、 short 其中int类型、long类型在内存中占4个字节，short类型在内存中占2个字节；而一个字节可由两个十六进制数表示，一个十六进制数可由四个二进制数表示，每个二进制数表示一位，那么一个字节就在内存中占8位 在C++中，整数类型又可以分为有符号型与无符号型两种。有符号整数可用来表示负数，而无符号整数只能是正数，它们在数据的取值范围上也有区别 1.1.1 无符号整数在内存中，无符号整数的所有位都用来表示数值。以无符号整型数据unsigned int为例，而我们知道，此类型（int型）的变量在内存中占4字节，由8个十六进制数组成，那么其取值范围用十六进制表示就是0x00000000 ~ 0xFFFFFFFF,如果转换为十进制数，则表示范围就是0 ~ 4294967295。 需要注意的是，当无符号整型不足32位时，用0来填充剩余高位，直到占满4字节内存空间为止。例如，数字7对应的二进制数为111，只占了3位，按4字节大小保存，剩余29个高位将用0填充，填充后结果为: 00000000000000000000000000000101 ;转换成十六进制数就是0x00000005。这种存放方式称之为”小尾方式”，”小尾方式”存放是以字节为单位，按照数据类型长度，高数据位对高地址，低数据位对低地址。当然，也有”大尾方式”，它则与”小尾方式”相反。 我们知道，因为无符号整数并不存在正负之分，都是正数，所以无符号整数在内存中都是以真值的形式存放的，每一位都可以参与数据表达。无符号整数可表示的正数范围是补码的一倍。 1.1.2 有符号整数有符号整数中用来表示符号的是最高位一符号位。 最高位为0表示正数，最高位为1表示负数，有符号整数在内存中同样占4字节，但由于最高位为符号位，不能用来表示数值，因此有符号整数中用来表示符号的是最高位一符号位，即最高位为0表示正数，最高位为1表示负数。 有符号整数在内存中同样占4字节，但由于最高位为符号位，不能用来表示数值，因此有符号整数的取值范围要比无符号整数取值范围少1位，即0x80000000 ~ 0x7FFFFFFF，如果转换为十进制数，则其表示范围为-2 147 483 648 ~ 2 147 483 647。在有符号整数中，正数的表示区间为: 0x0000000 ~ 0x7FFFFFF ;负数的表示区间为:0x80000000 ~ 0xFFFFFFFF. 我们要知道，计算机是只会进行加法运算的，所以所有我们输入的减法运算，其实都要转换为加法运算，例如1 - 3 就会是 1 + ( - 3 )。 另外，我们还需要知道，负数在内存中都是以补码形式存放的，补码的规则是用0减去这个数的绝对值，也可以简单地表达为对这个数值取反加1。例如，对于-3，可以表达为0 - 3。为了计算方便，人们也常用取反加一的方式来求得补码。本章的最后会介绍这两种计算方法的原理。值得一提的是，对于4个字节的补码，0x80000000所表达的意义可以是负数0，也可以是0x80000001减去1。然而，对于0来说，它的正负值是相等的，没有必要还来个负数0，因此，也就把这个值的意义规定为0x00000001减去1,这样0x80000000也就成为4字节负数的最小值了。这也是为什么有符号整数的取值范围中，负数区间总是比正数区间多一个最小值的原因。 所以，我们可以通过查看数据表示为十六进制数时的最高位来判断该数据的正负，最高位小于8则为正数，大于8则为负数（另外，如果是负数，则需转换为真值，才能得到对应负数的数值） 对于1.1.2 有符号整数中补码的运算规则，有兴趣的可以继续看完。 我们已经知道，负数在内存中都是以补码形式存放的，我们可以用0减去这个数的绝对值，也可以表达为对这个数值取反加1。例如，对于-3，可以表达为0-3，而0xFFFFFFD+3等于0 (进位丢失),所以-3的补码也就是0xFFFFFFD了。相应地，0xFFFFFFD 作为一个补码，最高位为1,视为负数，转换回真值同样也可以用0-0xFFFFFFD的方式，于是得到-3。为了计算方便，人们也常用取反加一的方式来求得补码，因为对于任何4字节的数值x，都有x+x(反)&#x3D;0xFFFFFFF,于是x+x(反)+1&#x3D;0,接下来就可以推导出0-x&#x3D;x(反)+1了。 如设有符号数x, y,求x-y的值，我们可以推导出x-y&#x3D;x+(0-‘y’)，根据补码的规则，当y为负数的时候，0-‘y’等价于y的补码。对于y的补码，我们记为y(补),所以x-y&#x3D;x+y (补)。例如，(3-2)可会转换成(3+ (-2))，运算过程为: 3的十六进制原码0x00000003加上-2的十六进制补码0xFFFFFFFE，从而得到0x100000001。由于存储范围为4字节大小，两数相加后产生了进位，超出了存储范围，超出的1将被舍弃。进位被舍弃后，结果为0x00000001。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"IDA常用快捷键","slug":"IDA几种常用快捷键","date":"2023-10-27T16:35:42.000Z","updated":"2023-10-28T13:40:30.009Z","comments":true,"path":"2023/10/28/IDA几种常用快捷键/","link":"","permalink":"http://example.com/2023/10/28/IDA%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"IDA 几种常用快捷键IDA&nbsp;是反汇编程序 ，反汇编程序是一种软件，用于将机器代码转换为人类可读的格式，称为汇编语言。而且 IDA 是用作静态分析的，IDA 是神器，尤其是你一个 F5 能看到伪代码，然后修改修改贴到 C 程序里直接能编译运行的时候，你就会深刻感受到 IDA 的强大。 IDA 里有很多强大的功能，其中很多功能我们可以用快捷键来快速实现 1. F5 与 TabF5 键和 Tab 键的功能是基本一样的，都可以用来反编译，也就是查看伪代码，一般我们用 IDA 打开一个程序是下面这个样子的： 而这种形式我们看不懂，或者不太能看懂，那么我们就可以用 IDA 强大的功能查看它的伪代码，那我们要怎样可以快速查看呢，就是 F5，我们按 F5 就能进入下面这个窗口，这样是不是就亲切多了 当然，按 tab 键也能实现上面的功能（ tab 键就是大写锁定上面那个），不过 tab 键相较于 F5 多一个小功能，那就是返回原本的形式，我们可以自己打开一个试试看 2. Shift + F12shift + f12 是一个重要的功能，它的功能就是把所有的字符串都整理出来 像上图这样，我们就可以看到所有的字符串信息，我们可以选中一个 双击 这样我们就能看到这段字符串的一些有用信息 善用 shift + f12 是很重要的，这对我们找到我们想要的信息有很大的帮助 3. Ctrl + XCtrl + X 也是一个非常重要的功能，它可以帮我们找到一段信息在哪里被调用了，比如说上面讲 Shift + f12 的时候，我们找到了”You are correct!”所在的位置，那么哪里调用了它呢，这时候 Ctrl + X 的作用就体现出来了，Ctrl + X 也被称为 交叉引用 ，我们选中字符串 “You are correct!” 然后使用 Ctrl + X， 这样就会告诉你都有哪些地方调用了这段字符串，这里显示只有一处调用了它，我们可以双击那个蓝条条，直接进入调用它的地方 然后我们到了这里，这个时候我们就用 F5 或者 tab 键查看伪代码 这样，我们就知道我们找的这段字符串在哪里出现的了 4. EscEsc 我们都很熟悉，就是退出、退回，所以当我们点进一个函数的时候，查找了一个数据后，用 esc 返回上一层，比如进来了这个_main()函数 我们点 esc 就能回去了 5. Shift + EShift + E 可以用来提取数据，比如说下图一个叫 aZyxwvutsrqponm 的 它的数据是后面绿色的部分，但是，我们发现，这串绿色的字中间有参杂着不是数据的东西（注意看单引号从哪开始，在哪结束），而且有些数据没有放在同一行，我们很容易弄混，这个时候 Shift + E 就有大作用了 我们选中 aZyxwvutsrqponm，然后使用 shift + e ，这个时候它就显示了 aZyxwvutsrqponm 的数据 我们还可以选择输出的形式，比如上图就是 16 进制的形式，我们还可以把它弄成 10 进制的 （还有字符形式等形式） 当然我们还可以导出这段数据，点击下面的 Export 就可以了，这时它就会生成一个文本文件到你的程序的目录下 6. &#x2F; (添加注释)我们在分析的时候，添加注释是个好习惯，这能够让我们保持清晰的思路，而且不会遗忘之前看懂的东西，那么怎么直接在 IDA 上添加注释呢？ 我们选中一行，直接点 左斜杠 &#x2F; 就好 当然，直接 右键 → Edit comment… 也是可以添加注释的 7. \\ (隐藏类型描述)很多时候，在反编译后伪代码的界面中会有变量和函数的类型描述，当这些描述太多的时候，会影响我们对代码的判断，这个时候我们可以使用 右斜杠 \\ 来隐藏掉这些描述 不过有的时候，这些描述是必要的，我们可以再使用一次 右斜杠 \\ 来显示这些描述 当然，我们也可以通过 右键 → Hide casts &#x2F; Show casts 来隐藏或者显示描述 8. Alt + Talt + t 可以用来搜索字符串，我们可以在 ida 里试试， 使用 alt + t 后会出现上面的窗口，然后我们在 String 那里填你想要输入的字符串，比如我想找 right 在哪 这样 ida 就会帮你找到 right 的位置 9. Alt + Lalt + l 的作用就是标记，可以自己在 ida 里尝试一下， 选择一处然后按 alt + l ，可以明显看到变化 10. Alt + Malt + m 和之前讲的添加注释很像，我们在 ida 里试试， 选中一行，然后按 alt + m， 就会出现下面这个窗口，然后我们先随便输入一个东西， 点击 OK 后，我们可以看到操作后的那一行变了色， 我们把鼠标放过去，就可以看到我们刚刚输入的东西 11. N 键n 键的作用是重命名，很简单，就是 ida 可以帮你把一个变量的名字换成你输入的名称，而且每处调用该变量的地方都会帮你修改，我们来试试， 我们选中一个变量，可以看到，黄底的都是这个变量，我们按 N 键， 这样就出现了下面那样的窗口，我们可以重命名这个变量了， 我们把它改成 input， 我们可以看到，原本叫 byte_4212C0 的都改成了我们输入的 input 12. G 键g 键可以跳转到我们想要去的地址处，比如我们记住了下面那处地址后，到了其他地址后想回来，就可以用 g 键，输入，然后跳转，就回来了 13. A 键a 键的作用呢，不好说，不过看了实例后就会明白了， 像下图的这样明显是字符串的，这种形式我们不好看，那么我们选中首地址后按一下 a 键后会怎么样呢？ 瞧，它就变成了这样，是不是好看多了 14. Ctrl + Z说了这么多操作，那么如果不小心用错了怎么办，没事，ida 还有撤回操作 没错，就是 ctrl + z ，快去试一试吧！ 15. 其它以上 14 种是我最常用的，还有其他的快捷键没有介绍，有兴趣的可以查找相关信息了解一下","categories":[{"name":"IDA 学习记录","slug":"IDA-学习记录","permalink":"http://example.com/categories/IDA-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-10-27T14:43:22.000Z","updated":"2023-10-31T09:58:45.861Z","comments":true,"path":"2023/10/27/hello-world/","link":"","permalink":"http://example.com/2023/10/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Start","slug":"Start","permalink":"http://example.com/categories/Start/"}],"tags":[]}],"categories":[{"name":"汇编语言学习","slug":"汇编语言学习","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"2、寄存器（CPU 工作原理）","slug":"汇编语言学习/2、寄存器（CPU-工作原理）","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/categories/WriteUp/"},{"name":"Re","slug":"WriteUp/Re","permalink":"http://example.com/categories/WriteUp/Re/"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"14章-运行时压缩","slug":"逆向工程核心原理/14章-运行时压缩","permalink":"http://example.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/14%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/"},{"name":"Python相关","slug":"Python相关","permalink":"http://example.com/categories/Python%E7%9B%B8%E5%85%B3/"},{"name":"栈相关","slug":"栈相关","permalink":"http://example.com/categories/%E6%A0%88%E7%9B%B8%E5%85%B3/"},{"name":"其它","slug":"其它","permalink":"http://example.com/categories/%E5%85%B6%E5%AE%83/"},{"name":"1、基础知识","slug":"汇编语言学习/1、基础知识","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"},{"name":"IDA 学习记录","slug":"IDA-学习记录","permalink":"http://example.com/categories/IDA-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"Start","slug":"Start","permalink":"http://example.com/categories/Start/"}],"tags":[]}