{"meta":{"title":"This is Title","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2023-10-27T15:04:19.000Z","updated":"2023-10-27T17:10:23.471Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Welcome to my blog! Have a nice day!"},{"title":"categories","date":"2023-10-27T14:56:34.000Z","updated":"2023-10-27T15:00:41.794Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"3.3位运算","slug":"3.3 位运算","date":"2023-10-31T09:28:28.000Z","updated":"2023-10-31T09:28:17.350Z","comments":true,"path":"2023/10/31/3.3 位运算/","link":"","permalink":"http://example.com/2023/10/31/3.3%20%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"3.3 位运算二进制数据的运算成为位运算，位运算操作有： “&lt;&lt;”：左移运算，最高位左移到 CF 中，最低位补零 “&gt;&gt;”：右移运算，最高位不变，最低位右移到 CF 中 “ ‘ “：位或运算，在两个数的相同位上，只要有一个 1，则结果为 1 “ &amp; “：位与运算，在两个数的相同位上，只有同时为 1 时，结果才为 1 “ ^ “：异或运算，在两个数的相同位上，两个值相同则为 0 ，不同则为 1 “ ~ “：取反运算，将操作数每一位上的 1 变为 0 ，0 变为 1 位运算在程序算法中被大量使用，如不可逆算法 md5，就是通过大量位运算来完成的。如何使一个数不可逆转呢？利用位运算就可以达到目的，比如说呢，x &amp; 0 &#x3D; 0 ,但是我们并不能通过结果来逆推 x 的值的。 由于大多数位运算会导致数据信息的丢失（其中 取反” ~ “ 和 异或” ^ “ 是可以逆推的），所以，在知道原算法的前提下，使用逆转算法是无法计算出原数据的。在算术运算中，编译器会将各种运算转换成位运算，因此掌握位运算对于学会算法识别是一件非常重要的事。 接下来我们来看看，位运算符号又是如何转换成汇编代码的呢 12345678910111213141516171819int main() //C++ 源码说明：位运算&#123; int argc = 1; argc = argc &lt;&lt; 3; //将变量 argc 左移 3 位 argc = argc &gt;&gt; 5; //将变量 argc 右移 5 位 argc = argc &#x27; 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做位或运算 argc = argc &amp; 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做位与运算 argc = argc ^ 0xFFFF0000; //将变量 argc 与 0xFFFF0000 做异或运算 argc = ~argc; //将变量 argc 做按位取反运算&#125; 我们来看看汇编代码是什么 ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\1image.png) 上面展示了有符号数的位运算，对于无符号数而言，转换的位运算指令将会发生转变，我们也来看看 1234567891011int main() //无符号位运算&#123; unsigned int argc = 1; argc = argc &lt;&lt; 3; //将变量 argc 左移 3 位 argc = argc &gt;&gt; 5; //将变量 argc 右移 5 位&#125; ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\1image-1.png) 可以看到，无符号数的左移运算和有符号数的是一样的，都不需要考虑到符号位。但右移运算则有变化，有符号数对应的指令为 sar ，可以保留符号位，而无符号数不需要符号位，所以直接使用 shr 将最高位补 0","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"3.2关系运算和逻辑运算","slug":"3.2 关系运算和逻辑运算","date":"2023-10-31T09:28:04.000Z","updated":"2023-10-31T09:27:48.477Z","comments":true,"path":"2023/10/31/3.2 关系运算和逻辑运算/","link":"","permalink":"http://example.com/2023/10/31/3.2%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/","excerpt":"","text":"3.2 关系运算和逻辑运算关系运算用于判断两者之间的关系，如等于、不等于、大于等于、小于等于、大于和小于，对应的符号分别为”&#x3D;&#x3D;”、”!&#x3D;”、 “&gt;&#x3D;”、”&lt;&#x3D;”、”&gt;”、”&lt;”，关系运算的作用是比较关系运算符左右两边的操作数的值，得出一个判断结果:真或假。逻辑运算用于判定两个逻辑值之间的依赖关系，如或、与、非，对应的符号有”‘’”、”&amp;&amp;”、”!” ， 逻辑运算也是可以组合的，执行顺序和关系运算相同。 或 运算：比较运算符”‘’”左右的语句的结果，如果有一个值为真，则返回真值；如果都为假，则返回假值 与 运算：比较运算符”&amp;&amp;”左右的语句的结果，如果有一个值为假，则返回假值；如果都为真值，则返回真值 非 运算：改变运算符 “!” 后面的语句的真假结果，如果该语句的结果为真值，则返回假值；如果为假值，则返回真值 3.2.1 关系运算和条件跳转的对应如何选择条件跳转指令，需要根据所使用到的关系运算，不同的关系运算对应的条件跳转指令也不同 下面我们来看看各种关系对应的条件跳转指令 指令助记符检查标记位说明JZZF==1等于 0 则跳转JEZF==1相等则跳转JNZZF==0不等于 0 则跳转JNEZF==0不相等则跳转JSSF==1符号为 负 则跳转JNSSF==0符号为 正 则跳转JP/JPEPF==1\"1\"的个数为偶数则跳转JPN/JPOPF==0\"1\"的个数为奇数则跳转JOOF==1溢出则跳转JNOOF==0无溢出则跳转JCCF==1进位则跳转JBCF==1小于则跳转（无符号比较）JNAECF==1不大于等于则跳转JNCCF==0无进位则跳转JNBCF==0不小于则跳转JAECF==0大于等于则跳转JBECF==1 或 ZF==1小于等于则跳转JNACF==1 或 ZF==1不大于则跳转JNBECF==0 或 ZF==0不小于等于则跳转JACF==0 或 ZF==0大于则跳转（无符号比较）JLSF != OF小于则跳转（有符号比较）JNGESF != OF不大于等于则跳转JNLSF == OF不小于则跳转JGESF == OF大于等于则跳转JLEZF != OF 或 ZF==1小于等于则跳转JNGZF != OF 或 ZF==1不大于则跳转JNLESF == OF 或 ZF==0不小于等于则跳转JGSF == OF 或 ZF==0大于则跳转（有符号比较） 其中，有一定的规律，比如 A 和 G 表示的是大于，比如说 JA 和 JG；B 和 L 表示的是小于，比如说 JB 和 JL；E 表示的是相等，比如说 JE 是相等则跳转，JGE/JAE 是大于等于则跳转，JLE/JBE 是小于等于则跳转；N 表示的是 不 ，比如说 JNE 是不相等，JNG/JNA 是不大于则跳转，JNGE/JNAE 是不大于等于则跳转...... 在通常情况下，这些条件跳转指令都与 CMP 和 TEST 匹配出现，但条件跳转指令检查的是标记位。因此，在有修改标记位的代码处，也可以根据需要使用条件跳转指令来修改程序流程 3.2.2 表达式短路表达式短路通过 “逻辑与” 运算 和 “逻辑或” 运算 使语句根据条件在执行时发生中断，从而不予执行后面的语句。如何利用表达式短路来实现语句中断呢？根据逻辑与和逻辑或运算的特性，如果是与运算，当运算符左边的语句块为假值时，则直接返回假值，不执行右边的语句；如果是或运算，当运算符左边的语句块为真值时，直接返回真值，不执行右边的语句块 我们将进一步学习和理解表达式短路的构成 ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image-165.png) //当 num 等于 0 时，逻辑与 运算符左边的值为假，将不会执行右边语句 num && (num += Accumulation(num - 1)); 00007FF613B1177E cmp dword ptr [num],0 //这里为短路模式汇编代码，比较变量 num 是否等于 0 00007FF613B11785 je Accumulation+46h (07FF613B117A6h) //通过 je 跳转，检查 ZF 标记位等于 1 跳转 00007FF613B11787 mov eax,dword ptr [num] //跳转失败，进入递归调用 00007FF613B1178D dec eax 00007FF613B1178F mov ecx,eax //对变量减 1，并将结果转移 00007FF613B11791 call Accumulation (07FF613B111AEh) 00007FF613B11796 mov ecx,dword ptr [num] 00007FF613B1179C add ecx,eax 00007FF613B1179E mov eax,ecx 00007FF613B117A0 mov dword ptr [num],eax //继续调用自己，形成递归 return num; 00007FF613B117A6 mov eax,dword ptr [num] 在上面的实例中，通过递归函数 Accumulation 完成了整数累加和计算，在递归函数的构成中，必须要有一个出口，本实例选择了逻辑运算”&amp;&amp;”来制造递归函数的出口。通过使用 CMP 指令来检查运算符左边的语句是否为假值，根据跳转指令 JE 来决定是否跳过程序流程。当变量 num 为假时，JE 成功跳转，跳过递归函数调用，程序流程将会执行到出口 return 处 逻辑运算” ‘’ “虽然与逻辑运算”&amp;&amp;”有些不同，但它们的构成原理相同，只需稍作修改就可以解决这一类型的问题。将 逻辑与 运算修改为 逻辑或 运算来实现表达式短路 ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image-166.png) //当 num 等于 0 时，逻辑或 运算符左边的值为真，将不会执行右边语句 (num == 0) '' (num += Accumulation(num - 1)); //使用逻辑或 运算造成的表达式短路，生成的反汇编代码与使用逻辑与 时是样的 00007FF67B54177E cmp dword ptr [num],0 00007FF67B541785 je Accumulation+46h (07FF67B5417A6h) 00007FF67B541787 mov eax,dword ptr [num] 00007FF67B54178D dec eax 00007FF67B54178F mov ecx,eax 00007FF67B541791 call Accumulation (07FF67B5411AEh) 00007FF67B541796 mov ecx,dword ptr [num] 00007FF67B54179C add ecx,eax 00007FF67B54179E mov eax,ecx 00007FF67B5417A0 mov dword ptr [num],eax return num; 00007FF67B5417A6 mov eax,dword ptr [num] 我们对比一下可以发现，两种短路表达式编译为相同的汇编代码，虽然使用的逻辑运算符不同，但在这两种情况下，运算符的左边的语句块都是在与 0 值作比较，而且判定的结果都是等于 0 时不执行运算符右边的语句块，所以就变成了相同的汇编代码 转换成汇编代码后，通过比较后跳转来实现短路，这种结构实质上呢，就是分支结构，在反汇编代码中时没有表达式短路的（虽然这节标题叫作表达式短路），我们能够看到的都是分支结构，至于什么是分支结构我们之后会详细了解的 3.2.3 条件表达式条件表达式，也就是三目运算 表达式 1 ? 表达式 2 : 表达式 3 我们来复习一下：如果表达式 1 是真值，那么执行表达式 2；如果是假值，那么执行表达式 3 条件表达式也属于表达式的一种，所以表达式 1，表达式 2，表达式 3 都可以套用到条件表达式中，条件表达式被套用后，其执行顺序依然是由左向右，自内向外 条件表达式的构成应该是先判断再选择，但是，编译器并不一定会按照这种方式进行编译，当表达式 2 与表达式 3 都为常量时，条件表达式可以被优化；而当表达式 2 或表达式 3 中的一个为变量时，条件表达式不可以被优化，会转换成分支结构；当表达式 1 为一个常量值时，编译器会在编译过程得到答案，将不会有条件表达式存在 编译器有四种条件表达式的转换方案 表达式 1 为简单比较，而表达式 2 和表达式 3 两者的差值等于 1 表达式 1 为简单比较，而表达式 2 和表达式 3 两者的差值大于 1 表达式 1 为复杂比较，而表达式 2 和表达式 3 两者的差值大于 1 表达式 2 和表达式 3 有一个是变量，于是没有优化 我们可以自己通过反汇编形式对比这 4 种转换方案，找出它们的特征，分析它们之间的区别","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"3.1算术运算和赋值","slug":"3.1 算术运算和赋值","date":"2023-10-31T09:27:44.000Z","updated":"2023-10-31T09:27:09.076Z","comments":true,"path":"2023/10/31/3.1 算术运算和赋值/","link":"","permalink":"http://example.com/2023/10/31/3.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C%E8%B5%8B%E5%80%BC/","excerpt":"","text":"3.1 算术运算和赋值 本节内容稍长，爱护眼睛，望周知 Table of Contents 3.1.1 各种算术运算的工作方式 3.1.1.1 加法 ODebug ORelease ▲常量扩散 ▲常量折叠 3.1.1.2 减法 3.1.1.3 乘法 3.1.1.4 除法 O除法计算约定 O对整数除法的优化 ▲除数为 2 的幂 ▲除数为非 2 的幂 ▲除数为负的 2 的幂 ▲除数为负的非 2 的幂 ▲除法优化的原则 3.1.2 算术结果溢出 3.1.3 自增与自减 算术运算是指加法、减法、乘法、除法这四种数学运算，也称为四则运算。我们知道，数学上也有四则运算，那计算机上的四则运算和数学上的有什么不同呢？ 首先，赋值运算类似于数学中的”等于”，是将一个内存单元中的数据传递到另一个内存空间中。由于内存没有处理器那样的控制能力，各个内存单元之间是无法直接传递数据的，所以必须通过处理器访问并中转，以实现两个内存单元间的数据传输。 1234567int main()&#123; int a = 10; //这里的等号&#x27;=&#x27;就是赋值运算，将10赋值给变量a int b; b = a; //这里将变量a 的值赋值给变量b ，而变量a 所在的内存单元中的数据是 10，所以传递到变量b 的内存单元后，变量b 表示的就是 10&#125; 在 C++ 中，算术运算于其他传递计算结果的代码组合后才能被视为一条有效的语句，也就是说算术运算单独存在是没有意义的，因为单独的算术运算虽然可以编译通过，但是不会生成代码，就像你有炊具但是没有食材，最后是做不出饭菜的。不过，因为只进行计算而没有 传递结果的运算会被编译器视为无效语句，与空语句等价，所以不会对程序结果有任何结果 3.1.1 各种算术运算的工作方式3.1.1.1 加法加法运算对应的汇编指令为 ADD，也就是英文中的 ‘add’ ，翻译过来就是添加。在执行加法运算的时候，针对不同的操作数，转换的指令也会不同，而编译器会根据优化方案选择最佳的匹配方案。一般 C++ 最常用的优化方案是下面这两种： 生成文件占用空间最小 执行效率最快 本节内容我们来对比和分析一下Debug编译选项组与Release编译选项组这两个选项对各种计算产生的目标代码方案。 Debug在使用Debug编译选项组的时候，C++产生的目标汇编代码会和源码一一对应： ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image-20221104144856347.png) 现在我们来分析一下Debug编译选项组下编译的汇编代码： 首先我们先是定义了变量 number_one 和变量 number_two ，我们可以看到编译器是用 mov 将数 0 传入 number_one 所在的地址中，对于 number_two 也是同理 然后是变量 + 常量的运算，我们可以看到，编译器将放在 number_one 地址处的数据先是用 mov 放到了 eax 中，然后对 eax 执行加 1 运算（在汇编中，inc 的作用是将指定的操作数的内容加1，再将结果送回到该操作数），最后将结果放回变量 number_one 中，完成加法运算 接下来是变量 + 变量的运算，由上面的C++源码对比可以看出，编译器先使用 eax 存放变量 number_one，然后使用 ecx 存放变量 number_two，再将 eax 的数据加到 ecx 里，完成后将 ecx 的数据转移到 eax （eax 原本的数据将会被覆盖掉），最后再将 eax 的数据存入变量 number_two 的地址处。这样就完成了number_three &#x3D; number_one + number_two 的运算 其中 eax 、ecx 是寄存器 ReleaseC++ 中，很多编译器的Release 编译选项组的默认选项是第二种方案–执行效率优先 在这种方案下，编译出来的汇编代码将会有较大的变化。因为其遵循效率优先，所以编译器会将无用代码去除，并将可合并代码进行归并处理。比如连续两次给同一个变量赋值，它会将第一次赋值给省去，因为在其后又重新对其进行了赋值操作，而且在此之前没有对该变量的任何访问，所以编译器判定此句代码是被删除的。 首先，我们先了解两个关于优化的概念。在编译过程中，编译器常常会采用”常量传播”和”常量折叠”这样的方案对代码中的变量与常量进行优化 常量传播将编译期间可计算出结果的变量转化成变量，这样就减少了变量的使用，比如说： 12345void main()&#123; int nVar = 1; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 我们知道，上面的变量 nVar 是一个在编译期间可以计算出结果的变量。所以，在程序中所有引用到 nVar 的地方都可以直接用常量 1来代替，这样代码就可以变成下面这样： 1234void main()&#123; printf(&quot;nVarOne = %d \\r\\n&quot;,1);&#125; 常量折叠当计算公式中出现多个常量进行计算的时候，且编译器可以在编译期间计算出结果时，这样所有的常量计算都将被计算结果代替（个人觉得这个大多数时候是没什么用的，因为我们写代码的时候一般不会闲着没事把数拆开） 12345void main()&#123; int nVar = 1 + 5 - 3 * 6; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 这个时候就不会生成计算指令，因为”1 + 5 - 3 * 6 “的值是可以在编译过程中计算出来的，所以编译器会先计算出”1 + 5 - 3 * 6 “的结果，也就是 -12，然后将数值 -12 替换掉原表达式 12345void main()&#123; int nVar = -12; printf(&quot;nVarOne = %d \\r\\n&quot;,nVar);&#125; 接下来我们可以再使用”常量传播” 1234void main()&#123; printf(&quot;nVarOne = %d \\r\\n&quot;,-12);&#125; 3.1.1.2 减法减法运算对应于汇编指令 sub，也就是英文中的”subtraction”的缩写。我们知道，计算机只会做加法，但是可以通过补码转换，将减法转变为加法的形式来完成运算 我们先来浅浅学习一下将减法转变为加法的过程： 设有二进制数 Y ,其反码记为 Y（ 反 ），假定其二进制长度为8位，有： Y + Y（ 反 ）&#x3D; 1111 1111B Y + Y（ 反 ）+ 1 &#x3D; 0 （ 进位丢失 ） 根据以上公式从，可得： Y（ 反 ） + 1 &#x3D; 0 - Y Y（ 反 ） + 1 &#x3D; - Y Y（ 补 ） &#x3D; - Y 这就是为什么负数的补码可以简化为取反加 1 的原因 比如，7 - 4 可以转换成： 7 +（ 0 - 4 ）~ 7 +（ 4（ 反 ）+ 1 ）~ 7 + 4（ 补 ） 有了这个特性，所有的减法运算就都可以转换成加法运算了 而减法运算的工作方式与加法运算的基本一致，就不赘述了 3.1.1.3 乘法乘法运算对应的汇编指令有两种： 有符号 imul 无符号 mul 由于乘法指令的执行周期较长，在编译过程中，编译器会先尝试将乘法转换为加法，或者使用移位等周期较短的指令，如果它们都不可以转换的时候，才会使用乘法指令。 我们可以继续用Debug编译选项组来对比C++源码和对应的汇编代码 ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image.png) ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image-1.png) 我们可以看到，有符号数乘以常量值，且这个常量非2的幂，会直接使用有符号乘法 imul 指令。而当常量值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令。当常值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令。 这是因为，任何十进制数都可以转换成二进制数来表示，在二进制数中乘以2就等同于所有位依次向左移动1 位。如十进制数3的二进制数为 0011，3乘以 2 后等于 6，6 转换成二进制数为 0110。 而当乘数和被乘数同时都是未知变量时，则无法套用优化方案。这时编译器不会优化处理，将直接使用乘法指令完成乘法计算。 我们发现，两常量相乘时，会先在编译期间计算出相乘的结果，再将表达式转换为常量值 在上例中，乘法运算与加法运算的结合运算，编译器采用 LEA 指令来处理。在代码中，lea 语句 的目的并不是取地址。如果这种组合运算中的乘数不等于 2、4、8 的时候，组合运算会有些许不同 ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image-4.png) 我们可以看到，编译器会直接先拆分，然后再进行运算 而两变量相乘的时候，会直接使用有符号乘法指令 再者，无符号数乘法的原理与之相同，我们可以自己思考一下 3.1.1.4 除法除法计算约定除法运算对应的汇编指令分有符号 idiv 和无符号 div 两种。除法指令的执行周期较长，效率也较低，所以编译器想尽办法用其他运算指令代替除法指令。C++ 中的除法和数学中的除法不同。在 C++ 中，除法运算不保留余数，有专门求取余数的运算 ( 运算符为 % )，也称之为取模运算。对于整数除法，C++ 的规则是仅仅保留整数部分，小数部分完全舍弃。 我们先讨论一下除法计算的相关约定。以下讨论的除法是”计算机整数除法”，我们使用 C 语言中的 a&#x2F;b 表示除法关系。在 C 语言中，两个无符号整数相除，结果依然是无符号的;两个有符号整数相除，结果则是有符号的;如果有符号数和无符号数混除，其结果则是无符号的，有符号数的最高位 ( 符号位 ) 被作为数据位对待,然后作为无符号数参与计算。 对于除法而言，计算机面临着如何处理小数部分的问题。在数学意义上，7&#x2F;2&#x3D; 3.5，而对于计算机而言，整数除法的结果必须为整数。对于3.5这样的数值，计算机取整数部分的方式不止一种，下面来介绍三种取整方式： 向下取整： 所谓对 x 向下取整，就是往 -∞ 方向也就是往小的方向，取最接近 x 的整数值，换言之也就是取得不大于 x 的最大整数，例如，+3.5 向下取整得到3，-3.5向下取整得到-4。在数学描述中，⌊ x ⌋ 表示的就是对 x 向下取整。在标准 C 语言的 math.h 中，定义了 floor 函数，其作用就是向下取整，也有人称之为**”地板取整”**。向下取整的除法，当除数为 2 的幂时，可以直接用带符号右移指令( sar ) 来完成。但是，向下取整存在一个问题：那就是 ⌊ - a &#x2F; b ⌋ ≠ - ⌊ a &#x2F; b ⌋，比如说 ⌊ -1 &#x2F; 2 ⌋ 是 -1，而 -⌊ 1 &#x2F; 2 ⌋ 却是 0（假设 a &#x2F; b 不为整数） 向上取整 所谓对 x 向上取整，就是往 +∞ 方向也就是往大的方向，取最接近 x 的整数值，换言之也就是取得不小于 x 的最小整数。例如，+3.5 向上取整得到 4 ，-3.5 向上取整得到 -3。在数学描述中，⌈ x ⌉ 表示对x 向上取整。在标准 C 语言的 math.h 中有定义 ceil 函数，其作用就是向上取整，也有人称之为**”天花板取整”**。向上取整也存在一个问题：也是 ⌈ - a &#x2F; b ⌉ ≠ - ⌈ a &#x2F; b ⌉，比如 ⌈ -1 &#x2F; 2 ⌉ 是 0，而 -⌈ 1 &#x2F; 2 ⌉ 却是 -1（假设 a &#x2F; b 不为整数） 向 0 取整 所谓对 x 向零取整，就是往 0 方向，取最接近 x 的整数值，换而言之也就是放弃小数部分。举例说明，+3.5 向零取整得到 3，-3.5 向零取整得到 -3。在数学描述中，[ x ] 表示对 x向零取整。在C语言和其他多数高级语言中，对整数除法规定为向零取整。也有人称这种取整方法为**”截断除法”** 对整数除法的优化如果除数是变量，则只能使用除法指令（这和两变量相乘很相似）如果除数为常量，就有了优化的余地，根据除数值的相关特性，编译器有对应的处理方式 除数为 2 的幂我们知道，在乘法里，如果常值为 2 的幂时，编译器会采用执行周期短的左移运算来代替执行周期长的乘法指令，那么在除法运算里也是类似的：在C语言中，有符号除法的除法规则是向 0 取整，对有符号数做右移运算，编译后使用的指令为 sar，相当于向下取整 比如说，4 &#x2F; 2 等价于 4 &gt;&gt; 1，结果就是 2（ ‘ &gt;&gt; ‘ 的意思是右移，比如说 4 的二进制码是 0100，右移就是 0010，也就是 2 了）如果是 5 &#x2F; 2 ，也就是 5 &gt;&gt; 1，结果还是 2（ 5 的二进制码是 0101，右移就是 0010，也就是 2 ）这也是我们在 C 语言中整型用除法时取整的原理 除数为非 2 的幂由于除法指令的周期比乘法指令周期长很多，因此编译器会用周期较短的乘法和其他指令代替除法。我们来看看数学证明 设 x 为被除数变量，o 为某一常量，则有: x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) 由于 o 为常量，且 2n 的取值由编译器选择，所以 ( 2n &#x2F; o ) 的值在编译期间可以计算出来，一般来说，n 的取值都大于等于32， 这样就可以直接调整使用乘法结果的高位，也就是说 ( 2n &#x2F; o ) 是一个编译期间先行计算的常量值，这个值通常被称为 Magic Number 我们用 M 代表 ( 2n &#x2F; o )，那么就有 x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; ( x * M ) * ( 1 &#x2F; 2n ) 我们再用 K 代表 ( x * M )，那么就有 K * ( 1 &#x2F; 2n ) &#x3D; K &#x2F; 2n 这样除数不就变成了 2 的幂了吗，就是 K &gt;&gt; n 然而除法运算还有更加深奥的方面没有研究，比如 ( 2n &#x2F; o ) 的 n 次方的大小问题，这里就先不深究了 除数为负的 2 的幂有了先前学习的基础，我们知道 sar 是右移指令，其实，除数为负的 2 的幂的除法和除数为 2 的幂的除法很相似，如果我们用 Release 编译选项组查看汇编代码，发现里面多了一个 neg 指令，其实这个 neg 指令相当于取负，其他的和除数为 2 的幂的除法基本一致 除数为负的非 2 的幂我们知道，在除数为非 2 的幂的除法中，x &#x2F; o &#x3D; x * ( 1 &#x2F; o ) &#x3D; x * ( 2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; x * M * ( 1 &#x2F; 2n ) 那么在除数为负的非 2 的幂的除法中，就是 x &#x2F; ( -o ) &#x3D; x * ( -1 &#x2F; o ) &#x3D; x * ( -2n &#x2F; o ) * ( 1 &#x2F; 2n ) &#x3D; x * ( -M ) * ( 1 &#x2F; 2n )，我们来研究一下这个 -M : -M &#x3D; - ( 2n &#x2F; o ) &#x3D; ( 2n &#x2F; o ) ( 求补 ) 而更深奥的方面我们在这就不研究了 除法优化的原则其实，我们通过还原所得的数都是近似值，这说明给出的公式不够严格，我们要在稍稍深度学习除法运算再来探索这方面的原理 我们可以先不管如何证明的，先看一下为什么还原的除数近似而不等的原因：我们的 Magic Number 是整数值，而 ( 2n &#x2F; o ) 是实数值，所以我们要找到 Magic Number 表达式中 2n 的值才行 3.1.2 算术结果溢出其实我们在之前已经接触过算术结果溢出的相关知识，比如 int 类型的数据如果经过计算后超出了 int 类型的存储范围，超出的部分也就是溢出数据，将无法被保存。又比如说一个负数，溢出后由于表示符号的最高位被进位了，原来符号位上的 1 变成了 0，这是负数也就变成了正数。 不过，我们需要知道，溢出的部分丢失后不是说它就是最大的数了，而是变成了一个很小的数，所以，有一些循环看似死循环，其实有可能并不是死循环，我们来看一下下面的例子： 1234for(int i = 1 ; i &gt; 0 ; i++)&#123; std::cout &lt;&lt; i;&#125; 上面的 for 循环看上去是一一个死循环，但由于 i 是一个有符号数，当 i 等于它允许取得的最大正数值0x7FFFFFF 时，再次加 1 后，数值会产生进位，将符号位 0 修改为 1，最终结果为 0x80000000，这时的最高位为 1,按照有符号数进行解释，这便是一个负数，对于 for 循环而言，当循环条件为假时，则会跳出循环体，结束循环。 溢出是由于数据进位后超出数据的保存范围导致的。溢出和进位都表示数据超出了存储范围，它们之间又有什么区别呢? 进位： 无符号数超出存储范围叫做进位。因为没有符号位，所以不会破坏数据，而多出的1位数据会被进位标志位 CF 保存，数据产生了进位，只是进位后的 1 位数据 1 不在自身的存储空间中，而在标志位 CF 中，可通过查看进位标志位 CF，检查数据是否进位。 溢出： 有符号数超出存储范围叫做溢出，由于数据进位，从而破坏了有符号数的最高位一符号位，因为只有有符号数才有符号位，所以溢出只针对有符号数。可查看溢出标志位 OF，检查数据是否溢出。OF 的判定规则很简单，如果参与加法计算的数值符号一致，而计算结果符号不同，则判定 OF 成立，其他都不成立。 3.1.3 自增与自减我们知道，C&#x2F;C++ 中分别用 ‘ ++ ‘，’ - - ‘ 来表示自增和自减。而自增和自减有两种： 先递增(减)：先执行自增(减)，然后再执行语句块 后递增(减)：先执行语句块，然后再执行自增(减) 下面我们要研究的是在汇编语言中自增和自减是怎么执行的 ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image-6.png) ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image-5.png) 通过上面的汇编我们可以清晰的知道自增和自减是如何运作的： 先递增是将原语句块”number_two &#x3D; 5 + (++number_one);”分解为”number_one +&#x3D; 1 ;”和”number_two&#x3D; 5 +number_one;”，这样就实现了先自增 1，再参与语句块运算。同理，后递增的拆分过程只是执行顺序做了替换，先参与表达式运算，再将自身加 1。在识别过程中，后递增必然会保存计算前的变量值，在表达式计算完成后，才取出之前的值加 1，这是个显著特点。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"}],"tags":[]},{"title":"2.3main函数的识别","slug":"2.3 main函数的识别","date":"2023-10-31T09:26:14.000Z","updated":"2023-10-31T09:25:51.356Z","comments":true,"path":"2023/10/31/2.3 main函数的识别/","link":"","permalink":"http://example.com/2023/10/31/2.3%20main%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%86%E5%88%AB/","excerpt":"","text":"2.3 main函数的识别通过上节的学习，我们知道了调用main函数之前，必须先要得到三个必要的参数，而这三个参数的获取我们应该已经了解了，那么我们来看看怎么识别main函数： 首先，main函数被调用前要先调用下面的函数： GetVersion() heap init() GetCommandLineA0 _crtGetEnvironmentStringsA() _setargv() _setenvp() _cinit() 这些函数被调用之后，就会开始调用main函数。根据main函数被调用的特性，会将三个参数压入栈中作为函数的参数，那么我们只要知道以上函数到哪里截止就好了 2.3.1 OllyDBGOllyDBG在加载程序时直接暂停在应用程序的人口处，而不会直接定位到main函数处，需要分析者手动查找定位，我们可以通过main函数的特性查找到所在的位置 识别出GetCommandLineA()函数后，对应前面讨论的main函数特性继续寻找。为了准确识别main函数，可以观察传递参数的个数，如果具有3个参数，便是main函数的调用，双击即可进入main函数的实现中 2.3.2 IDAIDA下的main函数识别更为简便，它会直接分析出main函数所在的位置并显示出来（虽然有的程序放在IDA中是显示没有main函数的）那么，如何使用IDA分析启动函数mainCRTStartup呢？只要在函数窗口(左栏)中找到mainCRTStartup所在的位置，双击便可进入函数实现中 ![](C:\\Users\\zero to hero\\Desktop\\BLOG\\source\\image-46-1024x549.png)","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"2.2了解启动程序","slug":"2.2 了解启动程序","date":"2023-10-31T09:25:33.000Z","updated":"2023-10-31T09:25:17.306Z","comments":true,"path":"2023/10/31/2.2 了解启动程序/","link":"","permalink":"http://example.com/2023/10/31/2.2%20%E4%BA%86%E8%A7%A3%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"2.2 了解启动程序> 需要注意的是，本篇将以VC++ 6.0作为示例，而其他C++的编译器与其差异不大，我们可以用自己的编译器实际操作一下 VC++ 6.0在控制台和多字节编码环境下的启动函数为mainCRTStartup，由系统库KERNEL32.dll负责调用。在mainCRTStartup中再调用main函数。使用VC++ 6.0进行调试时，入口断点总是停留在main函数的首地址处。如何挖掘main函数之前的代码呢？我们可以利用VC++ 6.0的栈回溯功能。在调试环境下，依次选择菜单View→Debug Windows→Call Stack打开出栈窗口(快捷键: Alt+7) 通过实践，我们可以知道，程序运行时调用了三个函数，依次是KERNEL32、mainCRTStartup 和main。其中显示的”KERNEL32 ! 7c817077” 表示在系统库KERNEL32.d11中的地址7c817077处调用mainCRTStartup,我们无法查看KERNEL32.dIl的高级源码，而VC++则提供了mainCRTStartup函数的源码，安装完整版VC++就可以查看。双击CallStack窗口中的mainCRTStartup函数，查看函数的内部实现 接下来，我们需要了解一些启动函数的工作流程： GetVersion函数：获取当前运行平台的版本号。控制台程序运行在Windows模拟的DOS下，因此这里获取的版本号为MS-DOS的版本信息。 _ heap_ init 函数：用于初始化堆空间。在函数实现中使用HeapCreate申请堆空间，申请空间的大小由_ heap_ init 传递的参数决定。_ sbh heap init 函数用于初始化堆结构信息。堆结构的说明将在第7章详细讲解。 GetCommandLineA函数：获取命令行参数信息的首地址。 _ crtGetEnvironmentStringsA 函数：获取环境变量信息的首地址。 _ setargv函数：此函数根据GetCommandLineA获取命令行参数信息的首地址并进行 参数分析，将分离出的参数的个数保存在全局变量**_argc** 中，将分析出的每个命令行 参数的首地址存放在数组中，并将这个字符指针数组的首地址保存在全局变量**argv **中。这样就得到了命令行参数的个数，以及命令行参数信息。 setenvp 函数：此函数根据_ _crtGetEnvironmentStringsA 函数获取环境变量信息的首地址并进行分析，将得到的每条环境变量字符串的首地址存放在字符指针数组中，并将这个数组的首地址存放在全局变量env中。 这就会得到main函数所需要的三个参数，所以当调用main函数的时候，便将**argc**** ，**_argv ，_env 这三个全局变量作为参数，以栈传参的方式传递到main函数中 接下来我们还要认识一个函数： _cinit 函数：用于全局数据和浮点寄存器的初始化。全局对象和IO流的初始化都是通过这个函数实现的。利用函数_initterm进行数据链初始化，这个函数由两个参数组成，类型为”_PVFV*”，这是一个函数指针数组，其中保留了每个初始化函数的地 址。初始化函数的类型为 PVFV, 其定义原型如下: typedef void ( cdecl *_PVFV) (void) ; 也就是说，这个初始化函数是无参数也无返回值的。大家知道，C++ 规定全局对象和静态对象必须在main函数前构造，在main函数返回后析构。所以，这里的_PVFV函数指针数组就是用来代理调用构造函数的 那么，是不是所有由VC++编译出的控制台程序的启动函数都在mainCRTStartup中呢？这要根据编译选项确定。在默认情况下，人口函数为main，这时会从mainCRTStartup启动，再传入main所需要的三个参数，最后调用main函数。重新指定入口函数后，将直接从KERNEL32中调用重新指定的入口函数，而不会经过mainCRTStartup。通过修改编译选项，重新设置入口函数，依次选择菜Procject→Settings→Link→Output,在Enty-pointsymbol中填写需要重新指定新入口的函数名称 但是，如果没有经过mainCRTStartup，而直接调用的新的入口函数，所以堆空间是没有被初始化的，这么做的话，在使用到堆空间的时候，程序会报错并且崩溃","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"2.1程序的真正入口","slug":"2.1 程序的真正入口","date":"2023-10-31T09:17:07.000Z","updated":"2023-10-31T09:32:19.555Z","comments":true,"path":"2023/10/31/2.1 程序的真正入口/","link":"","permalink":"http://example.com/2023/10/31/2.1%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%85%A5%E5%8F%A3/","excerpt":"","text":"2.1 程序的真正入口VC++开发的程序，在调试时总是从main或WinMain函数开始，这就让我们误认为它们是程序的第一条指令执行的地方，这个认识其实是不对的。 其实呢，main 或WinMain也是一个函数，也需要有一个调用者。在它们被调用前，编译器其实已经做了很多事情，所以我们熟悉的main或WinMain应该是”语法规定的用户入口”，而不是”应用程序入口”。在应用程序被操作系统加载的时候，操作系统会分析执行文件内的数据，并且将相关资源都分配出去，再读取执行文件中的代码和数据到合适的内存单元，然后才是执行入口代码，入口代码其实并不是我们熟悉的main或WinMain,通常是mainCRTStartup、wmainCRTStartup、 WinMainCRTStartup 或wWinMainCRTStartup，具体视编译选项而定。 其中，mainCRTStarup和wmainCRTStartup是控制台环境下多字节编码和Unicode编码的启动函数，而WinMainCRTStartup和wWinMainCRTStartup则是Windows环境下多字节编码和Unicode编码的启动函数。在开发过程中，VC++也允许程序员自己指定人口。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"}],"tags":[]},{"title":"1.6常量","slug":"1.6 常量","date":"2023-10-31T09:11:33.000Z","updated":"2023-10-31T09:31:48.532Z","comments":true,"path":"2023/10/31/1.6 常量/","link":"","permalink":"http://example.com/2023/10/31/1.6%20%E5%B8%B8%E9%87%8F/","excerpt":"","text":"1.6 常量常量和变量不同，变量可以随时改变，在程序运行中可以修改其保存的值；而常量呢，顾名思义，就是一个恒定不变的值，它在内存中也是不可修改的。比如说在程序中见到1、2、3这样的数字，或者是”Hello”这样的字符串，还有数组名称等等，这些都属于常量。程序在运行中是不可以修改它们的数据的 而常量是在程序运行前就已经存在了的，它们被编译到可执行文件中。当程序启动后，它们便会被加载进来。这些数据通常都会在常量数据库中保存，这个区域的属性中是没有可写权限的，所以当你试图对常量进行修改的时候，程序都会报错，引发异常，严重时将会导致程序崩溃 常量数据的地址减去基地址，便是它们的偏移地址 1.6.1 常量的定义在C++中，有两种方式定义常量： 可以用宏机制#define来定义常量 也可以用const将变量定义为一个常量 #define定义的常量名称，编译器对其进行编译时，会将代码中的宏名称替换成对应的信息，宏的使用可以增加代码的可读性 比如我们宏定义了一个常量number_one，并定义其的值为99，所以程序将其输出时，输出得到的结果就是99。而const是为了增加程序的健壮性而存在的 ![](&#x2F;images&#x2F;1.6 常量&#x2F;image-31.png) 这里我们将宏定义的常量number_one的值，也就是99，赋值给了const常量number_two，所以最后输出得到的结果也是99 1.6.2 #define 与 const 的区别#define是一个真常量，而const却是由编译器判断实现的常量，是一个伪常量。实际中，使用const定义的变量，最终还是一个变量，只是在编译器内进行了检查，发现有修改则报错 由于编译器在编译期间对const进行检查，因此被const修饰过的变量是可以被修改的。利用指针获取到const修饰过的变量地址，强制将指针的const修饰去掉，就可以修改对应的数据内容 1.6.3 关于这两者在连接生成可执行文件后将不复存在，在二进制编码中也没有这两种类型存在，在实际分析中，我们需要根据自身的经验进行分析还原","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"1.5地址","slug":"1.5 地址、指针和引用","date":"2023-10-31T09:09:46.000Z","updated":"2023-10-31T09:23:36.788Z","comments":true,"path":"2023/10/31/1.5 地址、指针和引用/","link":"","permalink":"http://example.com/2023/10/31/1.5%20%E5%9C%B0%E5%9D%80%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/","excerpt":"","text":"1.5 地址、指针和引用首先我们先来初步了解一下什么时是地址和指针，还有引用 地址：在C++中，地址标号用十六进制表示，如果我们想取一个变量的地址，那么就需要用到”&amp;”符号。但我们需要知道，只有变量才有地址，而常量是没有地址的（当然，我们不将const定义的伪常量包括在内），例如数字100，我们是无法取出它的地址的。取出的地址是一个常量值，我们就无法再对其取地址了。 指针：指针的定义使用”TYPE“,TYPE指的是数据类型，比如说 int，char*……所以任何数据类型都可以定义指针。实际上，指针本身就是一种数据类型，它用来保存各种数据类型在内存中的地址。因为指针本身就是变量，所以是可以对指针变量取地址的，所以会出现多级指针 引用：**引用的定义用”TYPE&amp;”**，TYPE指得是数据类型。在C++中是不可以单独定义的，并且在定义的时候就要进行初始化。引用表示一个变量的别名，对它的任何操作，本质上都是在操作它所表示的变量 1.5.1 地址和指针的区别指针可以通过指针类型对其地址对应的数据进行解释，而一个地址值无法单独解释数据 由于指针保存的数据都是地址，所以无论什么类型的指针在内存中都占用4个字节 下表是指针与变量不同点： 指针地址本身是变量，用于保存变量地址本身是常量，内存标号可修改，再次保存其他变量的地址不可修改可对其执行取地址操作得到地址不可对其执行取地址操作包含对保存的地址的解释信息一个地址值无法单独解释数据**指针与地址之间的不同点** 下表是指针与变量共同点： 指针地址可以取出指向地址内存中的数据可以取出地址对应内存中的数据可以对地址偏移后，再取数据可以偏移后取数据，自身不变可以求两个地址的差可以求两个地址的差 ## 1.5.2 各类型指针的工作方式 在C++中，任何数据类型都有对应的指针类型。从前面的学习中了解到，指针中保存的都是地址，为什么还需要类型作为修饰呢?因为需要用类型去解释这个地址中的数据。每种数据类型在内存中所占的内存空间不同，指针中只保存了存放数据的首地址，而没有指明该在哪里结束。这时就需要根据对应的类型来寻找解释数据的结束地址。例如，同一地址，使用不同类型指针进行访问，取出的内容就会不一样 指针的取内容操作分为两个步骤：先取出指针中保存的地址信息，然后针对这个地址进行取内容，也就是一个间接寻址的过程，这也是识别指针的重要依据 我们需要知道：所有类型的指针对地址的解释都取自于自身指针类型 那么指针支持哪些运算符号呢？在C++中，所有指针类型只支持加减法。指针是永远保存数据的地址、解释地址而存在的。因此，只有加减法才是有意义的，而乘除法是没有意义的 指针的加减法用于地址偏移，但指针的加减法并不像数学中的加减法那样简单。比如说，指针加1后，指针内保存的地址值并不一定会加1，具体的值取决于指针类型，若指针类型为int，指针加1后地址值将会加4。这个4是根据数据类型大小所得到的值。所以说用数据类型去修饰指针是很重要的。 但是，为什么C++要用这种繁琐的地址偏移方法呢，为什么不让加1就是加1呢？这是因为指针中保存的地址为数据的首地址，如果数据类型为数组，为了能够利用指针加1后直接访问到数组内下一成员，所以加的是类型长度，而非数字1 两指针做减法操作，是在计算两个地址之间的元素个数，结果为有符号整数，进行减法操作的两指针必须是同类指针 指针的减法可用于其中地址的比较，也可用于其他场合，比如求数组元素的个数（用两指针相减得到地址的差除以数据类型的大小即可得到数组元素的个数） 另外，两指针相加也是没有意义的 当然，在能够灵活运用指针的同时，指针的运用也要谨慎，以免将指针指向意料之外的地址，错误地修改地址中的数据，造成程序的崩溃 1.5.3 引用引用类型在C++中被描述为变量的别名。实际上，C++为了简化指针操作，对指针操作进行了封装，这就产生了引用类型。其实呢，引用类型就是指针类型，只不过它用于存放地址的内存空间对使用者来说是隐藏的。 引用类型的存储方式和指针是一样的，都是使用内存空间存放地址值。所以在C++中，引用和指针没有区别，只是引用时通过编译器实现寻址，而指针需要手动寻址。指针虽然灵活，但操作失误将造成严重后果，而使用引用则不存在这种问题。因此，C++极力推荐使用引用类型 在汇编代码中，如果没有源码对战，指针和应用都一样难以区分。 不过值得庆幸的时，在反汇编中，没有引用 这种数据类型","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"1.4布尔类型","slug":"1.4 布尔类型","date":"2023-10-31T09:08:07.000Z","updated":"2023-10-31T09:23:31.588Z","comments":true,"path":"2023/10/31/1.4 布尔类型/","link":"","permalink":"http://example.com/2023/10/31/1.4%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"1.4 布尔类型1.4.1 布尔类型的介绍布尔类型很简单，只有 0 与 非0 两种情况，在C++中，0 则表示为假，非0 则表示为真，并且是用bool定义布尔类型变量。布尔类型变量在内存中占一个字节，无论输入给布尔类型变量怎么样的数，只要非0就解释为1，即真，只要是0，就解释为0，即假。 现在我们知道，布尔类型的出现都是用来判断的，所以，它只是一个比较方便的工具，但实际上，任何类型都可以代替它的作用，比如说整型，浮点数，甚至是字符串或者位。 布尔类型的输出值只有1和0（即真和假）两种，所以布尔类型很好理解和学习，但布尔类型非常的重要，在代码中如果遇到布尔类型的运用，我们要能够将其转变为我们能理解的等价代码与解释。 例如下面的代码： 12345678910111213141516171819#include&lt;iostream&gt;int main()&#123; //我们可以用布尔类型来判断用户输入的数是否是零 using namespace std; bool judgment; int num; cout &lt;&lt; &quot;Please input num&quot;; cin &gt;&gt; num; judgment = num; if (!judgment) &#123; cout &lt;&lt; &quot;This is zero!&quot;; &#125; else &#123; cout &lt;&lt; &quot;This is not zero!&quot;; &#125;&#125; 当然我们一般不这么判断，我们知道，直接将if 语句的条件句改为 num &#x3D;&#x3D; 0 就好了，还不用定义布尔类型的judgment。实际上确实如此，但是其实 num &#x3D;&#x3D; 0 这一句就是 ！judgment 的等价代码，而前者更容易被人理解，而后者看似简短但需要仔细琢磨一下。 虽然我们自己写代码的时候可以用最好理解的方式写代码，但是其他方式写出来的我们也能看懂才行❤","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"1.3字符和字符串","slug":"1.3 字符和字符串","date":"2023-10-31T09:07:23.000Z","updated":"2023-10-31T09:23:25.310Z","comments":true,"path":"2023/10/31/1.3 字符和字符串/","link":"","permalink":"http://example.com/2023/10/31/1.3%20%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"1.3 字符和字符串字符串是由一个个字符组成的，而每个字符在字符表中又各自对应着一个唯一的编号。系统通过这些编号在表中查找这些字符，并把它们显示出来。其实，字符表格中的编号就是字符的编码格式。 1.3.1字符的编码在C++中，字符的编码格式有两种，分别是ASCII和Unicode 其中，Unicode是ASCII码的升级版，它弥补了ASCII的不足，在《C++反汇编与逆向分析技术揭秘》中说到，Unicode也是未来编码格式的趋势。 1.3.1.1 ASCII在C++中，ASCII编码在内存中占用一个字节，每个编号表示一个字符，它的表示范围为0~255。而且，ASCII码是可以和整型相互转换的，但是要注意不能超过ASCII码所能表示的最大范围，因为多余的部分将会被舍弃。 一般的，使用char定义ASCII编码格式的字符，如字符’a’可以转换为十六进制的0x61，或者是十进制的97 更多的ASCII码可以搜索ASCII表进行对照 ![ASCII字符代码表](&#x2F;images&#x2F;1.3 字符和字符串&#x2F;image-23.png) 1.3.1.2 Unicode由于ASCII所能表示的范围太小，只能表示26个英文字母的大小写和一些常用字符，不同于ASCII，Unicode是占用两个字节的，它的表示范围为0～65535，当然，ASCII也包含在其中 一般的，用wchar_t定义Unicode编码格式的字符。像是字符’a’，我们知道用ASCII码表示是0x61，而用Unicode保存ASCII码的话是0x0061，这是因为ASCII是占用一个字节的，Unicode是占用两个字节的，所以不足的位就用0来补。 1.3.1.3 汉字的编码ASCII编码和Unicode编码都可以存储汉字，但是它们对汉字的编码方式各不相同，所以存储同样的汉字，它们在内存中的编码是不相同 ASCII两个字节解释一个汉字。在汉字国标码中用区和位来定位，第一个字节保存每个区，共94个区；第二个字节保存每个区中的位，共94位 Unicode使用USC-2编码格式，最多可以存储65535个字符，每个数字编号在表中对应一个汉字，但汉字博大精深，65535个肯定不够用，所以USC-2编码格式中只保存了常用字。而为了将更多的汉字都能表示出来，Unicode采用了和ASCII类似的方法，就是用两个Unicode编码解释一个汉字，称之为USC-4编码格式 1.3.2 字符串的存储方式字符串是由一系列按照一定的编码顺序线性排列的字符组成的。在图形中，两点可以确定一条直线，那么在程序中，只要知道字符串的首地址和结束地址就可以确定字符串的长度和大小。字符串的首地址很容易确定，因为在定义字符串的时候都会先指定好首地址。结束地址如何确定呢?有两种做法，一种是在首地址的4字节中保存字符串的总长度;另一种是在字符串的结尾处使用一个规定好的特殊字符，即结束符。为了更好的理解，我们可以看一下下面的距离： 保存总长度法： 我们知道了这串字符串的首地址，如果我们又知道了这串字符串多长，那么是不是就可以知道这段字符串是到哪里停止了，比如说下面这么一串字符中，如果字符串的第一个字符是4，长度是7，那么我们就可以知道这个字符串就是4567890 “1 2 3 4 5 6 7 8 9 0” 保存结束符法： 我们知道了这串字符串的首地址，如果我们又知道了这串字符串是以什么为结束符的，那么是不是就可以知道这段字符串是到什么了，比如说下面这么一串字符中，如果字符串的第一个字符是2，以’\\0’为结束符，那么我们就可以知道这个字符串就是234 “1 2 3 4 \\0 5 6 7 8 9 0” 当然，这两种方法都有各自的优缺点： 保存总长度： **优点:**获取字符串长度时，不用遍历字符串中的每个字符，取得首地址的前n字节就可以得到字符串的长度。(n 的取值一般是1、2、4)**缺点:**字符串长度不能超过n字节的表示范围，且要多开销n字节空间保存长度。如果涉及通信，双方交互前必须事先知道通信字符串的长度。 保存结束符： **优点:**没有记录长度的开销:另外，如果涉及通信，通信字符串可以根据实际情况随时结束，结束时附上结束符即可。**缺点:**获取字符串长度需要遍历所有字符，寻找特殊结尾字符，在某些情况下处理效率低。 C++使用结束符’\\0’作为字符串结束标志。ASCII 编码使用一个字节’\\0’, Unicode 编码使用两个字节’\\0’。需要注意的是，不能使用处理ASCII编码的函数对Unicode编码进行处理，因为如果Unicode编码中出现了只占用一字节的字符,就会发生解释错误 在程序中，都会使用一个存放地址的变量来存放字符串中第一个字符的地址，以便查找使用字符串。比如说使用字符型指针char* ，wchar_t* 都来保存字符串首地址。**所以我们要学好C&#x2F;C++语言** &#x2F;哭 1.3.3 字符串的识别字符串的识别也相对简单，同样是结合上下文，查看调用地址处对该地址的处理过程 在通常情况下，OllyDBG 与IDA都会自动识别出程序中的字符串 在使用IDA的过程中，有时会无法识别字符串，可手动修改 ![](&#x2F;images&#x2F;1.3 字符和字符串&#x2F;image-25.png) 这段数据明显为一个字符串，但是IDA并没有分析出来，这时可以选中将要分析的字符串的首地址，使用快捷键A，便可将从分析地址处到’\\0’解释为字符串。下图为识别后的字符串数据。如果想将已识别的变回未识别的状态，可以选中字符串的地址，使用快捷键D就好了 ![](&#x2F;images&#x2F;1.3 字符和字符串&#x2F;image-26.png)","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"1.2浮点数","slug":"1.2 浮点数","date":"2023-10-31T09:06:53.000Z","updated":"2023-10-31T09:23:19.121Z","comments":true,"path":"2023/10/31/1.2 浮点数/","link":"","permalink":"http://example.com/2023/10/31/1.2%20%E6%B5%AE%E7%82%B9%E6%95%B0/","excerpt":"","text":"实数数据不可能都是整数，那么就会出现怎么输出小数的问题。在计算机的发展历程中，出现过许多中存储实数的方式，有的现在很少用了不管如何存储，我们都可以划分为定点实数存储方式和浮点实数存储方式这两种。 所谓定点实数，就是约定整数位和小数位的长度。这样的好处是计算的效率高，缺点也显而易见，因为整数部分和小数部分的位数都被固定了，所以存储不灵活。 对应的也有浮点实数的存储方式，简单的理解就是小数点可以移动，是浮动的，不是固定的，这就灵活多了。但这相较于定点实数来说，效率就低得多了。现在主流的实数存储方式就是浮点实数存储方式。但是，在一些条件恶劣的嵌入式开发场合，仍可看到定点实数的存储和使用。 1.2.1 浮点数类型在C&#x2F;C++中，使用浮点方式存储实数，用两种数据类型来保存浮点数: float (单精度)、double (双精度)。float 在内存中占4字节空间，double 在内存中占用8字节空间。由于占用空间大，double可描述的精度更高。这两种数据类型在内存中同样以十六进制方式进行存储，但与整型类型有所不同。整型类型是将十进制转换成二进制保存在内存中，以十六进制方式显示。浮点类型并不是将一个浮点小数直接转换成二进制数保存，而是将浮点小数转换成的二进制码重新编码，再进行存储。C&#x2F;C++的浮点数是有符号的。 注意：在C&#x2F;C++中，将浮点数强制转换为整数时，不会采用数学上四舍五人的方式，而是舍弃掉小数部分，不会进位。下面以C语言为例； 12345678910#include&lt;stdio.h&gt;main()&#123; int num = 127; int a ; float b ; a = num / 10 ; b = (float)num / 10 ; printf(&quot;a=%d,b=%f&quot;,a,b);&#125; 该段代码最后会输出 a&#x3D;12，b&#x3D;12.700000，我们发现 a 的值是12，而不是13，说明并不是四舍五入的原理。所以这就是浮点数强制转换为整数时，直接将小数点后面的全部舍去 另外，我们还需要知道，在使用浮点数之前需要先对浮点寄存器进行初始化，然后才能正常运行，若像下面代码一样则会使程序崩溃 12345678#include&lt;stdio.h&gt;main()&#123; //在未使用到浮点数情况下， //程序输入小数会报错，这是因为没有对浮点寄存器进行初始化 int n = 0; scanf (&quot;%f&quot;，&amp;n) ;&#125; 解决办法是：在使用该浮点数之前定义一个浮点类型的变量即可对浮点寄存器进行初始化 1.2.2 浮点数的编码方式浮点数編码转换采用的是IEEE规定的编码标准，float和double这两种类型数据的转换原理相同，但由于表示的范围不一样，编码方式有些许区别。IEEE 规定的浮点数编码会将一个浮点数转换为二进制数。以科学记数法划分，将浮点数拆分为3部分:符号、指数、尾数。. 1.2.2.1 float类型的IEEE编码float类型在内存中占4字节(32 位)，最高位用于表示符号，在剩余的31位中，从右向左取8位用于表示指数，其余用于表示尾数，如下图所示 ![浮点数的二进制表示说明](&#x2F;images&#x2F;1.2 浮点数&#x2F;image-20231031171241838.png) 1.2.2.2 double类型的IEEE编码double类型表示的范围更大，精准度也更高，当然占用的空间更多，是float类型所占用空间的两倍。 double类型在内存中占8字节（64位），与float一样的是，最高位也是用于表示符号；不同的是，指数位占11位，剩余的52位用于表示尾数。 而且double类型的IEEE编码转换方式与float类型，除了判断指数符号上有一点点区别之外，其余的都是基本一样的。 1.2.3 基本的浮点数指令之前有讲到，浮点数操作是通过浮点寄存器来实现的，而普通数据类型使用的是通用寄存器，它们分别使用两套不同的指令。 首先，我们要先了解一下什么是栈 栈（我们先来初步了解一下） 栈，存储货物或供旅客住宿的地方，可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。栈是限制插入和删除只能在一个位置上进行的线性表。关于栈的稍详细内容请看另一篇文章：初步了解栈❤ 浮点寄存器是通过栈结构来实现的，由ST(0)~ ST(7)共8个栈空间组成，每个浮点寄存器占8字节。每次使用浮点寄存器都是率先使用ST(0)，而不能越过ST(0)直接使用ST(1) （更不用说直接使用更里面的空间了）。浮点寄存器的使用就是压栈、出栈的过程。当ST(0)存在数据时，执行压栈操作后，ST(0)中的数据将装人ST(1)中，如无出栈操作，将顺序地向下压栈，直到将浮点寄存器占满。常用浮点数指令的介绍如表所示，其中，IN表示操作数入栈，OUT表示操作数出栈。 常用浮点数指令表 指令名称使用格式指令功能FLDFLD IN将浮点数IN压入ST(0)中。IN（mem 32/64/80）FILDFILD IN将整数IN压入ST(0)中。IN（mem 32/64/80）FLDZFLDZ将0.0压入ST(0)中FLD1FLD1将1.0压入ST(0)中FSTFST OUTST(0)中的数据以浮点形式存入OUT地址中。OUT(mem 32/64)FSTPFSTP OUT和FST指令一样，但会执行一次出栈操作FISTFIST OUTST(0)数据以整数形式存入OUT地址中。OUT(mem 32/64)FISTPFISTP OUT和FIST指令一样，但会执行一次出栈操作FCOMFCOM IN将IN地址数据与ST(0)进行实数比较，影响对应标记位FTSTFTST比较ST(0)是否为0.0，影响对应标记位FADDFADD IN将IN地址内的数据与ST(0)做加法运算，结果放入ST(0)中FADDPFADDP ST(N).ST将ST(N)中的数据与ST(0)中的数据做加法运算，N为0~7中任意一个，先执行一次出栈操作，然后将相加结果放入ST(0)中保存 其他运算指令和普通指令类似，只需在前面加F即可，如FSUB和FSUBP等。 在使用浮点指令时，都要先利用ST(0)进行运算。当ST(0)中有值时，便会将ST(0)中的数据顺序向下存放到ST(1)中，然后再将数据放入ST(0)中。如果再次操作ST(0)，则会先将ST(1)中的数据放入ST(2)中，然后将ST(0)中的数据放入ST(1)中，最后才将新的数据存放到ST(0)。以此类推，**在8个浮点寄存器都有值的情况下继续向ST(0)中存放数据,这时会丢弃ST(7)中数据信息**。 其实，float类型的浮点数虽然占4字节，但是都以8字节方式进行处理。当浮点数作为参数时，并不能直接压栈。PUSH指令只能传入4字节数据到栈中，这样就有4字节的数据丢失了。这就是为什么使用printf函数以整数形式输出浮点数时会产生错误的原因。printf以整数形式输出时，将对应参数作为4字节数据，按补码方式进行解释；而真正压入的参数时浮点类型时，数据长度其实是8字节，需要用浮点编码方式来解释。如果是将浮点数作为返回值也是一样的，需要传递8字节数据 我们可以自己尝试使用各指令，观察浮点指令的特点的同时，熟悉数据传输类型指令的使用","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"1.1整型","slug":"1.1 整型","date":"2023-10-31T09:06:27.000Z","updated":"2023-10-31T09:23:09.892Z","comments":true,"path":"2023/10/31/1.1 整型/","link":"","permalink":"http://example.com/2023/10/31/1.1%20%E6%95%B4%E5%9E%8B/","excerpt":"","text":"1.1 整型C++提供的整数数据类型有三种: int、long、 short 其中int类型、long类型在内存中占4个字节，short类型在内存中占2个字节；而一个字节可由两个十六进制数表示，一个十六进制数可由四个二进制数表示，每个二进制数表示一位，那么一个字节就在内存中占8位 在C++中，整数类型又可以分为有符号型与无符号型两种。有符号整数可用来表示负数，而无符号整数只能是正数，它们在数据的取值范围上也有区别 1.1.1 无符号整数在内存中，无符号整数的所有位都用来表示数值。以无符号整型数据unsigned int为例，而我们知道，此类型（int型）的变量在内存中占4字节，由8个十六进制数组成，那么其取值范围用十六进制表示就是0x00000000 ~ 0xFFFFFFFF,如果转换为十进制数，则表示范围就是0 ~ 4294967295。 需要注意的是，当无符号整型不足32位时，用0来填充剩余高位，直到占满4字节内存空间为止。例如，数字7对应的二进制数为111，只占了3位，按4字节大小保存，剩余29个高位将用0填充，填充后结果为: 00000000000000000000000000000101 ;转换成十六进制数就是0x00000005。这种存放方式称之为”小尾方式”，”小尾方式”存放是以字节为单位，按照数据类型长度，高数据位对高地址，低数据位对低地址。当然，也有”大尾方式”，它则与”小尾方式”相反。 我们知道，因为无符号整数并不存在正负之分，都是正数，所以无符号整数在内存中都是以真值的形式存放的，每一位都可以参与数据表达。无符号整数可表示的正数范围是补码的一倍。 1.1.2 有符号整数有符号整数中用来表示符号的是最高位一符号位。 最高位为0表示正数，最高位为1表示负数，有符号整数在内存中同样占4字节，但由于最高位为符号位，不能用来表示数值，因此有符号整数中用来表示符号的是最高位一符号位，即最高位为0表示正数，最高位为1表示负数。 有符号整数在内存中同样占4字节，但由于最高位为符号位，不能用来表示数值，因此有符号整数的取值范围要比无符号整数取值范围少1位，即0x80000000 ~ 0x7FFFFFFF，如果转换为十进制数，则其表示范围为-2 147 483 648 ~ 2 147 483 647。在有符号整数中，正数的表示区间为: 0x0000000 ~ 0x7FFFFFF ;负数的表示区间为:0x80000000 ~ 0xFFFFFFFF. 我们要知道，计算机是只会进行加法运算的，所以所有我们输入的减法运算，其实都要转换为加法运算，例如1 - 3 就会是 1 + ( - 3 )。 另外，我们还需要知道，负数在内存中都是以补码形式存放的，补码的规则是用0减去这个数的绝对值，也可以简单地表达为对这个数值取反加1。例如，对于-3，可以表达为0 - 3。为了计算方便，人们也常用取反加一的方式来求得补码。本章的最后会介绍这两种计算方法的原理。值得一提的是，对于4个字节的补码，0x80000000所表达的意义可以是负数0，也可以是0x80000001减去1。然而，对于0来说，它的正负值是相等的，没有必要还来个负数0，因此，也就把这个值的意义规定为0x00000001减去1,这样0x80000000也就成为4字节负数的最小值了。这也是为什么有符号整数的取值范围中，负数区间总是比正数区间多一个最小值的原因。 所以，我们可以通过查看数据表示为十六进制数时的最高位来判断该数据的正负，最高位小于8则为正数，大于8则为负数（另外，如果是负数，则需转换为真值，才能得到对应负数的数值） 对于1.1.2 有符号整数中补码的运算规则，有兴趣的可以继续看完。 我们已经知道，负数在内存中都是以补码形式存放的，我们可以用0减去这个数的绝对值，也可以表达为对这个数值取反加1。例如，对于-3，可以表达为0-3，而0xFFFFFFD+3等于0 (进位丢失),所以-3的补码也就是0xFFFFFFD了。相应地，0xFFFFFFD 作为一个补码，最高位为1,视为负数，转换回真值同样也可以用0-0xFFFFFFD的方式，于是得到-3。为了计算方便，人们也常用取反加一的方式来求得补码，因为对于任何4字节的数值x，都有x+x(反)&#x3D;0xFFFFFFF,于是x+x(反)+1&#x3D;0,接下来就可以推导出0-x&#x3D;x(反)+1了。 如设有符号数x, y,求x-y的值，我们可以推导出x-y&#x3D;x+(0-‘y’)，根据补码的规则，当y为负数的时候，0-‘y’等价于y的补码。对于y的补码，我们记为y(补),所以x-y&#x3D;x+y (补)。例如，(3-2)可会转换成(3+ (-2))，运算过程为: 3的十六进制原码0x00000003加上-2的十六进制补码0xFFFFFFFE，从而得到0x100000001。由于存储范围为4字节大小，两数相加后产生了进位，超出了存储范围，超出的1将被舍弃。进位被舍弃后，结果为0x00000001。","categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"}],"tags":[]},{"title":"IDA常用快捷键","slug":"IDA几种常用快捷键","date":"2023-10-27T16:35:42.000Z","updated":"2023-10-28T13:40:30.009Z","comments":true,"path":"2023/10/28/IDA几种常用快捷键/","link":"","permalink":"http://example.com/2023/10/28/IDA%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"IDA 几种常用快捷键IDA&nbsp;是反汇编程序 ，反汇编程序是一种软件，用于将机器代码转换为人类可读的格式，称为汇编语言。而且 IDA 是用作静态分析的，IDA 是神器，尤其是你一个 F5 能看到伪代码，然后修改修改贴到 C 程序里直接能编译运行的时候，你就会深刻感受到 IDA 的强大。 IDA 里有很多强大的功能，其中很多功能我们可以用快捷键来快速实现 1. F5 与 TabF5 键和 Tab 键的功能是基本一样的，都可以用来反编译，也就是查看伪代码，一般我们用 IDA 打开一个程序是下面这个样子的： 而这种形式我们看不懂，或者不太能看懂，那么我们就可以用 IDA 强大的功能查看它的伪代码，那我们要怎样可以快速查看呢，就是 F5，我们按 F5 就能进入下面这个窗口，这样是不是就亲切多了 当然，按 tab 键也能实现上面的功能（ tab 键就是大写锁定上面那个），不过 tab 键相较于 F5 多一个小功能，那就是返回原本的形式，我们可以自己打开一个试试看 2. Shift + F12shift + f12 是一个重要的功能，它的功能就是把所有的字符串都整理出来 像上图这样，我们就可以看到所有的字符串信息，我们可以选中一个 双击 这样我们就能看到这段字符串的一些有用信息 善用 shift + f12 是很重要的，这对我们找到我们想要的信息有很大的帮助 3. Ctrl + XCtrl + X 也是一个非常重要的功能，它可以帮我们找到一段信息在哪里被调用了，比如说上面讲 Shift + f12 的时候，我们找到了”You are correct!”所在的位置，那么哪里调用了它呢，这时候 Ctrl + X 的作用就体现出来了，Ctrl + X 也被称为 交叉引用 ，我们选中字符串 “You are correct!” 然后使用 Ctrl + X， 这样就会告诉你都有哪些地方调用了这段字符串，这里显示只有一处调用了它，我们可以双击那个蓝条条，直接进入调用它的地方 然后我们到了这里，这个时候我们就用 F5 或者 tab 键查看伪代码 这样，我们就知道我们找的这段字符串在哪里出现的了 4. EscEsc 我们都很熟悉，就是退出、退回，所以当我们点进一个函数的时候，查找了一个数据后，用 esc 返回上一层，比如进来了这个_main()函数 我们点 esc 就能回去了 5. Shift + EShift + E 可以用来提取数据，比如说下图一个叫 aZyxwvutsrqponm 的 它的数据是后面绿色的部分，但是，我们发现，这串绿色的字中间有参杂着不是数据的东西（注意看单引号从哪开始，在哪结束），而且有些数据没有放在同一行，我们很容易弄混，这个时候 Shift + E 就有大作用了 我们选中 aZyxwvutsrqponm，然后使用 shift + e ，这个时候它就显示了 aZyxwvutsrqponm 的数据 我们还可以选择输出的形式，比如上图就是 16 进制的形式，我们还可以把它弄成 10 进制的 （还有字符形式等形式） 当然我们还可以导出这段数据，点击下面的 Export 就可以了，这时它就会生成一个文本文件到你的程序的目录下 6. &#x2F; (添加注释)我们在分析的时候，添加注释是个好习惯，这能够让我们保持清晰的思路，而且不会遗忘之前看懂的东西，那么怎么直接在 IDA 上添加注释呢？ 我们选中一行，直接点 左斜杠 &#x2F; 就好 当然，直接 右键 → Edit comment… 也是可以添加注释的 7. \\ (隐藏类型描述)很多时候，在反编译后伪代码的界面中会有变量和函数的类型描述，当这些描述太多的时候，会影响我们对代码的判断，这个时候我们可以使用 右斜杠 \\ 来隐藏掉这些描述 不过有的时候，这些描述是必要的，我们可以再使用一次 右斜杠 \\ 来显示这些描述 当然，我们也可以通过 右键 → Hide casts &#x2F; Show casts 来隐藏或者显示描述 8. Alt + Talt + t 可以用来搜索字符串，我们可以在 ida 里试试， 使用 alt + t 后会出现上面的窗口，然后我们在 String 那里填你想要输入的字符串，比如我想找 right 在哪 这样 ida 就会帮你找到 right 的位置 9. Alt + Lalt + l 的作用就是标记，可以自己在 ida 里尝试一下， 选择一处然后按 alt + l ，可以明显看到变化 10. Alt + Malt + m 和之前讲的添加注释很像，我们在 ida 里试试， 选中一行，然后按 alt + m， 就会出现下面这个窗口，然后我们先随便输入一个东西， 点击 OK 后，我们可以看到操作后的那一行变了色， 我们把鼠标放过去，就可以看到我们刚刚输入的东西 11. N 键n 键的作用是重命名，很简单，就是 ida 可以帮你把一个变量的名字换成你输入的名称，而且每处调用该变量的地方都会帮你修改，我们来试试， 我们选中一个变量，可以看到，黄底的都是这个变量，我们按 N 键， 这样就出现了下面那样的窗口，我们可以重命名这个变量了， 我们把它改成 input， 我们可以看到，原本叫 byte_4212C0 的都改成了我们输入的 input 12. G 键g 键可以跳转到我们想要去的地址处，比如我们记住了下面那处地址后，到了其他地址后想回来，就可以用 g 键，输入，然后跳转，就回来了 13. A 键a 键的作用呢，不好说，不过看了实例后就会明白了， 像下图的这样明显是字符串的，这种形式我们不好看，那么我们选中首地址后按一下 a 键后会怎么样呢？ 瞧，它就变成了这样，是不是好看多了 14. Ctrl + Z说了这么多操作，那么如果不小心用错了怎么办，没事，ida 还有撤回操作 没错，就是 ctrl + z ，快去试一试吧！ 15. 其它以上 14 种是我最常用的，还有其他的快捷键没有介绍，有兴趣的可以查找相关信息了解一下","categories":[{"name":"IDA 学习记录","slug":"IDA-学习记录","permalink":"http://example.com/categories/IDA-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-10-27T14:43:22.000Z","updated":"2023-10-28T13:40:31.392Z","comments":true,"path":"2023/10/27/hello-world/","link":"","permalink":"http://example.com/2023/10/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Start","slug":"Start","permalink":"http://example.com/categories/Start/"}],"tags":[]}],"categories":[{"name":"C++反汇编与逆向分析技术揭秘","slug":"C-反汇编与逆向分析技术揭秘","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/"},{"name":"3、观察各种表达式的求值过程","slug":"C-反汇编与逆向分析技术揭秘/3、观察各种表达式的求值过程","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/3%E3%80%81%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E8%BF%87%E7%A8%8B/"},{"name":"2、认识启动函数，找到用户入口","slug":"C-反汇编与逆向分析技术揭秘/2、认识启动函数，找到用户入口","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/2%E3%80%81%E8%AE%A4%E8%AF%86%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%BE%E5%88%B0%E7%94%A8%E6%88%B7%E5%85%A5%E5%8F%A3/"},{"name":"1、基本数据类型的表现形式","slug":"C-反汇编与逆向分析技术揭秘/1、基本数据类型的表现形式","permalink":"http://example.com/categories/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/"},{"name":"IDA 学习记录","slug":"IDA-学习记录","permalink":"http://example.com/categories/IDA-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"Start","slug":"Start","permalink":"http://example.com/categories/Start/"}],"tags":[]}